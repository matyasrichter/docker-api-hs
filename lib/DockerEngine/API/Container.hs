{-
   Docker Engine API

   The Engine API is an HTTP API served by Docker Engine. It is the API the Docker client uses to communicate with the Engine, so everything the Docker client can do can be done with the API.  Most of the client's commands map directly to API endpoints (e.g. `docker ps` is `GET /containers/json`). The notable exception is running containers, which consists of several API calls.  # Errors  The API uses standard HTTP status codes to indicate the success or failure of the API call. The body of the response will be JSON in the following format:  ``` {   \"message\": \"page not found\" } ```  # Versioning  The API is usually changed in each release, so API calls are versioned to ensure that clients don't break. To lock to a specific version of the API, you prefix the URL with its version, for example, call `/v1.30/info` to use the v1.30 version of the `/info` endpoint. If the API version specified in the URL is not supported by the daemon, a HTTP `400 Bad Request` error message is returned.  If you omit the version-prefix, the current version of the API (v1.41) is used. For example, calling `/info` is the same as calling `/v1.41/info`. Using the API without a version-prefix is deprecated and will be removed in a future release.  Engine releases in the near future should support this version of the API, so your client will continue to work even if it is talking to a newer Engine.  The API uses an open schema model, which means server may add extra properties to responses. Likewise, the server will ignore any extra query parameters and request body properties. When you write clients, you need to ignore additional properties in responses to ensure they do not break when talking to newer daemons.   # Authentication  Authentication for registries is handled client side. The client has to send authentication details to various endpoints that need to communicate with registries, such as `POST /images/(name)/push`. These are sent as `X-Registry-Auth` header as a [base64url encoded](https://tools.ietf.org/html/rfc4648#section-5) (JSON) string with the following structure:  ``` {   \"username\": \"string\",   \"password\": \"string\",   \"email\": \"string\",   \"serveraddress\": \"string\" } ```  The `serveraddress` is a domain/IP without a protocol. Throughout this structure, double quotes are required.  If you have already got an identity token from the [`/auth` endpoint](#operation/SystemAuth), you can just pass this instead of credentials:  ``` {   \"identitytoken\": \"9cbaf023786cd7...\" } ``` 

   OpenAPI Version: 3.0.1
   Docker Engine API API version: 1.41
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : DockerEngine.API.Container
-}

{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MonoLocalBinds #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing -fno-warn-unused-binds -fno-warn-unused-imports #-}

module DockerEngine.API.Container where

import DockerEngine.Core
import DockerEngine.MimeTypes
import DockerEngine.Model as M

import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Proxy as P (Proxy(..))
import qualified Data.Set as Set
import qualified Data.String as P
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Text.Lazy as TL
import qualified Data.Text.Lazy.Encoding as TL
import qualified Data.Time as TI
import qualified Network.HTTP.Client.MultipartFormData as NH
import qualified Network.HTTP.Media as ME
import qualified Network.HTTP.Types as NH
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Data.Text (Text)
import GHC.Base ((<|>))

import Prelude ((==),(/=),($), (.),(<$>),(<*>),(>>=),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)
import qualified Prelude as P

-- * Operations


-- ** Container

-- *** containerArchive

-- | @GET \/containers\/{id}\/archive@
-- 
-- Get an archive of a filesystem resource in a container
-- 
-- Get a tar archive of a resource in the filesystem of container id.
-- 
containerArchive
  :: Id -- ^ "id" -  ID or name of the container
  -> Path -- ^ "path" -  Resource in the container’s filesystem to archive.
  -> DockerEngineRequest ContainerArchive MimeNoContent NoContent MimeNoContent
containerArchive (Id id) (Path path) =
  _mkRequest "GET" ["/containers/",toPath id,"/archive"]
    `addQuery` toQuery ("path", Just path)

data ContainerArchive  
instance Produces ContainerArchive MimeNoContent


-- *** containerArchiveInfo

-- | @HEAD \/containers\/{id}\/archive@
-- 
-- Get information about files in a container
-- 
-- A response header `X-Docker-Container-Path-Stat` is returned, containing a base64 - encoded JSON object with some filesystem header information about the path. 
-- 
containerArchiveInfo
  :: Id -- ^ "id" -  ID or name of the container
  -> Path -- ^ "path" -  Resource in the container’s filesystem to archive.
  -> DockerEngineRequest ContainerArchiveInfo MimeNoContent NoContent MimeNoContent
containerArchiveInfo (Id id) (Path path) =
  _mkRequest "HEAD" ["/containers/",toPath id,"/archive"]
    `addQuery` toQuery ("path", Just path)

data ContainerArchiveInfo  
instance Produces ContainerArchiveInfo MimeNoContent


-- *** containerAttach

-- | @POST \/containers\/{id}\/attach@
-- 
-- Attach to a container
-- 
-- Attach to a container to read its output or send it input. You can attach to the same container multiple times and you can reattach to containers that have been detached.  Either the `stream` or `logs` parameter must be `true` for this endpoint to do anything.  See the [documentation for the `docker attach` command](/engine/reference/commandline/attach/) for more details.  ### Hijacking  This endpoint hijacks the HTTP connection to transport `stdin`, `stdout`, and `stderr` on the same socket.  This is the response from the daemon for an attach request:  ``` HTTP/1.1 200 OK Content-Type: application/vnd.docker.raw-stream  [STREAM] ```  After the headers and two new lines, the TCP connection can now be used for raw, bidirectional communication between the client and server.  To hint potential proxies about connection hijacking, the Docker client can also optionally send connection upgrade headers.  For example, the client sends this request to upgrade the connection:  ``` POST /containers/16253994b7c4/attach?stream=1&stdout=1 HTTP/1.1 Upgrade: tcp Connection: Upgrade ```  The Docker daemon will respond with a `101 UPGRADED` response, and will similarly follow with the raw stream:  ``` HTTP/1.1 101 UPGRADED Content-Type: application/vnd.docker.raw-stream Connection: Upgrade Upgrade: tcp  [STREAM] ```  ### Stream format  When the TTY setting is disabled in [`POST /containers/create`](#operation/ContainerCreate), the stream over the hijacked connected is multiplexed to separate out `stdout` and `stderr`. The stream consists of a series of frames, each containing a header and a payload.  The header contains the information which the stream writes (`stdout` or `stderr`). It also contains the size of the associated frame encoded in the last four bytes (`uint32`).  It is encoded on the first eight bytes like this:  ```go header := [8]byte{STREAM_TYPE, 0, 0, 0, SIZE1, SIZE2, SIZE3, SIZE4} ```  `STREAM_TYPE` can be:  - 0: `stdin` (is written on `stdout`) - 1: `stdout` - 2: `stderr`  `SIZE1, SIZE2, SIZE3, SIZE4` are the four bytes of the `uint32` size encoded as big endian.  Following the header is the payload, which is the specified number of bytes of `STREAM_TYPE`.  The simplest way to implement this protocol is the following:  1. Read 8 bytes. 2. Choose `stdout` or `stderr` depending on the first byte. 3. Extract the frame size from the last four bytes. 4. Read the extracted size and output it on the correct output. 5. Goto 1.  ### Stream format when using a TTY  When the TTY setting is enabled in [`POST /containers/create`](#operation/ContainerCreate), the stream is not multiplexed. The data exchanged over the hijacked connection is simply the raw data from the process PTY and client's `stdin`. 
-- 
containerAttach
  :: Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerAttach MimeNoContent NoContent MimeNoContent
containerAttach (Id id) =
  _mkRequest "POST" ["/containers/",toPath id,"/attach"]

data ContainerAttach  

-- | /Optional Param/ "detachKeys" - Override the key sequence for detaching a container.Format is a single character `[a-Z]` or `ctrl-<value>` where `<value>` is one of: `a-z`, `@`, `^`, `[`, `,` or `_`. 
instance HasOptionalParam ContainerAttach DetachKeys where
  applyOptionalParam req (DetachKeys xs) =
    req `addQuery` toQuery ("detachKeys", Just xs)

-- | /Optional Param/ "logs" - Replay previous logs from the container.  This is useful for attaching to a container that has started and you want to output everything since the container started.  If `stream` is also enabled, once all the previous output has been returned, it will seamlessly transition into streaming current output. 
instance HasOptionalParam ContainerAttach Logs where
  applyOptionalParam req (Logs xs) =
    req `addQuery` toQuery ("logs", Just xs)

-- | /Optional Param/ "stream" - Stream attached streams from the time the request was made onwards. 
instance HasOptionalParam ContainerAttach Stream where
  applyOptionalParam req (Stream xs) =
    req `addQuery` toQuery ("stream", Just xs)

-- | /Optional Param/ "stdin" - Attach to `stdin`
instance HasOptionalParam ContainerAttach Stdin where
  applyOptionalParam req (Stdin xs) =
    req `addQuery` toQuery ("stdin", Just xs)

-- | /Optional Param/ "stdout" - Attach to `stdout`
instance HasOptionalParam ContainerAttach Stdout where
  applyOptionalParam req (Stdout xs) =
    req `addQuery` toQuery ("stdout", Just xs)

-- | /Optional Param/ "stderr" - Attach to `stderr`
instance HasOptionalParam ContainerAttach Stderr where
  applyOptionalParam req (Stderr xs) =
    req `addQuery` toQuery ("stderr", Just xs)
instance Produces ContainerAttach MimeNoContent


-- *** containerAttachWebsocket

-- | @GET \/containers\/{id}\/attach\/ws@
-- 
-- Attach to a container via a websocket
-- 
containerAttachWebsocket
  :: Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerAttachWebsocket MimeNoContent NoContent MimeNoContent
containerAttachWebsocket (Id id) =
  _mkRequest "GET" ["/containers/",toPath id,"/attach/ws"]

data ContainerAttachWebsocket  

-- | /Optional Param/ "detachKeys" - Override the key sequence for detaching a container.Format is a single character `[a-Z]` or `ctrl-<value>` where `<value>` is one of: `a-z`, `@`, `^`, `[`, `,`, or `_`. 
instance HasOptionalParam ContainerAttachWebsocket DetachKeys where
  applyOptionalParam req (DetachKeys xs) =
    req `addQuery` toQuery ("detachKeys", Just xs)

-- | /Optional Param/ "logs" - Return logs
instance HasOptionalParam ContainerAttachWebsocket Logs where
  applyOptionalParam req (Logs xs) =
    req `addQuery` toQuery ("logs", Just xs)

-- | /Optional Param/ "stream" - Return stream
instance HasOptionalParam ContainerAttachWebsocket Stream where
  applyOptionalParam req (Stream xs) =
    req `addQuery` toQuery ("stream", Just xs)

-- | /Optional Param/ "stdin" - Attach to `stdin`
instance HasOptionalParam ContainerAttachWebsocket Stdin where
  applyOptionalParam req (Stdin xs) =
    req `addQuery` toQuery ("stdin", Just xs)

-- | /Optional Param/ "stdout" - Attach to `stdout`
instance HasOptionalParam ContainerAttachWebsocket Stdout where
  applyOptionalParam req (Stdout xs) =
    req `addQuery` toQuery ("stdout", Just xs)

-- | /Optional Param/ "stderr" - Attach to `stderr`
instance HasOptionalParam ContainerAttachWebsocket Stderr where
  applyOptionalParam req (Stderr xs) =
    req `addQuery` toQuery ("stderr", Just xs)
instance Produces ContainerAttachWebsocket MimeNoContent


-- *** containerChanges

-- | @GET \/containers\/{id}\/changes@
-- 
-- Get changes on a container’s filesystem
-- 
-- Returns which files in a container's filesystem have been added, deleted, or modified. The `Kind` of modification can be one of:  - `0`: Modified - `1`: Added - `2`: Deleted 
-- 
containerChanges
  :: Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerChanges MimeNoContent [ContainerChangeResponseItem] MimeJSON
containerChanges (Id id) =
  _mkRequest "GET" ["/containers/",toPath id,"/changes"]

data ContainerChanges  
-- | @application/json@
instance Produces ContainerChanges MimeJSON


-- *** containerCreate

-- | @POST \/containers\/create@
-- 
-- Create a container
-- 
containerCreate
  :: (Consumes ContainerCreate contentType, MimeRender contentType ContainerConfig)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> ContainerConfig -- ^ "body" -  Container to create
  -> DockerEngineRequest ContainerCreate contentType ContainerCreateResponse MimeJSON
containerCreate _ body =
  _mkRequest "POST" ["/containers/create"]
    `setBodyParam` body

data ContainerCreate 

-- | /Body Param/ "body" - Container to create
instance HasBodyParam ContainerCreate ContainerConfig 

-- | /Optional Param/ "name" - Assign the specified name to the container. Must match `/?[a-zA-Z0-9][a-zA-Z0-9_.-]+`. 
instance HasOptionalParam ContainerCreate Name where
  applyOptionalParam req (Name xs) =
    req `addQuery` toQuery ("name", Just xs)

-- | @application/octet-stream@
instance Consumes ContainerCreate MimeOctetStream
-- | @application/json@
instance Consumes ContainerCreate MimeJSON

-- | @application/json@
instance Produces ContainerCreate MimeJSON


-- *** containerDelete

-- | @DELETE \/containers\/{id}@
-- 
-- Remove a container
-- 
containerDelete
  :: Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerDelete MimeNoContent NoContent MimeNoContent
containerDelete (Id id) =
  _mkRequest "DELETE" ["/containers/",toPath id]

data ContainerDelete  

-- | /Optional Param/ "v" - Remove anonymous volumes associated with the container.
instance HasOptionalParam ContainerDelete V where
  applyOptionalParam req (V xs) =
    req `addQuery` toQuery ("v", Just xs)

-- | /Optional Param/ "force" - If the container is running, kill it before removing it.
instance HasOptionalParam ContainerDelete Force where
  applyOptionalParam req (Force xs) =
    req `addQuery` toQuery ("force", Just xs)

-- | /Optional Param/ "link" - Remove the specified link associated with the container.
instance HasOptionalParam ContainerDelete Link where
  applyOptionalParam req (Link xs) =
    req `addQuery` toQuery ("link", Just xs)
instance Produces ContainerDelete MimeNoContent


-- *** containerExport

-- | @GET \/containers\/{id}\/export@
-- 
-- Export a container
-- 
-- Export the contents of a container as a tarball.
-- 
containerExport
  :: Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerExport MimeNoContent NoContent MimeNoContent
containerExport (Id id) =
  _mkRequest "GET" ["/containers/",toPath id,"/export"]

data ContainerExport  
instance Produces ContainerExport MimeNoContent


-- *** containerInspect

-- | @GET \/containers\/{id}\/json@
-- 
-- Inspect a container
-- 
-- Return low-level information about a container.
-- 
containerInspect
  :: Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerInspect MimeNoContent ContainerInspectResponse MimeJSON
containerInspect (Id id) =
  _mkRequest "GET" ["/containers/",toPath id,"/json"]

data ContainerInspect  

-- | /Optional Param/ "size" - Return the size of container as fields `SizeRw` and `SizeRootFs`
instance HasOptionalParam ContainerInspect Size where
  applyOptionalParam req (Size xs) =
    req `addQuery` toQuery ("size", Just xs)
-- | @application/json@
instance Produces ContainerInspect MimeJSON


-- *** containerKill

-- | @POST \/containers\/{id}\/kill@
-- 
-- Kill a container
-- 
-- Send a POSIX signal to a container, defaulting to killing to the container. 
-- 
containerKill
  :: Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerKill MimeNoContent NoContent MimeNoContent
containerKill (Id id) =
  _mkRequest "POST" ["/containers/",toPath id,"/kill"]

data ContainerKill  

-- | /Optional Param/ "signal" - Signal to send to the container as an integer or string (e.g. `SIGINT`)
instance HasOptionalParam ContainerKill Signal where
  applyOptionalParam req (Signal xs) =
    req `addQuery` toQuery ("signal", Just xs)
instance Produces ContainerKill MimeNoContent


-- *** containerList

-- | @GET \/containers\/json@
-- 
-- List containers
-- 
-- Returns a list of containers. For details on the format, see the [inspect endpoint](#operation/ContainerInspect).  Note that it uses a different, smaller representation of a container than inspecting a single container. For example, the list of linked containers is not propagated . 
-- 
containerList
  :: DockerEngineRequest ContainerList MimeNoContent [ContainerSummary] MimeJSON
containerList =
  _mkRequest "GET" ["/containers/json"]

data ContainerList  

-- | /Optional Param/ "all" - Return all containers. By default, only running containers are shown. 
instance HasOptionalParam ContainerList All where
  applyOptionalParam req (All xs) =
    req `addQuery` toQuery ("all", Just xs)

-- | /Optional Param/ "limit" - Return this number of most recently created containers, including non-running ones. 
instance HasOptionalParam ContainerList Limit2 where
  applyOptionalParam req (Limit2 xs) =
    req `addQuery` toQuery ("limit", Just xs)

-- | /Optional Param/ "size" - Return the size of container as fields `SizeRw` and `SizeRootFs`. 
instance HasOptionalParam ContainerList Size where
  applyOptionalParam req (Size xs) =
    req `addQuery` toQuery ("size", Just xs)

-- | /Optional Param/ "filters" - Filters to process on the container list, encoded as JSON (a `map[string][]string`). For example, `{\"status\": [\"paused\"]}` will only return paused containers.  Available filters:  - `ancestor`=(`<image-name>[:<tag>]`, `<image id>`, or `<image@digest>`) - `before`=(`<container id>` or `<container name>`) - `expose`=(`<port>[/<proto>]`|`<startport-endport>/[<proto>]`) - `exited=<int>` containers with exit code of `<int>` - `health`=(`starting`|`healthy`|`unhealthy`|`none`) - `id=<ID>` a container's ID - `isolation=`(`default`|`process`|`hyperv`) (Windows daemon only) - `is-task=`(`true`|`false`) - `label=key` or `label=\"key=value\"` of a container label - `name=<name>` a container's name - `network`=(`<network id>` or `<network name>`) - `publish`=(`<port>[/<proto>]`|`<startport-endport>/[<proto>]`) - `since`=(`<container id>` or `<container name>`) - `status=`(`created`|`restarting`|`running`|`removing`|`paused`|`exited`|`dead`) - `volume`=(`<volume name>` or `<mount point destination>`) 
instance HasOptionalParam ContainerList Filters where
  applyOptionalParam req (Filters xs) =
    req `addQuery` toQuery ("filters", Just xs)
-- | @application/json@
instance Produces ContainerList MimeJSON


-- *** containerLogs

-- | @GET \/containers\/{id}\/logs@
-- 
-- Get container logs
-- 
-- Get `stdout` and `stderr` logs from a container.  Note: This endpoint works only for containers with the `json-file` or `journald` logging driver. 
-- 
containerLogs
  :: Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerLogs MimeNoContent FilePath accept
containerLogs  _ (Id id) =
  _mkRequest "GET" ["/containers/",toPath id,"/logs"]

data ContainerLogs  

-- | /Optional Param/ "follow" - Keep connection after returning logs.
instance HasOptionalParam ContainerLogs Follow where
  applyOptionalParam req (Follow xs) =
    req `addQuery` toQuery ("follow", Just xs)

-- | /Optional Param/ "stdout" - Return logs from `stdout`
instance HasOptionalParam ContainerLogs Stdout where
  applyOptionalParam req (Stdout xs) =
    req `addQuery` toQuery ("stdout", Just xs)

-- | /Optional Param/ "stderr" - Return logs from `stderr`
instance HasOptionalParam ContainerLogs Stderr where
  applyOptionalParam req (Stderr xs) =
    req `addQuery` toQuery ("stderr", Just xs)

-- | /Optional Param/ "since" - Only return logs since this time, as a UNIX timestamp
instance HasOptionalParam ContainerLogs Since where
  applyOptionalParam req (Since xs) =
    req `addQuery` toQuery ("since", Just xs)

-- | /Optional Param/ "until" - Only return logs before this time, as a UNIX timestamp
instance HasOptionalParam ContainerLogs Until where
  applyOptionalParam req (Until xs) =
    req `addQuery` toQuery ("until", Just xs)

-- | /Optional Param/ "timestamps" - Add timestamps to every log line
instance HasOptionalParam ContainerLogs Timestamps where
  applyOptionalParam req (Timestamps xs) =
    req `addQuery` toQuery ("timestamps", Just xs)

-- | /Optional Param/ "tail" - Only return this number of log lines from the end of the logs. Specify as an integer or `all` to output all log lines. 
instance HasOptionalParam ContainerLogs Tail where
  applyOptionalParam req (Tail xs) =
    req `addQuery` toQuery ("tail", Just xs)
-- | @application/json@
instance Produces ContainerLogs MimeJSON
-- | @text/plain@
instance Produces ContainerLogs MimePlainText


-- *** containerPause

-- | @POST \/containers\/{id}\/pause@
-- 
-- Pause a container
-- 
-- Use the freezer cgroup to suspend all processes in a container.  Traditionally, when suspending a process the `SIGSTOP` signal is used, which is observable by the process being suspended. With the freezer cgroup the process is unaware, and unable to capture, that it is being suspended, and subsequently resumed. 
-- 
containerPause
  :: Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerPause MimeNoContent NoContent MimeNoContent
containerPause (Id id) =
  _mkRequest "POST" ["/containers/",toPath id,"/pause"]

data ContainerPause  
instance Produces ContainerPause MimeNoContent


-- *** containerPrune

-- | @POST \/containers\/prune@
-- 
-- Delete stopped containers
-- 
containerPrune
  :: DockerEngineRequest ContainerPrune MimeNoContent ContainerPruneResponse MimeJSON
containerPrune =
  _mkRequest "POST" ["/containers/prune"]

data ContainerPrune  

-- | /Optional Param/ "filters" - Filters to process on the prune list, encoded as JSON (a `map[string][]string`).  Available filters: - `until=<timestamp>` Prune containers created before this timestamp. The `<timestamp>` can be Unix timestamps, date formatted timestamps, or Go duration strings (e.g. `10m`, `1h30m`) computed relative to the daemon machine’s time. - `label` (`label=<key>`, `label=<key>=<value>`, `label!=<key>`, or `label!=<key>=<value>`) Prune containers with (or without, in case `label!=...` is used) the specified labels. 
instance HasOptionalParam ContainerPrune Filters where
  applyOptionalParam req (Filters xs) =
    req `addQuery` toQuery ("filters", Just xs)
-- | @application/json@
instance Produces ContainerPrune MimeJSON


-- *** containerRename

-- | @POST \/containers\/{id}\/rename@
-- 
-- Rename a container
-- 
containerRename
  :: Id -- ^ "id" -  ID or name of the container
  -> Name -- ^ "name" -  New name for the container
  -> DockerEngineRequest ContainerRename MimeNoContent NoContent MimeNoContent
containerRename (Id id) (Name name) =
  _mkRequest "POST" ["/containers/",toPath id,"/rename"]
    `addQuery` toQuery ("name", Just name)

data ContainerRename  
instance Produces ContainerRename MimeNoContent


-- *** containerResize

-- | @POST \/containers\/{id}\/resize@
-- 
-- Resize a container TTY
-- 
-- Resize the TTY for a container.
-- 
containerResize
  :: Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerResize MimeNoContent NoContent MimeNoContent
containerResize (Id id) =
  _mkRequest "POST" ["/containers/",toPath id,"/resize"]

data ContainerResize  

-- | /Optional Param/ "h" - Height of the TTY session in characters
instance HasOptionalParam ContainerResize H where
  applyOptionalParam req (H xs) =
    req `addQuery` toQuery ("h", Just xs)

-- | /Optional Param/ "w" - Width of the TTY session in characters
instance HasOptionalParam ContainerResize W where
  applyOptionalParam req (W xs) =
    req `addQuery` toQuery ("w", Just xs)
instance Produces ContainerResize MimeNoContent


-- *** containerRestart

-- | @POST \/containers\/{id}\/restart@
-- 
-- Restart a container
-- 
containerRestart
  :: Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerRestart MimeNoContent NoContent MimeNoContent
containerRestart (Id id) =
  _mkRequest "POST" ["/containers/",toPath id,"/restart"]

data ContainerRestart  

-- | /Optional Param/ "t" - Number of seconds to wait before killing the container
instance HasOptionalParam ContainerRestart T where
  applyOptionalParam req (T xs) =
    req `addQuery` toQuery ("t", Just xs)
instance Produces ContainerRestart MimeNoContent


-- *** containerStart

-- | @POST \/containers\/{id}\/start@
-- 
-- Start a container
-- 
containerStart
  :: Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerStart MimeNoContent NoContent MimeNoContent
containerStart (Id id) =
  _mkRequest "POST" ["/containers/",toPath id,"/start"]

data ContainerStart  

-- | /Optional Param/ "detachKeys" - Override the key sequence for detaching a container. Format is a single character `[a-Z]` or `ctrl-<value>` where `<value>` is one of: `a-z`, `@`, `^`, `[`, `,` or `_`. 
instance HasOptionalParam ContainerStart DetachKeys where
  applyOptionalParam req (DetachKeys xs) =
    req `addQuery` toQuery ("detachKeys", Just xs)
instance Produces ContainerStart MimeNoContent


-- *** containerStats

-- | @GET \/containers\/{id}\/stats@
-- 
-- Get container stats based on resource usage
-- 
-- This endpoint returns a live stream of a container’s resource usage statistics.  The `precpu_stats` is the CPU statistic of the *previous* read, and is used to calculate the CPU usage percentage. It is not an exact copy of the `cpu_stats` field.  If either `precpu_stats.online_cpus` or `cpu_stats.online_cpus` is nil then for compatibility with older daemons the length of the corresponding `cpu_usage.percpu_usage` array should be used.  On a cgroup v2 host, the following fields are not set * `blkio_stats`: all fields other than `io_service_bytes_recursive` * `cpu_stats`: `cpu_usage.percpu_usage` * `memory_stats`: `max_usage` and `failcnt` Also, `memory_stats.stats` fields are incompatible with cgroup v1.  To calculate the values shown by the `stats` command of the docker cli tool the following formulas can be used: * used_memory = `memory_stats.usage - memory_stats.stats.cache` * available_memory = `memory_stats.limit` * Memory usage % = `(used_memory / available_memory) * 100.0` * cpu_delta = `cpu_stats.cpu_usage.total_usage - precpu_stats.cpu_usage.total_usage` * system_cpu_delta = `cpu_stats.system_cpu_usage - precpu_stats.system_cpu_usage` * number_cpus = `lenght(cpu_stats.cpu_usage.percpu_usage)` or `cpu_stats.online_cpus` * CPU usage % = `(cpu_delta / system_cpu_delta) * number_cpus * 100.0` 
-- 
containerStats
  :: Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerStats MimeNoContent A.Value MimeJSON
containerStats (Id id) =
  _mkRequest "GET" ["/containers/",toPath id,"/stats"]

data ContainerStats  

-- | /Optional Param/ "stream" - Stream the output. If false, the stats will be output once and then it will disconnect. 
instance HasOptionalParam ContainerStats Stream where
  applyOptionalParam req (Stream xs) =
    req `addQuery` toQuery ("stream", Just xs)

-- | /Optional Param/ "one-shot" - Only get a single stat instead of waiting for 2 cycles. Must be used with `stream=false`. 
instance HasOptionalParam ContainerStats OneShot where
  applyOptionalParam req (OneShot xs) =
    req `addQuery` toQuery ("one-shot", Just xs)
-- | @application/json@
instance Produces ContainerStats MimeJSON


-- *** containerStop

-- | @POST \/containers\/{id}\/stop@
-- 
-- Stop a container
-- 
containerStop
  :: Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerStop MimeNoContent NoContent MimeNoContent
containerStop (Id id) =
  _mkRequest "POST" ["/containers/",toPath id,"/stop"]

data ContainerStop  

-- | /Optional Param/ "t" - Number of seconds to wait before killing the container
instance HasOptionalParam ContainerStop T where
  applyOptionalParam req (T xs) =
    req `addQuery` toQuery ("t", Just xs)
instance Produces ContainerStop MimeNoContent


-- *** containerTop

-- | @GET \/containers\/{id}\/top@
-- 
-- List processes running inside a container
-- 
-- On Unix systems, this is done by running the `ps` command. This endpoint is not supported on Windows. 
-- 
containerTop
  :: Accept accept -- ^ request accept ('MimeType')
  -> Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerTop MimeNoContent ContainerTopResponse accept
containerTop  _ (Id id) =
  _mkRequest "GET" ["/containers/",toPath id,"/top"]

data ContainerTop  

-- | /Optional Param/ "ps_args" - The arguments to pass to `ps`. For example, `aux`
instance HasOptionalParam ContainerTop PsArgs where
  applyOptionalParam req (PsArgs xs) =
    req `addQuery` toQuery ("ps_args", Just xs)
-- | @application/json@
instance Produces ContainerTop MimeJSON
-- | @text/plain@
instance Produces ContainerTop MimePlainText


-- *** containerUnpause

-- | @POST \/containers\/{id}\/unpause@
-- 
-- Unpause a container
-- 
-- Resume a container which has been paused.
-- 
containerUnpause
  :: Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerUnpause MimeNoContent NoContent MimeNoContent
containerUnpause (Id id) =
  _mkRequest "POST" ["/containers/",toPath id,"/unpause"]

data ContainerUnpause  
instance Produces ContainerUnpause MimeNoContent


-- *** containerUpdate

-- | @POST \/containers\/{id}\/update@
-- 
-- Update a container
-- 
-- Change various configuration options of a container without having to recreate it. 
-- 
containerUpdate
  :: (Consumes ContainerUpdate MimeJSON, MimeRender MimeJSON ContainerConfig)
  => ContainerConfig -- ^ "update"
  -> Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerUpdate MimeJSON ContainerUpdateResponse MimeJSON
containerUpdate update (Id id) =
  _mkRequest "POST" ["/containers/",toPath id,"/update"]
    `setBodyParam` update

data ContainerUpdate 
instance HasBodyParam ContainerUpdate ContainerConfig 

-- | @application/json@
instance Consumes ContainerUpdate MimeJSON

-- | @application/json@
instance Produces ContainerUpdate MimeJSON


-- *** containerWait

-- | @POST \/containers\/{id}\/wait@
-- 
-- Wait for a container
-- 
-- Block until a container stops, then returns the exit code.
-- 
containerWait
  :: Id -- ^ "id" -  ID or name of the container
  -> DockerEngineRequest ContainerWait MimeNoContent ContainerWaitResponse MimeJSON
containerWait (Id id) =
  _mkRequest "POST" ["/containers/",toPath id,"/wait"]

data ContainerWait  

-- | /Optional Param/ "condition" - Wait until a container state reaches the given condition.  Defaults to `not-running` if omitted or empty. 
instance HasOptionalParam ContainerWait Condition where
  applyOptionalParam req (Condition xs) =
    req `addQuery` toQuery ("condition", Just xs)
-- | @application/json@
instance Produces ContainerWait MimeJSON


-- *** putContainerArchive

-- | @PUT \/containers\/{id}\/archive@
-- 
-- Extract an archive of files or folders to a directory in a container
-- 
-- Upload a tar archive to be extracted to a path in the filesystem of container id. `path` parameter is asserted to be a directory. If it exists as a file, 400 error will be returned with message \"not a directory\". 
-- 
putContainerArchive
  :: (Consumes PutContainerArchive contentType, MimeRender contentType InputStream)
  => ContentType contentType -- ^ request content-type ('MimeType')
  -> InputStream -- ^ "inputStream" -  The input stream must be a tar archive compressed with one of the following algorithms: `identity` (no compression), `gzip`, `bzip2`, or `xz`. 
  -> Id -- ^ "id" -  ID or name of the container
  -> Path -- ^ "path" -  Path to a directory in the container to extract the archive’s contents into. 
  -> DockerEngineRequest PutContainerArchive contentType NoContent MimeNoContent
putContainerArchive _ inputStream (Id id) (Path path) =
  _mkRequest "PUT" ["/containers/",toPath id,"/archive"]
    `setBodyParam` inputStream
    `addQuery` toQuery ("path", Just path)

data PutContainerArchive 

-- | /Body Param/ "inputStream" - The input stream must be a tar archive compressed with one of the following algorithms: `identity` (no compression), `gzip`, `bzip2`, or `xz`. 
instance HasBodyParam PutContainerArchive InputStream 

-- | /Optional Param/ "noOverwriteDirNonDir" - If `1`, `true`, or `True` then it will be an error if unpacking the given content would cause an existing directory to be replaced with a non-directory and vice versa. 
instance HasOptionalParam PutContainerArchive NoOverwriteDirNonDir where
  applyOptionalParam req (NoOverwriteDirNonDir xs) =
    req `addQuery` toQuery ("noOverwriteDirNonDir", Just xs)

-- | /Optional Param/ "copyUIDGID" - If `1`, `true`, then it will copy UID/GID maps to the dest file or dir 
instance HasOptionalParam PutContainerArchive CopyUidgid where
  applyOptionalParam req (CopyUidgid xs) =
    req `addQuery` toQuery ("copyUIDGID", Just xs)

-- | @application/x-tar@
instance Consumes PutContainerArchive MimeXTar
-- | @application/octet-stream@
instance Consumes PutContainerArchive MimeOctetStream

instance Produces PutContainerArchive MimeNoContent

