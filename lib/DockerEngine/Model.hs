{-
   Docker Engine API

   The Engine API is an HTTP API served by Docker Engine. It is the API the Docker client uses to communicate with the Engine, so everything the Docker client can do can be done with the API.  Most of the client's commands map directly to API endpoints (e.g. `docker ps` is `GET /containers/json`). The notable exception is running containers, which consists of several API calls.  # Errors  The API uses standard HTTP status codes to indicate the success or failure of the API call. The body of the response will be JSON in the following format:  ``` {   \"message\": \"page not found\" } ```  # Versioning  The API is usually changed in each release, so API calls are versioned to ensure that clients don't break. To lock to a specific version of the API, you prefix the URL with its version, for example, call `/v1.30/info` to use the v1.30 version of the `/info` endpoint. If the API version specified in the URL is not supported by the daemon, a HTTP `400 Bad Request` error message is returned.  If you omit the version-prefix, the current version of the API (v1.41) is used. For example, calling `/info` is the same as calling `/v1.41/info`. Using the API without a version-prefix is deprecated and will be removed in a future release.  Engine releases in the near future should support this version of the API, so your client will continue to work even if it is talking to a newer Engine.  The API uses an open schema model, which means server may add extra properties to responses. Likewise, the server will ignore any extra query parameters and request body properties. When you write clients, you need to ignore additional properties in responses to ensure they do not break when talking to newer daemons.   # Authentication  Authentication for registries is handled client side. The client has to send authentication details to various endpoints that need to communicate with registries, such as `POST /images/(name)/push`. These are sent as `X-Registry-Auth` header as a [base64url encoded](https://tools.ietf.org/html/rfc4648#section-5) (JSON) string with the following structure:  ``` {   \"username\": \"string\",   \"password\": \"string\",   \"email\": \"string\",   \"serveraddress\": \"string\" } ```  The `serveraddress` is a domain/IP without a protocol. Throughout this structure, double quotes are required.  If you have already got an identity token from the [`/auth` endpoint](#operation/SystemAuth), you can just pass this instead of credentials:  ``` {   \"identitytoken\": \"9cbaf023786cd7...\" } ``` 

   OpenAPI Version: 3.0.1
   Docker Engine API API version: 1.41
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : DockerEngine.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module DockerEngine.Model where

import DockerEngine.Core
import DockerEngine.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** All
newtype All = All { unAll :: Bool } deriving (P.Eq, P.Show)

-- ** Author
newtype Author = Author { unAuthor :: Text } deriving (P.Eq, P.Show)

-- ** Body
newtype Body = Body { unBody :: [PluginPrivilege] } deriving (P.Eq, P.Show, A.ToJSON)

-- ** BodyText
newtype BodyText = BodyText { unBodyText :: [Text] } deriving (P.Eq, P.Show, A.ToJSON)

-- ** Buildargs
newtype Buildargs = Buildargs { unBuildargs :: Text } deriving (P.Eq, P.Show)

-- ** Cachefrom
newtype Cachefrom = Cachefrom { unCachefrom :: Text } deriving (P.Eq, P.Show)

-- ** Changes
newtype Changes = Changes { unChanges :: [Text] } deriving (P.Eq, P.Show)

-- ** ChangesText
newtype ChangesText = ChangesText { unChangesText :: Text } deriving (P.Eq, P.Show)

-- ** Comment
newtype Comment = Comment { unComment :: Text } deriving (P.Eq, P.Show)

-- ** Condition
newtype Condition = Condition { unCondition :: E'Condition2 } deriving (P.Eq, P.Show)

-- ** Container
newtype Container = Container { unContainer :: Text } deriving (P.Eq, P.Show)

-- ** CopyUidgid
newtype CopyUidgid = CopyUidgid { unCopyUidgid :: Text } deriving (P.Eq, P.Show)

-- ** Cpuperiod
newtype Cpuperiod = Cpuperiod { unCpuperiod :: Int } deriving (P.Eq, P.Show)

-- ** Cpuquota
newtype Cpuquota = Cpuquota { unCpuquota :: Int } deriving (P.Eq, P.Show)

-- ** Cpusetcpus
newtype Cpusetcpus = Cpusetcpus { unCpusetcpus :: Text } deriving (P.Eq, P.Show)

-- ** Cpushares
newtype Cpushares = Cpushares { unCpushares :: Int } deriving (P.Eq, P.Show)

-- ** DetachKeys
newtype DetachKeys = DetachKeys { unDetachKeys :: Text } deriving (P.Eq, P.Show)

-- ** Details
newtype Details = Details { unDetails :: Bool } deriving (P.Eq, P.Show)

-- ** Digests
newtype Digests = Digests { unDigests :: Bool } deriving (P.Eq, P.Show)

-- ** Dockerfile
newtype Dockerfile = Dockerfile { unDockerfile :: Text } deriving (P.Eq, P.Show)

-- ** Extrahosts
newtype Extrahosts = Extrahosts { unExtrahosts :: Text } deriving (P.Eq, P.Show)

-- ** Filters
newtype Filters = Filters { unFilters :: Text } deriving (P.Eq, P.Show)

-- ** Follow
newtype Follow = Follow { unFollow :: Bool } deriving (P.Eq, P.Show)

-- ** Force
newtype Force = Force { unForce :: Bool } deriving (P.Eq, P.Show)

-- ** Forcerm
newtype Forcerm = Forcerm { unForcerm :: Bool } deriving (P.Eq, P.Show)

-- ** FromImage
newtype FromImage = FromImage { unFromImage :: Text } deriving (P.Eq, P.Show)

-- ** FromSrc
newtype FromSrc = FromSrc { unFromSrc :: Text } deriving (P.Eq, P.Show)

-- ** H
newtype H = H { unH :: Int } deriving (P.Eq, P.Show)

-- ** Id
newtype Id = Id { unId :: Text } deriving (P.Eq, P.Show)

-- ** ImagesTarball
newtype ImagesTarball = ImagesTarball { unImagesTarball :: FilePath } deriving (P.Eq, P.Show, A.ToJSON)

-- ** InputImage
newtype InputImage = InputImage { unInputImage :: Text } deriving (P.Eq, P.Show, A.ToJSON)

-- ** InputStream
newtype InputStream = InputStream { unInputStream :: FilePath } deriving (P.Eq, P.Show, A.ToJSON)

-- ** InsertDefaults
newtype InsertDefaults = InsertDefaults { unInsertDefaults :: Bool } deriving (P.Eq, P.Show)

-- ** KeepStorage
newtype KeepStorage = KeepStorage { unKeepStorage :: Integer } deriving (P.Eq, P.Show)

-- ** Labels
newtype Labels = Labels { unLabels :: Text } deriving (P.Eq, P.Show)

-- ** Limit2
newtype Limit2 = Limit2 { unLimit2 :: Int } deriving (P.Eq, P.Show)

-- ** Link
newtype Link = Link { unLink :: Bool } deriving (P.Eq, P.Show)

-- ** Logs
newtype Logs = Logs { unLogs :: Bool } deriving (P.Eq, P.Show)

-- ** Memory
newtype Memory = Memory { unMemory :: Int } deriving (P.Eq, P.Show)

-- ** Memswap
newtype Memswap = Memswap { unMemswap :: Int } deriving (P.Eq, P.Show)

-- ** Message
newtype Message = Message { unMessage :: Text } deriving (P.Eq, P.Show)

-- ** Name
newtype Name = Name { unName :: Text } deriving (P.Eq, P.Show)

-- ** Names
newtype Names = Names { unNames :: [Text] } deriving (P.Eq, P.Show)

-- ** Networkmode
newtype Networkmode = Networkmode { unNetworkmode :: Text } deriving (P.Eq, P.Show)

-- ** NoOverwriteDirNonDir
newtype NoOverwriteDirNonDir = NoOverwriteDirNonDir { unNoOverwriteDirNonDir :: Text } deriving (P.Eq, P.Show)

-- ** Nocache
newtype Nocache = Nocache { unNocache :: Bool } deriving (P.Eq, P.Show)

-- ** Noprune
newtype Noprune = Noprune { unNoprune :: Bool } deriving (P.Eq, P.Show)

-- ** OneShot
newtype OneShot = OneShot { unOneShot :: Bool } deriving (P.Eq, P.Show)

-- ** Outputs
newtype Outputs = Outputs { unOutputs :: Text } deriving (P.Eq, P.Show)

-- ** ParamContentType
newtype ParamContentType = ParamContentType { unParamContentType :: E'ContentType } deriving (P.Eq, P.Show)

-- ** Path
newtype Path = Path { unPath :: Text } deriving (P.Eq, P.Show)

-- ** Pause
newtype Pause = Pause { unPause :: Bool } deriving (P.Eq, P.Show)

-- ** Platform2
newtype Platform2 = Platform2 { unPlatform2 :: Text } deriving (P.Eq, P.Show)

-- ** PsArgs
newtype PsArgs = PsArgs { unPsArgs :: Text } deriving (P.Eq, P.Show)

-- ** Pull
newtype Pull = Pull { unPull :: Text } deriving (P.Eq, P.Show)

-- ** Q
newtype Q = Q { unQ :: Bool } deriving (P.Eq, P.Show)

-- ** Quiet
newtype Quiet = Quiet { unQuiet :: Bool } deriving (P.Eq, P.Show)

-- ** RegistryAuthFrom
newtype RegistryAuthFrom = RegistryAuthFrom { unRegistryAuthFrom :: E'RegistryAuthFrom } deriving (P.Eq, P.Show)

-- ** Remote
newtype Remote = Remote { unRemote :: Text } deriving (P.Eq, P.Show)

-- ** Repo
newtype Repo = Repo { unRepo :: Text } deriving (P.Eq, P.Show)

-- ** Rm
newtype Rm = Rm { unRm :: Bool } deriving (P.Eq, P.Show)

-- ** Rollback
newtype Rollback = Rollback { unRollback :: Text } deriving (P.Eq, P.Show)

-- ** RotateManagerToken
newtype RotateManagerToken = RotateManagerToken { unRotateManagerToken :: Bool } deriving (P.Eq, P.Show)

-- ** RotateManagerUnlockKey
newtype RotateManagerUnlockKey = RotateManagerUnlockKey { unRotateManagerUnlockKey :: Bool } deriving (P.Eq, P.Show)

-- ** RotateWorkerToken
newtype RotateWorkerToken = RotateWorkerToken { unRotateWorkerToken :: Bool } deriving (P.Eq, P.Show)

-- ** Scope
newtype Scope = Scope { unScope :: Text } deriving (P.Eq, P.Show)

-- ** Shmsize
newtype Shmsize = Shmsize { unShmsize :: Int } deriving (P.Eq, P.Show)

-- ** Signal
newtype Signal = Signal { unSignal :: Text } deriving (P.Eq, P.Show)

-- ** Since
newtype Since = Since { unSince :: Int } deriving (P.Eq, P.Show)

-- ** SinceText
newtype SinceText = SinceText { unSinceText :: Text } deriving (P.Eq, P.Show)

-- ** Size
newtype Size = Size { unSize :: Bool } deriving (P.Eq, P.Show)

-- ** Squash
newtype Squash = Squash { unSquash :: Bool } deriving (P.Eq, P.Show)

-- ** Status
newtype Status = Status { unStatus :: Bool } deriving (P.Eq, P.Show)

-- ** Stderr
newtype Stderr = Stderr { unStderr :: Bool } deriving (P.Eq, P.Show)

-- ** Stdin
newtype Stdin = Stdin { unStdin :: Bool } deriving (P.Eq, P.Show)

-- ** Stdout
newtype Stdout = Stdout { unStdout :: Bool } deriving (P.Eq, P.Show)

-- ** Stream
newtype Stream = Stream { unStream :: Bool } deriving (P.Eq, P.Show)

-- ** T
newtype T = T { unT :: Int } deriving (P.Eq, P.Show)

-- ** TText
newtype TText = TText { unTText :: Text } deriving (P.Eq, P.Show)

-- ** Tag
newtype Tag = Tag { unTag :: Text } deriving (P.Eq, P.Show)

-- ** Tail
newtype Tail = Tail { unTail :: Text } deriving (P.Eq, P.Show)

-- ** TarContext
newtype TarContext = TarContext { unTarContext :: FilePath } deriving (P.Eq, P.Show, A.ToJSON)

-- ** Target
newtype Target = Target { unTarget :: Text } deriving (P.Eq, P.Show)

-- ** Term
newtype Term = Term { unTerm :: Text } deriving (P.Eq, P.Show)

-- ** Timeout
newtype Timeout = Timeout { unTimeout :: Int } deriving (P.Eq, P.Show)

-- ** Timestamps
newtype Timestamps = Timestamps { unTimestamps :: Bool } deriving (P.Eq, P.Show)

-- ** Until
newtype Until = Until { unUntil :: Int } deriving (P.Eq, P.Show)

-- ** UntilText
newtype UntilText = UntilText { unUntilText :: Text } deriving (P.Eq, P.Show)

-- ** V
newtype V = V { unV :: Bool } deriving (P.Eq, P.Show)

-- ** Verbose
newtype Verbose = Verbose { unVerbose :: Bool } deriving (P.Eq, P.Show)

-- ** Version
newtype Version = Version { unVersion :: Integer } deriving (P.Eq, P.Show)

-- ** VersionInt
newtype VersionInt = VersionInt { unVersionInt :: Int } deriving (P.Eq, P.Show)

-- ** W
newtype W = W { unW :: Int } deriving (P.Eq, P.Show)

-- ** XRegistryAuth
newtype XRegistryAuth = XRegistryAuth { unXRegistryAuth :: Text } deriving (P.Eq, P.Show)

-- ** XRegistryConfig
newtype XRegistryConfig = XRegistryConfig { unXRegistryConfig :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** Address
-- | Address
-- Address represents an IPv4 or IPv6 IP address.
data Address = Address
  { addressAddr :: !(Maybe Text) -- ^ "Addr" - IP address.
  , addressPrefixLen :: !(Maybe Int) -- ^ "PrefixLen" - Mask length of the IP address.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Address
instance A.FromJSON Address where
  parseJSON = A.withObject "Address" $ \o ->
    Address
      <$> (o .:? "Addr")
      <*> (o .:? "PrefixLen")

-- | ToJSON Address
instance A.ToJSON Address where
  toJSON Address {..} =
   _omitNulls
      [ "Addr" .= addressAddr
      , "PrefixLen" .= addressPrefixLen
      ]


-- | Construct a value of type 'Address' (by applying it's required fields, if any)
mkAddress
  :: Address
mkAddress =
  Address
  { addressAddr = Nothing
  , addressPrefixLen = Nothing
  }

-- ** AuthConfig
-- | AuthConfig
data AuthConfig = AuthConfig
  { authConfigUsername :: !(Maybe Text) -- ^ "username"
  , authConfigPassword :: !(Maybe Text) -- ^ "password"
  , authConfigEmail :: !(Maybe Text) -- ^ "email"
  , authConfigServeraddress :: !(Maybe Text) -- ^ "serveraddress"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AuthConfig
instance A.FromJSON AuthConfig where
  parseJSON = A.withObject "AuthConfig" $ \o ->
    AuthConfig
      <$> (o .:? "username")
      <*> (o .:? "password")
      <*> (o .:? "email")
      <*> (o .:? "serveraddress")

-- | ToJSON AuthConfig
instance A.ToJSON AuthConfig where
  toJSON AuthConfig {..} =
   _omitNulls
      [ "username" .= authConfigUsername
      , "password" .= authConfigPassword
      , "email" .= authConfigEmail
      , "serveraddress" .= authConfigServeraddress
      ]


-- | Construct a value of type 'AuthConfig' (by applying it's required fields, if any)
mkAuthConfig
  :: AuthConfig
mkAuthConfig =
  AuthConfig
  { authConfigUsername = Nothing
  , authConfigPassword = Nothing
  , authConfigEmail = Nothing
  , authConfigServeraddress = Nothing
  }

-- ** BuildCache
-- | BuildCache
data BuildCache = BuildCache
  { buildCacheId :: !(Maybe Text) -- ^ "ID"
  , buildCacheParent :: !(Maybe Text) -- ^ "Parent"
  , buildCacheType :: !(Maybe Text) -- ^ "Type"
  , buildCacheDescription :: !(Maybe Text) -- ^ "Description"
  , buildCacheInUse :: !(Maybe Bool) -- ^ "InUse"
  , buildCacheShared :: !(Maybe Bool) -- ^ "Shared"
  , buildCacheSize :: !(Maybe Int) -- ^ "Size" - Amount of disk space used by the build cache (in bytes). 
  , buildCacheCreatedAt :: !(Maybe Text) -- ^ "CreatedAt" - Date and time at which the build cache was created in [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds. 
  , buildCacheLastUsedAt :: !(Maybe Text) -- ^ "LastUsedAt" - Date and time at which the build cache was last used in [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds. 
  , buildCacheUsageCount :: !(Maybe Int) -- ^ "UsageCount"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BuildCache
instance A.FromJSON BuildCache where
  parseJSON = A.withObject "BuildCache" $ \o ->
    BuildCache
      <$> (o .:? "ID")
      <*> (o .:? "Parent")
      <*> (o .:? "Type")
      <*> (o .:? "Description")
      <*> (o .:? "InUse")
      <*> (o .:? "Shared")
      <*> (o .:? "Size")
      <*> (o .:? "CreatedAt")
      <*> (o .:? "LastUsedAt")
      <*> (o .:? "UsageCount")

-- | ToJSON BuildCache
instance A.ToJSON BuildCache where
  toJSON BuildCache {..} =
   _omitNulls
      [ "ID" .= buildCacheId
      , "Parent" .= buildCacheParent
      , "Type" .= buildCacheType
      , "Description" .= buildCacheDescription
      , "InUse" .= buildCacheInUse
      , "Shared" .= buildCacheShared
      , "Size" .= buildCacheSize
      , "CreatedAt" .= buildCacheCreatedAt
      , "LastUsedAt" .= buildCacheLastUsedAt
      , "UsageCount" .= buildCacheUsageCount
      ]


-- | Construct a value of type 'BuildCache' (by applying it's required fields, if any)
mkBuildCache
  :: BuildCache
mkBuildCache =
  BuildCache
  { buildCacheId = Nothing
  , buildCacheParent = Nothing
  , buildCacheType = Nothing
  , buildCacheDescription = Nothing
  , buildCacheInUse = Nothing
  , buildCacheShared = Nothing
  , buildCacheSize = Nothing
  , buildCacheCreatedAt = Nothing
  , buildCacheLastUsedAt = Nothing
  , buildCacheUsageCount = Nothing
  }

-- ** BuildInfo
-- | BuildInfo
data BuildInfo = BuildInfo
  { buildInfoId :: !(Maybe Text) -- ^ "id"
  , buildInfoStream :: !(Maybe Text) -- ^ "stream"
  , buildInfoError :: !(Maybe Text) -- ^ "error"
  , buildInfoErrorDetail :: !(Maybe ErrorDetail) -- ^ "errorDetail"
  , buildInfoStatus :: !(Maybe Text) -- ^ "status"
  , buildInfoProgress :: !(Maybe Text) -- ^ "progress"
  , buildInfoProgressDetail :: !(Maybe ProgressDetail) -- ^ "progressDetail"
  , buildInfoAux :: !(Maybe ImageID) -- ^ "aux"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BuildInfo
instance A.FromJSON BuildInfo where
  parseJSON = A.withObject "BuildInfo" $ \o ->
    BuildInfo
      <$> (o .:? "id")
      <*> (o .:? "stream")
      <*> (o .:? "error")
      <*> (o .:? "errorDetail")
      <*> (o .:? "status")
      <*> (o .:? "progress")
      <*> (o .:? "progressDetail")
      <*> (o .:? "aux")

-- | ToJSON BuildInfo
instance A.ToJSON BuildInfo where
  toJSON BuildInfo {..} =
   _omitNulls
      [ "id" .= buildInfoId
      , "stream" .= buildInfoStream
      , "error" .= buildInfoError
      , "errorDetail" .= buildInfoErrorDetail
      , "status" .= buildInfoStatus
      , "progress" .= buildInfoProgress
      , "progressDetail" .= buildInfoProgressDetail
      , "aux" .= buildInfoAux
      ]


-- | Construct a value of type 'BuildInfo' (by applying it's required fields, if any)
mkBuildInfo
  :: BuildInfo
mkBuildInfo =
  BuildInfo
  { buildInfoId = Nothing
  , buildInfoStream = Nothing
  , buildInfoError = Nothing
  , buildInfoErrorDetail = Nothing
  , buildInfoStatus = Nothing
  , buildInfoProgress = Nothing
  , buildInfoProgressDetail = Nothing
  , buildInfoAux = Nothing
  }

-- ** BuildPruneResponse
-- | BuildPruneResponse
-- BuildPruneResponse
-- 
data BuildPruneResponse = BuildPruneResponse
  { buildPruneResponseCachesDeleted :: !(Maybe [Text]) -- ^ "CachesDeleted"
  , buildPruneResponseSpaceReclaimed :: !(Maybe Integer) -- ^ "SpaceReclaimed" - Disk space reclaimed in bytes
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BuildPruneResponse
instance A.FromJSON BuildPruneResponse where
  parseJSON = A.withObject "BuildPruneResponse" $ \o ->
    BuildPruneResponse
      <$> (o .:? "CachesDeleted")
      <*> (o .:? "SpaceReclaimed")

-- | ToJSON BuildPruneResponse
instance A.ToJSON BuildPruneResponse where
  toJSON BuildPruneResponse {..} =
   _omitNulls
      [ "CachesDeleted" .= buildPruneResponseCachesDeleted
      , "SpaceReclaimed" .= buildPruneResponseSpaceReclaimed
      ]


-- | Construct a value of type 'BuildPruneResponse' (by applying it's required fields, if any)
mkBuildPruneResponse
  :: BuildPruneResponse
mkBuildPruneResponse =
  BuildPruneResponse
  { buildPruneResponseCachesDeleted = Nothing
  , buildPruneResponseSpaceReclaimed = Nothing
  }

-- ** ClusterInfo
-- | ClusterInfo
-- ClusterInfo represents information about the swarm as is returned by the \"/info\" endpoint. Join-tokens are not included. 
data ClusterInfo = ClusterInfo
  { clusterInfoId :: !(Maybe Text) -- ^ "ID" - The ID of the swarm.
  , clusterInfoVersion :: !(Maybe ObjectVersion) -- ^ "Version"
  , clusterInfoCreatedAt :: !(Maybe Text) -- ^ "CreatedAt" - Date and time at which the swarm was initialised in [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds. 
  , clusterInfoUpdatedAt :: !(Maybe Text) -- ^ "UpdatedAt" - Date and time at which the swarm was last updated in [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds. 
  , clusterInfoSpec :: !(Maybe SwarmSpec) -- ^ "Spec"
  , clusterInfoTlsInfo :: !(Maybe TLSInfo) -- ^ "TLSInfo"
  , clusterInfoRootRotationInProgress :: !(Maybe Bool) -- ^ "RootRotationInProgress" - Whether there is currently a root CA rotation in progress for the swarm 
  , clusterInfoDataPathPort :: !(Maybe Int) -- ^ "DataPathPort" - DataPathPort specifies the data path port number for data traffic. Acceptable port range is 1024 to 49151. If no port is set or is set to 0, the default port (4789) is used. 
  , clusterInfoDefaultAddrPool :: !(Maybe [Text]) -- ^ "DefaultAddrPool" - Default Address Pool specifies default subnet pools for global scope networks. 
  , clusterInfoSubnetSize :: !(Maybe Int) -- ^ "SubnetSize" - SubnetSize specifies the subnet size of the networks created from the default subnet pool. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ClusterInfo
instance A.FromJSON ClusterInfo where
  parseJSON = A.withObject "ClusterInfo" $ \o ->
    ClusterInfo
      <$> (o .:? "ID")
      <*> (o .:? "Version")
      <*> (o .:? "CreatedAt")
      <*> (o .:? "UpdatedAt")
      <*> (o .:? "Spec")
      <*> (o .:? "TLSInfo")
      <*> (o .:? "RootRotationInProgress")
      <*> (o .:? "DataPathPort")
      <*> (o .:? "DefaultAddrPool")
      <*> (o .:? "SubnetSize")

-- | ToJSON ClusterInfo
instance A.ToJSON ClusterInfo where
  toJSON ClusterInfo {..} =
   _omitNulls
      [ "ID" .= clusterInfoId
      , "Version" .= clusterInfoVersion
      , "CreatedAt" .= clusterInfoCreatedAt
      , "UpdatedAt" .= clusterInfoUpdatedAt
      , "Spec" .= clusterInfoSpec
      , "TLSInfo" .= clusterInfoTlsInfo
      , "RootRotationInProgress" .= clusterInfoRootRotationInProgress
      , "DataPathPort" .= clusterInfoDataPathPort
      , "DefaultAddrPool" .= clusterInfoDefaultAddrPool
      , "SubnetSize" .= clusterInfoSubnetSize
      ]


-- | Construct a value of type 'ClusterInfo' (by applying it's required fields, if any)
mkClusterInfo
  :: ClusterInfo
mkClusterInfo =
  ClusterInfo
  { clusterInfoId = Nothing
  , clusterInfoVersion = Nothing
  , clusterInfoCreatedAt = Nothing
  , clusterInfoUpdatedAt = Nothing
  , clusterInfoSpec = Nothing
  , clusterInfoTlsInfo = Nothing
  , clusterInfoRootRotationInProgress = Nothing
  , clusterInfoDataPathPort = Nothing
  , clusterInfoDefaultAddrPool = Nothing
  , clusterInfoSubnetSize = Nothing
  }

-- ** Commit
-- | Commit
-- Commit holds the Git-commit (SHA1) that a binary was built from, as reported in the version-string of external tools, such as `containerd`, or `runC`. 
data Commit = Commit
  { commitId :: !(Maybe Text) -- ^ "ID" - Actual commit ID of external tool.
  , commitExpected :: !(Maybe Text) -- ^ "Expected" - Commit ID of external tool expected by dockerd as set at build time. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Commit
instance A.FromJSON Commit where
  parseJSON = A.withObject "Commit" $ \o ->
    Commit
      <$> (o .:? "ID")
      <*> (o .:? "Expected")

-- | ToJSON Commit
instance A.ToJSON Commit where
  toJSON Commit {..} =
   _omitNulls
      [ "ID" .= commitId
      , "Expected" .= commitExpected
      ]


-- | Construct a value of type 'Commit' (by applying it's required fields, if any)
mkCommit
  :: Commit
mkCommit =
  Commit
  { commitId = Nothing
  , commitExpected = Nothing
  }

-- ** Config
-- | Config
data Config = Config
  { configId :: !(Maybe Text) -- ^ "ID"
  , configVersion :: !(Maybe ObjectVersion) -- ^ "Version"
  , configCreatedAt :: !(Maybe Text) -- ^ "CreatedAt"
  , configUpdatedAt :: !(Maybe Text) -- ^ "UpdatedAt"
  , configSpec :: !(Maybe ConfigSpec) -- ^ "Spec"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Config
instance A.FromJSON Config where
  parseJSON = A.withObject "Config" $ \o ->
    Config
      <$> (o .:? "ID")
      <*> (o .:? "Version")
      <*> (o .:? "CreatedAt")
      <*> (o .:? "UpdatedAt")
      <*> (o .:? "Spec")

-- | ToJSON Config
instance A.ToJSON Config where
  toJSON Config {..} =
   _omitNulls
      [ "ID" .= configId
      , "Version" .= configVersion
      , "CreatedAt" .= configCreatedAt
      , "UpdatedAt" .= configUpdatedAt
      , "Spec" .= configSpec
      ]


-- | Construct a value of type 'Config' (by applying it's required fields, if any)
mkConfig
  :: Config
mkConfig =
  Config
  { configId = Nothing
  , configVersion = Nothing
  , configCreatedAt = Nothing
  , configUpdatedAt = Nothing
  , configSpec = Nothing
  }

-- ** ConfigSpec
-- | ConfigSpec
data ConfigSpec = ConfigSpec
  { configSpecName :: !(Maybe Text) -- ^ "Name" - User-defined name of the config.
  , configSpecLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , configSpecData :: !(Maybe Text) -- ^ "Data" - Base64-url-safe-encoded ([RFC 4648](https://tools.ietf.org/html/rfc4648#section-5)) config data. 
  , configSpecTemplating :: !(Maybe Driver) -- ^ "Templating"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ConfigSpec
instance A.FromJSON ConfigSpec where
  parseJSON = A.withObject "ConfigSpec" $ \o ->
    ConfigSpec
      <$> (o .:? "Name")
      <*> (o .:? "Labels")
      <*> (o .:? "Data")
      <*> (o .:? "Templating")

-- | ToJSON ConfigSpec
instance A.ToJSON ConfigSpec where
  toJSON ConfigSpec {..} =
   _omitNulls
      [ "Name" .= configSpecName
      , "Labels" .= configSpecLabels
      , "Data" .= configSpecData
      , "Templating" .= configSpecTemplating
      ]


-- | Construct a value of type 'ConfigSpec' (by applying it's required fields, if any)
mkConfigSpec
  :: ConfigSpec
mkConfigSpec =
  ConfigSpec
  { configSpecName = Nothing
  , configSpecLabels = Nothing
  , configSpecData = Nothing
  , configSpecTemplating = Nothing
  }

-- ** ContainerChangeResponseItem
-- | ContainerChangeResponseItem
-- ContainerChangeResponseItem
-- 
-- change item in response to ContainerChanges operation
data ContainerChangeResponseItem = ContainerChangeResponseItem
  { containerChangeResponseItemPath :: !(Text) -- ^ /Required/ "Path" - Path to file that has changed
  , containerChangeResponseItemKind :: !(Int) -- ^ /Required/ "Kind" - Kind of change
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerChangeResponseItem
instance A.FromJSON ContainerChangeResponseItem where
  parseJSON = A.withObject "ContainerChangeResponseItem" $ \o ->
    ContainerChangeResponseItem
      <$> (o .:  "Path")
      <*> (o .:  "Kind")

-- | ToJSON ContainerChangeResponseItem
instance A.ToJSON ContainerChangeResponseItem where
  toJSON ContainerChangeResponseItem {..} =
   _omitNulls
      [ "Path" .= containerChangeResponseItemPath
      , "Kind" .= containerChangeResponseItemKind
      ]


-- | Construct a value of type 'ContainerChangeResponseItem' (by applying it's required fields, if any)
mkContainerChangeResponseItem
  :: Text -- ^ 'containerChangeResponseItemPath': Path to file that has changed
  -> Int -- ^ 'containerChangeResponseItemKind': Kind of change
  -> ContainerChangeResponseItem
mkContainerChangeResponseItem containerChangeResponseItemPath containerChangeResponseItemKind =
  ContainerChangeResponseItem
  { containerChangeResponseItemPath
  , containerChangeResponseItemKind
  }

-- ** ContainerConfig
-- | ContainerConfig
-- Configuration for a container that is portable between hosts. 
data ContainerConfig = ContainerConfig
  { containerConfigHostname :: !(Maybe Text) -- ^ "Hostname" - The hostname to use for the container, as a valid RFC 1123 hostname. 
  , containerConfigDomainname :: !(Maybe Text) -- ^ "Domainname" - The domain name to use for the container. 
  , containerConfigUser :: !(Maybe Text) -- ^ "User" - The user that commands are run as inside the container.
  , containerConfigAttachStdin :: !(Maybe Bool) -- ^ "AttachStdin" - Whether to attach to &#x60;stdin&#x60;.
  , containerConfigAttachStdout :: !(Maybe Bool) -- ^ "AttachStdout" - Whether to attach to &#x60;stdout&#x60;.
  , containerConfigAttachStderr :: !(Maybe Bool) -- ^ "AttachStderr" - Whether to attach to &#x60;stderr&#x60;.
  , containerConfigExposedPorts :: !(Maybe (Map.Map String A.Value)) -- ^ "ExposedPorts" - An object mapping ports to an empty object in the form:  &#x60;{\&quot;&lt;port&gt;/&lt;tcp|udp|sctp&gt;\&quot;: {}}&#x60; 
  , containerConfigTty :: !(Maybe Bool) -- ^ "Tty" - Attach standard streams to a TTY, including &#x60;stdin&#x60; if it is not closed. 
  , containerConfigOpenStdin :: !(Maybe Bool) -- ^ "OpenStdin" - Open &#x60;stdin&#x60;
  , containerConfigStdinOnce :: !(Maybe Bool) -- ^ "StdinOnce" - Close &#x60;stdin&#x60; after one attached client disconnects
  , containerConfigEnv :: !(Maybe [Text]) -- ^ "Env" - A list of environment variables to set inside the container in the form &#x60;[\&quot;VAR&#x3D;value\&quot;, ...]&#x60;. A variable without &#x60;&#x3D;&#x60; is removed from the environment, rather than to have an empty value. 
  , containerConfigCmd :: !(Maybe [Text]) -- ^ "Cmd" - Command to run specified as a string or an array of strings. 
  , containerConfigHealthcheck :: !(Maybe HealthConfig) -- ^ "Healthcheck"
  , containerConfigArgsEscaped :: !(Maybe Bool) -- ^ "ArgsEscaped" - Command is already escaped (Windows only)
  , containerConfigImage :: !(Maybe Text) -- ^ "Image" - The name (or reference) of the image to use when creating the container, or which was used when the container was created. 
  , containerConfigVolumes :: !(Maybe (Map.Map String A.Value)) -- ^ "Volumes" - An object mapping mount point paths inside the container to empty objects. 
  , containerConfigWorkingDir :: !(Maybe Text) -- ^ "WorkingDir" - The working directory for commands to run in.
  , containerConfigEntrypoint :: !(Maybe [Text]) -- ^ "Entrypoint" - The entry point for the container as a string or an array of strings.  If the array consists of exactly one empty string (&#x60;[\&quot;\&quot;]&#x60;) then the entry point is reset to system default (i.e., the entry point used by docker when there is no &#x60;ENTRYPOINT&#x60; instruction in the &#x60;Dockerfile&#x60;). 
  , containerConfigNetworkDisabled :: !(Maybe Bool) -- ^ "NetworkDisabled" - Disable networking for the container.
  , containerConfigMacAddress :: !(Maybe Text) -- ^ "MacAddress" - MAC address of the container.
  , containerConfigOnBuild :: !(Maybe [Text]) -- ^ "OnBuild" - &#x60;ONBUILD&#x60; metadata that were defined in the image&#39;s &#x60;Dockerfile&#x60;. 
  , containerConfigLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , containerConfigStopSignal :: !(Maybe Text) -- ^ "StopSignal" - Signal to stop a container as a string or unsigned integer. 
  , containerConfigStopTimeout :: !(Maybe Int) -- ^ "StopTimeout" - Timeout to stop a container in seconds.
  , containerConfigShell :: !(Maybe [Text]) -- ^ "Shell" - Shell for when &#x60;RUN&#x60;, &#x60;CMD&#x60;, and &#x60;ENTRYPOINT&#x60; uses a shell. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerConfig
instance A.FromJSON ContainerConfig where
  parseJSON = A.withObject "ContainerConfig" $ \o ->
    ContainerConfig
      <$> (o .:? "Hostname")
      <*> (o .:? "Domainname")
      <*> (o .:? "User")
      <*> (o .:? "AttachStdin")
      <*> (o .:? "AttachStdout")
      <*> (o .:? "AttachStderr")
      <*> (o .:? "ExposedPorts")
      <*> (o .:? "Tty")
      <*> (o .:? "OpenStdin")
      <*> (o .:? "StdinOnce")
      <*> (o .:? "Env")
      <*> (o .:? "Cmd")
      <*> (o .:? "Healthcheck")
      <*> (o .:? "ArgsEscaped")
      <*> (o .:? "Image")
      <*> (o .:? "Volumes")
      <*> (o .:? "WorkingDir")
      <*> (o .:? "Entrypoint")
      <*> (o .:? "NetworkDisabled")
      <*> (o .:? "MacAddress")
      <*> (o .:? "OnBuild")
      <*> (o .:? "Labels")
      <*> (o .:? "StopSignal")
      <*> (o .:? "StopTimeout")
      <*> (o .:? "Shell")

-- | ToJSON ContainerConfig
instance A.ToJSON ContainerConfig where
  toJSON ContainerConfig {..} =
   _omitNulls
      [ "Hostname" .= containerConfigHostname
      , "Domainname" .= containerConfigDomainname
      , "User" .= containerConfigUser
      , "AttachStdin" .= containerConfigAttachStdin
      , "AttachStdout" .= containerConfigAttachStdout
      , "AttachStderr" .= containerConfigAttachStderr
      , "ExposedPorts" .= containerConfigExposedPorts
      , "Tty" .= containerConfigTty
      , "OpenStdin" .= containerConfigOpenStdin
      , "StdinOnce" .= containerConfigStdinOnce
      , "Env" .= containerConfigEnv
      , "Cmd" .= containerConfigCmd
      , "Healthcheck" .= containerConfigHealthcheck
      , "ArgsEscaped" .= containerConfigArgsEscaped
      , "Image" .= containerConfigImage
      , "Volumes" .= containerConfigVolumes
      , "WorkingDir" .= containerConfigWorkingDir
      , "Entrypoint" .= containerConfigEntrypoint
      , "NetworkDisabled" .= containerConfigNetworkDisabled
      , "MacAddress" .= containerConfigMacAddress
      , "OnBuild" .= containerConfigOnBuild
      , "Labels" .= containerConfigLabels
      , "StopSignal" .= containerConfigStopSignal
      , "StopTimeout" .= containerConfigStopTimeout
      , "Shell" .= containerConfigShell
      ]


-- | Construct a value of type 'ContainerConfig' (by applying it's required fields, if any)
mkContainerConfig
  :: ContainerConfig
mkContainerConfig =
  ContainerConfig
  { containerConfigHostname = Nothing
  , containerConfigDomainname = Nothing
  , containerConfigUser = Nothing
  , containerConfigAttachStdin = Nothing
  , containerConfigAttachStdout = Nothing
  , containerConfigAttachStderr = Nothing
  , containerConfigExposedPorts = Nothing
  , containerConfigTty = Nothing
  , containerConfigOpenStdin = Nothing
  , containerConfigStdinOnce = Nothing
  , containerConfigEnv = Nothing
  , containerConfigCmd = Nothing
  , containerConfigHealthcheck = Nothing
  , containerConfigArgsEscaped = Nothing
  , containerConfigImage = Nothing
  , containerConfigVolumes = Nothing
  , containerConfigWorkingDir = Nothing
  , containerConfigEntrypoint = Nothing
  , containerConfigNetworkDisabled = Nothing
  , containerConfigMacAddress = Nothing
  , containerConfigOnBuild = Nothing
  , containerConfigLabels = Nothing
  , containerConfigStopSignal = Nothing
  , containerConfigStopTimeout = Nothing
  , containerConfigShell = Nothing
  }

-- ** ContainerCreateResponse
-- | ContainerCreateResponse
-- ContainerCreateResponse
-- 
-- OK response to ContainerCreate operation
data ContainerCreateResponse = ContainerCreateResponse
  { containerCreateResponseId :: !(Text) -- ^ /Required/ "Id" - The ID of the created container
  , containerCreateResponseWarnings :: !([Text]) -- ^ /Required/ "Warnings" - Warnings encountered when creating the container
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerCreateResponse
instance A.FromJSON ContainerCreateResponse where
  parseJSON = A.withObject "ContainerCreateResponse" $ \o ->
    ContainerCreateResponse
      <$> (o .:  "Id")
      <*> (o .:  "Warnings")

-- | ToJSON ContainerCreateResponse
instance A.ToJSON ContainerCreateResponse where
  toJSON ContainerCreateResponse {..} =
   _omitNulls
      [ "Id" .= containerCreateResponseId
      , "Warnings" .= containerCreateResponseWarnings
      ]


-- | Construct a value of type 'ContainerCreateResponse' (by applying it's required fields, if any)
mkContainerCreateResponse
  :: Text -- ^ 'containerCreateResponseId': The ID of the created container
  -> [Text] -- ^ 'containerCreateResponseWarnings': Warnings encountered when creating the container
  -> ContainerCreateResponse
mkContainerCreateResponse containerCreateResponseId containerCreateResponseWarnings =
  ContainerCreateResponse
  { containerCreateResponseId
  , containerCreateResponseWarnings
  }

-- ** ContainerInspectResponse
-- | ContainerInspectResponse
-- ContainerInspectResponse
-- 
data ContainerInspectResponse = ContainerInspectResponse
  { containerInspectResponseId :: !(Maybe Text) -- ^ "Id" - The ID of the container
  , containerInspectResponseCreated :: !(Maybe Text) -- ^ "Created" - The time the container was created
  , containerInspectResponsePath :: !(Maybe Text) -- ^ "Path" - The path to the command being run
  , containerInspectResponseArgs :: !(Maybe [Text]) -- ^ "Args" - The arguments to the command being run
  , containerInspectResponseState :: !(Maybe ContainerState) -- ^ "State"
  , containerInspectResponseImage :: !(Maybe Text) -- ^ "Image" - The container&#39;s image ID
  , containerInspectResponseResolvConfPath :: !(Maybe Text) -- ^ "ResolvConfPath"
  , containerInspectResponseHostnamePath :: !(Maybe Text) -- ^ "HostnamePath"
  , containerInspectResponseHostsPath :: !(Maybe Text) -- ^ "HostsPath"
  , containerInspectResponseLogPath :: !(Maybe Text) -- ^ "LogPath"
  , containerInspectResponseName :: !(Maybe Text) -- ^ "Name"
  , containerInspectResponseRestartCount :: !(Maybe Int) -- ^ "RestartCount"
  , containerInspectResponseDriver :: !(Maybe Text) -- ^ "Driver"
  , containerInspectResponsePlatform :: !(Maybe Text) -- ^ "Platform"
  , containerInspectResponseMountLabel :: !(Maybe Text) -- ^ "MountLabel"
  , containerInspectResponseProcessLabel :: !(Maybe Text) -- ^ "ProcessLabel"
  , containerInspectResponseAppArmorProfile :: !(Maybe Text) -- ^ "AppArmorProfile"
  , containerInspectResponseExecIds :: !(Maybe [Text]) -- ^ "ExecIDs" - IDs of exec instances that are running in the container.
  , containerInspectResponseHostConfig :: !(Maybe HostConfig) -- ^ "HostConfig"
  , containerInspectResponseGraphDriver :: !(Maybe GraphDriverData) -- ^ "GraphDriver"
  , containerInspectResponseSizeRw :: !(Maybe Integer) -- ^ "SizeRw" - The size of files that have been created or changed by this container. 
  , containerInspectResponseSizeRootFs :: !(Maybe Integer) -- ^ "SizeRootFs" - The total size of all the files in this container.
  , containerInspectResponseMounts :: !(Maybe [MountPoint]) -- ^ "Mounts"
  , containerInspectResponseConfig :: !(Maybe ContainerConfig) -- ^ "Config"
  , containerInspectResponseNetworkSettings :: !(Maybe NetworkSettings) -- ^ "NetworkSettings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerInspectResponse
instance A.FromJSON ContainerInspectResponse where
  parseJSON = A.withObject "ContainerInspectResponse" $ \o ->
    ContainerInspectResponse
      <$> (o .:? "Id")
      <*> (o .:? "Created")
      <*> (o .:? "Path")
      <*> (o .:? "Args")
      <*> (o .:? "State")
      <*> (o .:? "Image")
      <*> (o .:? "ResolvConfPath")
      <*> (o .:? "HostnamePath")
      <*> (o .:? "HostsPath")
      <*> (o .:? "LogPath")
      <*> (o .:? "Name")
      <*> (o .:? "RestartCount")
      <*> (o .:? "Driver")
      <*> (o .:? "Platform")
      <*> (o .:? "MountLabel")
      <*> (o .:? "ProcessLabel")
      <*> (o .:? "AppArmorProfile")
      <*> (o .:? "ExecIDs")
      <*> (o .:? "HostConfig")
      <*> (o .:? "GraphDriver")
      <*> (o .:? "SizeRw")
      <*> (o .:? "SizeRootFs")
      <*> (o .:? "Mounts")
      <*> (o .:? "Config")
      <*> (o .:? "NetworkSettings")

-- | ToJSON ContainerInspectResponse
instance A.ToJSON ContainerInspectResponse where
  toJSON ContainerInspectResponse {..} =
   _omitNulls
      [ "Id" .= containerInspectResponseId
      , "Created" .= containerInspectResponseCreated
      , "Path" .= containerInspectResponsePath
      , "Args" .= containerInspectResponseArgs
      , "State" .= containerInspectResponseState
      , "Image" .= containerInspectResponseImage
      , "ResolvConfPath" .= containerInspectResponseResolvConfPath
      , "HostnamePath" .= containerInspectResponseHostnamePath
      , "HostsPath" .= containerInspectResponseHostsPath
      , "LogPath" .= containerInspectResponseLogPath
      , "Name" .= containerInspectResponseName
      , "RestartCount" .= containerInspectResponseRestartCount
      , "Driver" .= containerInspectResponseDriver
      , "Platform" .= containerInspectResponsePlatform
      , "MountLabel" .= containerInspectResponseMountLabel
      , "ProcessLabel" .= containerInspectResponseProcessLabel
      , "AppArmorProfile" .= containerInspectResponseAppArmorProfile
      , "ExecIDs" .= containerInspectResponseExecIds
      , "HostConfig" .= containerInspectResponseHostConfig
      , "GraphDriver" .= containerInspectResponseGraphDriver
      , "SizeRw" .= containerInspectResponseSizeRw
      , "SizeRootFs" .= containerInspectResponseSizeRootFs
      , "Mounts" .= containerInspectResponseMounts
      , "Config" .= containerInspectResponseConfig
      , "NetworkSettings" .= containerInspectResponseNetworkSettings
      ]


-- | Construct a value of type 'ContainerInspectResponse' (by applying it's required fields, if any)
mkContainerInspectResponse
  :: ContainerInspectResponse
mkContainerInspectResponse =
  ContainerInspectResponse
  { containerInspectResponseId = Nothing
  , containerInspectResponseCreated = Nothing
  , containerInspectResponsePath = Nothing
  , containerInspectResponseArgs = Nothing
  , containerInspectResponseState = Nothing
  , containerInspectResponseImage = Nothing
  , containerInspectResponseResolvConfPath = Nothing
  , containerInspectResponseHostnamePath = Nothing
  , containerInspectResponseHostsPath = Nothing
  , containerInspectResponseLogPath = Nothing
  , containerInspectResponseName = Nothing
  , containerInspectResponseRestartCount = Nothing
  , containerInspectResponseDriver = Nothing
  , containerInspectResponsePlatform = Nothing
  , containerInspectResponseMountLabel = Nothing
  , containerInspectResponseProcessLabel = Nothing
  , containerInspectResponseAppArmorProfile = Nothing
  , containerInspectResponseExecIds = Nothing
  , containerInspectResponseHostConfig = Nothing
  , containerInspectResponseGraphDriver = Nothing
  , containerInspectResponseSizeRw = Nothing
  , containerInspectResponseSizeRootFs = Nothing
  , containerInspectResponseMounts = Nothing
  , containerInspectResponseConfig = Nothing
  , containerInspectResponseNetworkSettings = Nothing
  }

-- ** ContainerPruneResponse
-- | ContainerPruneResponse
-- ContainerPruneResponse
-- 
data ContainerPruneResponse = ContainerPruneResponse
  { containerPruneResponseContainersDeleted :: !(Maybe [Text]) -- ^ "ContainersDeleted" - Container IDs that were deleted
  , containerPruneResponseSpaceReclaimed :: !(Maybe Integer) -- ^ "SpaceReclaimed" - Disk space reclaimed in bytes
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerPruneResponse
instance A.FromJSON ContainerPruneResponse where
  parseJSON = A.withObject "ContainerPruneResponse" $ \o ->
    ContainerPruneResponse
      <$> (o .:? "ContainersDeleted")
      <*> (o .:? "SpaceReclaimed")

-- | ToJSON ContainerPruneResponse
instance A.ToJSON ContainerPruneResponse where
  toJSON ContainerPruneResponse {..} =
   _omitNulls
      [ "ContainersDeleted" .= containerPruneResponseContainersDeleted
      , "SpaceReclaimed" .= containerPruneResponseSpaceReclaimed
      ]


-- | Construct a value of type 'ContainerPruneResponse' (by applying it's required fields, if any)
mkContainerPruneResponse
  :: ContainerPruneResponse
mkContainerPruneResponse =
  ContainerPruneResponse
  { containerPruneResponseContainersDeleted = Nothing
  , containerPruneResponseSpaceReclaimed = Nothing
  }

-- ** ContainerState
-- | ContainerState
-- ContainerState stores container's running state. It's part of ContainerJSONBase and will be returned by the \"inspect\" command. 
data ContainerState = ContainerState
  { containerStateStatus :: !(Maybe E'Status2) -- ^ "Status" - String representation of the container state. Can be one of \&quot;created\&quot;, \&quot;running\&quot;, \&quot;paused\&quot;, \&quot;restarting\&quot;, \&quot;removing\&quot;, \&quot;exited\&quot;, or \&quot;dead\&quot;. 
  , containerStateRunning :: !(Maybe Bool) -- ^ "Running" - Whether this container is running.  Note that a running container can be _paused_. The &#x60;Running&#x60; and &#x60;Paused&#x60; booleans are not mutually exclusive:  When pausing a container (on Linux), the freezer cgroup is used to suspend all processes in the container. Freezing the process requires the process to be running. As a result, paused containers are both &#x60;Running&#x60; _and_ &#x60;Paused&#x60;.  Use the &#x60;Status&#x60; field instead to determine if a container&#39;s state is \&quot;running\&quot;. 
  , containerStatePaused :: !(Maybe Bool) -- ^ "Paused" - Whether this container is paused.
  , containerStateRestarting :: !(Maybe Bool) -- ^ "Restarting" - Whether this container is restarting.
  , containerStateOomKilled :: !(Maybe Bool) -- ^ "OOMKilled" - Whether this container has been killed because it ran out of memory. 
  , containerStateDead :: !(Maybe Bool) -- ^ "Dead"
  , containerStatePid :: !(Maybe Int) -- ^ "Pid" - The process ID of this container
  , containerStateExitCode :: !(Maybe Int) -- ^ "ExitCode" - The last exit code of this container
  , containerStateError :: !(Maybe Text) -- ^ "Error"
  , containerStateStartedAt :: !(Maybe Text) -- ^ "StartedAt" - The time when this container was last started.
  , containerStateFinishedAt :: !(Maybe Text) -- ^ "FinishedAt" - The time when this container last exited.
  , containerStateHealth :: !(Maybe Health) -- ^ "Health"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerState
instance A.FromJSON ContainerState where
  parseJSON = A.withObject "ContainerState" $ \o ->
    ContainerState
      <$> (o .:? "Status")
      <*> (o .:? "Running")
      <*> (o .:? "Paused")
      <*> (o .:? "Restarting")
      <*> (o .:? "OOMKilled")
      <*> (o .:? "Dead")
      <*> (o .:? "Pid")
      <*> (o .:? "ExitCode")
      <*> (o .:? "Error")
      <*> (o .:? "StartedAt")
      <*> (o .:? "FinishedAt")
      <*> (o .:? "Health")

-- | ToJSON ContainerState
instance A.ToJSON ContainerState where
  toJSON ContainerState {..} =
   _omitNulls
      [ "Status" .= containerStateStatus
      , "Running" .= containerStateRunning
      , "Paused" .= containerStatePaused
      , "Restarting" .= containerStateRestarting
      , "OOMKilled" .= containerStateOomKilled
      , "Dead" .= containerStateDead
      , "Pid" .= containerStatePid
      , "ExitCode" .= containerStateExitCode
      , "Error" .= containerStateError
      , "StartedAt" .= containerStateStartedAt
      , "FinishedAt" .= containerStateFinishedAt
      , "Health" .= containerStateHealth
      ]


-- | Construct a value of type 'ContainerState' (by applying it's required fields, if any)
mkContainerState
  :: ContainerState
mkContainerState =
  ContainerState
  { containerStateStatus = Nothing
  , containerStateRunning = Nothing
  , containerStatePaused = Nothing
  , containerStateRestarting = Nothing
  , containerStateOomKilled = Nothing
  , containerStateDead = Nothing
  , containerStatePid = Nothing
  , containerStateExitCode = Nothing
  , containerStateError = Nothing
  , containerStateStartedAt = Nothing
  , containerStateFinishedAt = Nothing
  , containerStateHealth = Nothing
  }

-- ** ContainerSummary
-- | ContainerSummary
data ContainerSummary = ContainerSummary
  { containerSummaryId :: !(Maybe Text) -- ^ "Id" - The ID of this container
  , containerSummaryNames :: !(Maybe [Text]) -- ^ "Names" - The names that this container has been given
  , containerSummaryImage :: !(Maybe Text) -- ^ "Image" - The name of the image used when creating this container
  , containerSummaryImageId :: !(Maybe Text) -- ^ "ImageID" - The ID of the image that this container was created from
  , containerSummaryCommand :: !(Maybe Text) -- ^ "Command" - Command to run when starting the container
  , containerSummaryCreated :: !(Maybe Integer) -- ^ "Created" - When the container was created
  , containerSummaryPorts :: !(Maybe [Port]) -- ^ "Ports" - The ports exposed by this container
  , containerSummarySizeRw :: !(Maybe Integer) -- ^ "SizeRw" - The size of files that have been created or changed by this container
  , containerSummarySizeRootFs :: !(Maybe Integer) -- ^ "SizeRootFs" - The total size of all the files in this container
  , containerSummaryLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , containerSummaryState :: !(Maybe Text) -- ^ "State" - The state of this container (e.g. &#x60;Exited&#x60;)
  , containerSummaryStatus :: !(Maybe Text) -- ^ "Status" - Additional human-readable status of this container (e.g. &#x60;Exit 0&#x60;)
  , containerSummaryHostConfig :: !(Maybe ContainerSummaryHostConfig) -- ^ "HostConfig"
  , containerSummaryNetworkSettings :: !(Maybe ContainerSummaryNetworkSettings) -- ^ "NetworkSettings"
  , containerSummaryMounts :: !(Maybe [MountPoint]) -- ^ "Mounts"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerSummary
instance A.FromJSON ContainerSummary where
  parseJSON = A.withObject "ContainerSummary" $ \o ->
    ContainerSummary
      <$> (o .:? "Id")
      <*> (o .:? "Names")
      <*> (o .:? "Image")
      <*> (o .:? "ImageID")
      <*> (o .:? "Command")
      <*> (o .:? "Created")
      <*> (o .:? "Ports")
      <*> (o .:? "SizeRw")
      <*> (o .:? "SizeRootFs")
      <*> (o .:? "Labels")
      <*> (o .:? "State")
      <*> (o .:? "Status")
      <*> (o .:? "HostConfig")
      <*> (o .:? "NetworkSettings")
      <*> (o .:? "Mounts")

-- | ToJSON ContainerSummary
instance A.ToJSON ContainerSummary where
  toJSON ContainerSummary {..} =
   _omitNulls
      [ "Id" .= containerSummaryId
      , "Names" .= containerSummaryNames
      , "Image" .= containerSummaryImage
      , "ImageID" .= containerSummaryImageId
      , "Command" .= containerSummaryCommand
      , "Created" .= containerSummaryCreated
      , "Ports" .= containerSummaryPorts
      , "SizeRw" .= containerSummarySizeRw
      , "SizeRootFs" .= containerSummarySizeRootFs
      , "Labels" .= containerSummaryLabels
      , "State" .= containerSummaryState
      , "Status" .= containerSummaryStatus
      , "HostConfig" .= containerSummaryHostConfig
      , "NetworkSettings" .= containerSummaryNetworkSettings
      , "Mounts" .= containerSummaryMounts
      ]


-- | Construct a value of type 'ContainerSummary' (by applying it's required fields, if any)
mkContainerSummary
  :: ContainerSummary
mkContainerSummary =
  ContainerSummary
  { containerSummaryId = Nothing
  , containerSummaryNames = Nothing
  , containerSummaryImage = Nothing
  , containerSummaryImageId = Nothing
  , containerSummaryCommand = Nothing
  , containerSummaryCreated = Nothing
  , containerSummaryPorts = Nothing
  , containerSummarySizeRw = Nothing
  , containerSummarySizeRootFs = Nothing
  , containerSummaryLabels = Nothing
  , containerSummaryState = Nothing
  , containerSummaryStatus = Nothing
  , containerSummaryHostConfig = Nothing
  , containerSummaryNetworkSettings = Nothing
  , containerSummaryMounts = Nothing
  }

-- ** ContainerSummaryHostConfig
-- | ContainerSummaryHostConfig
data ContainerSummaryHostConfig = ContainerSummaryHostConfig
  { containerSummaryHostConfigNetworkMode :: !(Maybe Text) -- ^ "NetworkMode"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerSummaryHostConfig
instance A.FromJSON ContainerSummaryHostConfig where
  parseJSON = A.withObject "ContainerSummaryHostConfig" $ \o ->
    ContainerSummaryHostConfig
      <$> (o .:? "NetworkMode")

-- | ToJSON ContainerSummaryHostConfig
instance A.ToJSON ContainerSummaryHostConfig where
  toJSON ContainerSummaryHostConfig {..} =
   _omitNulls
      [ "NetworkMode" .= containerSummaryHostConfigNetworkMode
      ]


-- | Construct a value of type 'ContainerSummaryHostConfig' (by applying it's required fields, if any)
mkContainerSummaryHostConfig
  :: ContainerSummaryHostConfig
mkContainerSummaryHostConfig =
  ContainerSummaryHostConfig
  { containerSummaryHostConfigNetworkMode = Nothing
  }

-- ** ContainerSummaryNetworkSettings
-- | ContainerSummaryNetworkSettings
-- A summary of the container's network settings
data ContainerSummaryNetworkSettings = ContainerSummaryNetworkSettings
  { containerSummaryNetworkSettingsNetworks :: !(Maybe (Map.Map String EndpointSettings)) -- ^ "Networks"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerSummaryNetworkSettings
instance A.FromJSON ContainerSummaryNetworkSettings where
  parseJSON = A.withObject "ContainerSummaryNetworkSettings" $ \o ->
    ContainerSummaryNetworkSettings
      <$> (o .:? "Networks")

-- | ToJSON ContainerSummaryNetworkSettings
instance A.ToJSON ContainerSummaryNetworkSettings where
  toJSON ContainerSummaryNetworkSettings {..} =
   _omitNulls
      [ "Networks" .= containerSummaryNetworkSettingsNetworks
      ]


-- | Construct a value of type 'ContainerSummaryNetworkSettings' (by applying it's required fields, if any)
mkContainerSummaryNetworkSettings
  :: ContainerSummaryNetworkSettings
mkContainerSummaryNetworkSettings =
  ContainerSummaryNetworkSettings
  { containerSummaryNetworkSettingsNetworks = Nothing
  }

-- ** ContainerTopResponse
-- | ContainerTopResponse
-- ContainerTopResponse
-- 
-- OK response to ContainerTop operation
data ContainerTopResponse = ContainerTopResponse
  { containerTopResponseTitles :: !(Maybe [Text]) -- ^ "Titles" - The ps column titles
  , containerTopResponseProcesses :: !(Maybe [[Text]]) -- ^ "Processes" - Each process running in the container, where each is process is an array of values corresponding to the titles. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerTopResponse
instance A.FromJSON ContainerTopResponse where
  parseJSON = A.withObject "ContainerTopResponse" $ \o ->
    ContainerTopResponse
      <$> (o .:? "Titles")
      <*> (o .:? "Processes")

-- | ToJSON ContainerTopResponse
instance A.ToJSON ContainerTopResponse where
  toJSON ContainerTopResponse {..} =
   _omitNulls
      [ "Titles" .= containerTopResponseTitles
      , "Processes" .= containerTopResponseProcesses
      ]


-- | Construct a value of type 'ContainerTopResponse' (by applying it's required fields, if any)
mkContainerTopResponse
  :: ContainerTopResponse
mkContainerTopResponse =
  ContainerTopResponse
  { containerTopResponseTitles = Nothing
  , containerTopResponseProcesses = Nothing
  }

-- ** ContainerUpdateResponse
-- | ContainerUpdateResponse
-- ContainerUpdateResponse
-- 
-- OK response to ContainerUpdate operation
data ContainerUpdateResponse = ContainerUpdateResponse
  { containerUpdateResponseWarnings :: !(Maybe [Text]) -- ^ "Warnings"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerUpdateResponse
instance A.FromJSON ContainerUpdateResponse where
  parseJSON = A.withObject "ContainerUpdateResponse" $ \o ->
    ContainerUpdateResponse
      <$> (o .:? "Warnings")

-- | ToJSON ContainerUpdateResponse
instance A.ToJSON ContainerUpdateResponse where
  toJSON ContainerUpdateResponse {..} =
   _omitNulls
      [ "Warnings" .= containerUpdateResponseWarnings
      ]


-- | Construct a value of type 'ContainerUpdateResponse' (by applying it's required fields, if any)
mkContainerUpdateResponse
  :: ContainerUpdateResponse
mkContainerUpdateResponse =
  ContainerUpdateResponse
  { containerUpdateResponseWarnings = Nothing
  }

-- ** ContainerWaitExitError
-- | ContainerWaitExitError
-- container waiting error, if any
data ContainerWaitExitError = ContainerWaitExitError
  { containerWaitExitErrorMessage :: !(Maybe Text) -- ^ "Message" - Details of an error
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerWaitExitError
instance A.FromJSON ContainerWaitExitError where
  parseJSON = A.withObject "ContainerWaitExitError" $ \o ->
    ContainerWaitExitError
      <$> (o .:? "Message")

-- | ToJSON ContainerWaitExitError
instance A.ToJSON ContainerWaitExitError where
  toJSON ContainerWaitExitError {..} =
   _omitNulls
      [ "Message" .= containerWaitExitErrorMessage
      ]


-- | Construct a value of type 'ContainerWaitExitError' (by applying it's required fields, if any)
mkContainerWaitExitError
  :: ContainerWaitExitError
mkContainerWaitExitError =
  ContainerWaitExitError
  { containerWaitExitErrorMessage = Nothing
  }

-- ** ContainerWaitResponse
-- | ContainerWaitResponse
-- ContainerWaitResponse
-- 
-- OK response to ContainerWait operation
data ContainerWaitResponse = ContainerWaitResponse
  { containerWaitResponseStatusCode :: !(Int) -- ^ /Required/ "StatusCode" - Exit code of the container
  , containerWaitResponseError :: !(ContainerWaitExitError) -- ^ /Required/ "Error"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ContainerWaitResponse
instance A.FromJSON ContainerWaitResponse where
  parseJSON = A.withObject "ContainerWaitResponse" $ \o ->
    ContainerWaitResponse
      <$> (o .:  "StatusCode")
      <*> (o .:  "Error")

-- | ToJSON ContainerWaitResponse
instance A.ToJSON ContainerWaitResponse where
  toJSON ContainerWaitResponse {..} =
   _omitNulls
      [ "StatusCode" .= containerWaitResponseStatusCode
      , "Error" .= containerWaitResponseError
      ]


-- | Construct a value of type 'ContainerWaitResponse' (by applying it's required fields, if any)
mkContainerWaitResponse
  :: Int -- ^ 'containerWaitResponseStatusCode': Exit code of the container
  -> ContainerWaitExitError -- ^ 'containerWaitResponseError' 
  -> ContainerWaitResponse
mkContainerWaitResponse containerWaitResponseStatusCode containerWaitResponseError =
  ContainerWaitResponse
  { containerWaitResponseStatusCode
  , containerWaitResponseError
  }

-- ** CreateImageInfo
-- | CreateImageInfo
data CreateImageInfo = CreateImageInfo
  { createImageInfoId :: !(Maybe Text) -- ^ "id"
  , createImageInfoError :: !(Maybe Text) -- ^ "error"
  , createImageInfoStatus :: !(Maybe Text) -- ^ "status"
  , createImageInfoProgress :: !(Maybe Text) -- ^ "progress"
  , createImageInfoProgressDetail :: !(Maybe ProgressDetail) -- ^ "progressDetail"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateImageInfo
instance A.FromJSON CreateImageInfo where
  parseJSON = A.withObject "CreateImageInfo" $ \o ->
    CreateImageInfo
      <$> (o .:? "id")
      <*> (o .:? "error")
      <*> (o .:? "status")
      <*> (o .:? "progress")
      <*> (o .:? "progressDetail")

-- | ToJSON CreateImageInfo
instance A.ToJSON CreateImageInfo where
  toJSON CreateImageInfo {..} =
   _omitNulls
      [ "id" .= createImageInfoId
      , "error" .= createImageInfoError
      , "status" .= createImageInfoStatus
      , "progress" .= createImageInfoProgress
      , "progressDetail" .= createImageInfoProgressDetail
      ]


-- | Construct a value of type 'CreateImageInfo' (by applying it's required fields, if any)
mkCreateImageInfo
  :: CreateImageInfo
mkCreateImageInfo =
  CreateImageInfo
  { createImageInfoId = Nothing
  , createImageInfoError = Nothing
  , createImageInfoStatus = Nothing
  , createImageInfoProgress = Nothing
  , createImageInfoProgressDetail = Nothing
  }

-- ** DeviceMapping
-- | DeviceMapping
-- A device mapping between the host and container
data DeviceMapping = DeviceMapping
  { deviceMappingPathOnHost :: !(Maybe Text) -- ^ "PathOnHost"
  , deviceMappingPathInContainer :: !(Maybe Text) -- ^ "PathInContainer"
  , deviceMappingCgroupPermissions :: !(Maybe Text) -- ^ "CgroupPermissions"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeviceMapping
instance A.FromJSON DeviceMapping where
  parseJSON = A.withObject "DeviceMapping" $ \o ->
    DeviceMapping
      <$> (o .:? "PathOnHost")
      <*> (o .:? "PathInContainer")
      <*> (o .:? "CgroupPermissions")

-- | ToJSON DeviceMapping
instance A.ToJSON DeviceMapping where
  toJSON DeviceMapping {..} =
   _omitNulls
      [ "PathOnHost" .= deviceMappingPathOnHost
      , "PathInContainer" .= deviceMappingPathInContainer
      , "CgroupPermissions" .= deviceMappingCgroupPermissions
      ]


-- | Construct a value of type 'DeviceMapping' (by applying it's required fields, if any)
mkDeviceMapping
  :: DeviceMapping
mkDeviceMapping =
  DeviceMapping
  { deviceMappingPathOnHost = Nothing
  , deviceMappingPathInContainer = Nothing
  , deviceMappingCgroupPermissions = Nothing
  }

-- ** DeviceRequest
-- | DeviceRequest
-- A request for devices to be sent to device drivers
data DeviceRequest = DeviceRequest
  { deviceRequestDriver :: !(Maybe Text) -- ^ "Driver"
  , deviceRequestCount :: !(Maybe Int) -- ^ "Count"
  , deviceRequestDeviceIds :: !(Maybe [Text]) -- ^ "DeviceIDs"
  , deviceRequestCapabilities :: !(Maybe [[Text]]) -- ^ "Capabilities" - A list of capabilities; an OR list of AND lists of capabilities. 
  , deviceRequestOptions :: !(Maybe (Map.Map String Text)) -- ^ "Options" - Driver-specific options, specified as a key/value pairs. These options are passed directly to the driver. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeviceRequest
instance A.FromJSON DeviceRequest where
  parseJSON = A.withObject "DeviceRequest" $ \o ->
    DeviceRequest
      <$> (o .:? "Driver")
      <*> (o .:? "Count")
      <*> (o .:? "DeviceIDs")
      <*> (o .:? "Capabilities")
      <*> (o .:? "Options")

-- | ToJSON DeviceRequest
instance A.ToJSON DeviceRequest where
  toJSON DeviceRequest {..} =
   _omitNulls
      [ "Driver" .= deviceRequestDriver
      , "Count" .= deviceRequestCount
      , "DeviceIDs" .= deviceRequestDeviceIds
      , "Capabilities" .= deviceRequestCapabilities
      , "Options" .= deviceRequestOptions
      ]


-- | Construct a value of type 'DeviceRequest' (by applying it's required fields, if any)
mkDeviceRequest
  :: DeviceRequest
mkDeviceRequest =
  DeviceRequest
  { deviceRequestDriver = Nothing
  , deviceRequestCount = Nothing
  , deviceRequestDeviceIds = Nothing
  , deviceRequestCapabilities = Nothing
  , deviceRequestOptions = Nothing
  }

-- ** DistributionInspect
-- | DistributionInspect
-- DistributionInspectResponse
-- 
-- Describes the result obtained from contacting the registry to retrieve image metadata. 
data DistributionInspect = DistributionInspect
  { distributionInspectDescriptor :: !(OCIDescriptor) -- ^ /Required/ "Descriptor"
  , distributionInspectPlatforms :: !([OCIPlatform]) -- ^ /Required/ "Platforms" - An array containing all platforms supported by the image. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DistributionInspect
instance A.FromJSON DistributionInspect where
  parseJSON = A.withObject "DistributionInspect" $ \o ->
    DistributionInspect
      <$> (o .:  "Descriptor")
      <*> (o .:  "Platforms")

-- | ToJSON DistributionInspect
instance A.ToJSON DistributionInspect where
  toJSON DistributionInspect {..} =
   _omitNulls
      [ "Descriptor" .= distributionInspectDescriptor
      , "Platforms" .= distributionInspectPlatforms
      ]


-- | Construct a value of type 'DistributionInspect' (by applying it's required fields, if any)
mkDistributionInspect
  :: OCIDescriptor -- ^ 'distributionInspectDescriptor' 
  -> [OCIPlatform] -- ^ 'distributionInspectPlatforms': An array containing all platforms supported by the image. 
  -> DistributionInspect
mkDistributionInspect distributionInspectDescriptor distributionInspectPlatforms =
  DistributionInspect
  { distributionInspectDescriptor
  , distributionInspectPlatforms
  }

-- ** Driver
-- | Driver
-- Driver represents a driver (network, logging, secrets).
data Driver = Driver
  { driverName :: !(Text) -- ^ /Required/ "Name" - Name of the driver.
  , driverOptions :: !(Maybe (Map.Map String Text)) -- ^ "Options" - Key/value map of driver-specific options.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Driver
instance A.FromJSON Driver where
  parseJSON = A.withObject "Driver" $ \o ->
    Driver
      <$> (o .:  "Name")
      <*> (o .:? "Options")

-- | ToJSON Driver
instance A.ToJSON Driver where
  toJSON Driver {..} =
   _omitNulls
      [ "Name" .= driverName
      , "Options" .= driverOptions
      ]


-- | Construct a value of type 'Driver' (by applying it's required fields, if any)
mkDriver
  :: Text -- ^ 'driverName': Name of the driver.
  -> Driver
mkDriver driverName =
  Driver
  { driverName
  , driverOptions = Nothing
  }

-- ** EndpointIPAMConfig
-- | EndpointIPAMConfig
-- EndpointIPAMConfig represents an endpoint's IPAM configuration. 
data EndpointIPAMConfig = EndpointIPAMConfig
  { endpointIPAMConfigIpv4Address :: !(Maybe Text) -- ^ "IPv4Address"
  , endpointIPAMConfigIpv6Address :: !(Maybe Text) -- ^ "IPv6Address"
  , endpointIPAMConfigLinkLocalIps :: !(Maybe [Text]) -- ^ "LinkLocalIPs"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EndpointIPAMConfig
instance A.FromJSON EndpointIPAMConfig where
  parseJSON = A.withObject "EndpointIPAMConfig" $ \o ->
    EndpointIPAMConfig
      <$> (o .:? "IPv4Address")
      <*> (o .:? "IPv6Address")
      <*> (o .:? "LinkLocalIPs")

-- | ToJSON EndpointIPAMConfig
instance A.ToJSON EndpointIPAMConfig where
  toJSON EndpointIPAMConfig {..} =
   _omitNulls
      [ "IPv4Address" .= endpointIPAMConfigIpv4Address
      , "IPv6Address" .= endpointIPAMConfigIpv6Address
      , "LinkLocalIPs" .= endpointIPAMConfigLinkLocalIps
      ]


-- | Construct a value of type 'EndpointIPAMConfig' (by applying it's required fields, if any)
mkEndpointIPAMConfig
  :: EndpointIPAMConfig
mkEndpointIPAMConfig =
  EndpointIPAMConfig
  { endpointIPAMConfigIpv4Address = Nothing
  , endpointIPAMConfigIpv6Address = Nothing
  , endpointIPAMConfigLinkLocalIps = Nothing
  }

-- ** EndpointPortConfig
-- | EndpointPortConfig
data EndpointPortConfig = EndpointPortConfig
  { endpointPortConfigName :: !(Maybe Text) -- ^ "Name"
  , endpointPortConfigProtocol :: !(Maybe E'Type) -- ^ "Protocol"
  , endpointPortConfigTargetPort :: !(Maybe Int) -- ^ "TargetPort" - The port inside the container.
  , endpointPortConfigPublishedPort :: !(Maybe Int) -- ^ "PublishedPort" - The port on the swarm hosts.
  , endpointPortConfigPublishMode :: !(Maybe E'PublishMode) -- ^ "PublishMode" - The mode in which port is published.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  - \&quot;ingress\&quot; makes the target port accessible on every node,   regardless of whether there is a task for the service running on   that node or not. - \&quot;host\&quot; bypasses the routing mesh and publish the port directly on   the swarm node where that service is running. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EndpointPortConfig
instance A.FromJSON EndpointPortConfig where
  parseJSON = A.withObject "EndpointPortConfig" $ \o ->
    EndpointPortConfig
      <$> (o .:? "Name")
      <*> (o .:? "Protocol")
      <*> (o .:? "TargetPort")
      <*> (o .:? "PublishedPort")
      <*> (o .:? "PublishMode")

-- | ToJSON EndpointPortConfig
instance A.ToJSON EndpointPortConfig where
  toJSON EndpointPortConfig {..} =
   _omitNulls
      [ "Name" .= endpointPortConfigName
      , "Protocol" .= endpointPortConfigProtocol
      , "TargetPort" .= endpointPortConfigTargetPort
      , "PublishedPort" .= endpointPortConfigPublishedPort
      , "PublishMode" .= endpointPortConfigPublishMode
      ]


-- | Construct a value of type 'EndpointPortConfig' (by applying it's required fields, if any)
mkEndpointPortConfig
  :: EndpointPortConfig
mkEndpointPortConfig =
  EndpointPortConfig
  { endpointPortConfigName = Nothing
  , endpointPortConfigProtocol = Nothing
  , endpointPortConfigTargetPort = Nothing
  , endpointPortConfigPublishedPort = Nothing
  , endpointPortConfigPublishMode = Nothing
  }

-- ** EndpointSettings
-- | EndpointSettings
-- Configuration for a network endpoint.
data EndpointSettings = EndpointSettings
  { endpointSettingsIpamConfig :: !(Maybe EndpointIPAMConfig) -- ^ "IPAMConfig"
  , endpointSettingsLinks :: !(Maybe [Text]) -- ^ "Links"
  , endpointSettingsAliases :: !(Maybe [Text]) -- ^ "Aliases"
  , endpointSettingsNetworkId :: !(Maybe Text) -- ^ "NetworkID" - Unique ID of the network. 
  , endpointSettingsEndpointId :: !(Maybe Text) -- ^ "EndpointID" - Unique ID for the service endpoint in a Sandbox. 
  , endpointSettingsGateway :: !(Maybe Text) -- ^ "Gateway" - Gateway address for this network. 
  , endpointSettingsIpAddress :: !(Maybe Text) -- ^ "IPAddress" - IPv4 address. 
  , endpointSettingsIpPrefixLen :: !(Maybe Int) -- ^ "IPPrefixLen" - Mask length of the IPv4 address. 
  , endpointSettingsIpv6Gateway :: !(Maybe Text) -- ^ "IPv6Gateway" - IPv6 gateway address. 
  , endpointSettingsGlobalIpv6Address :: !(Maybe Text) -- ^ "GlobalIPv6Address" - Global IPv6 address. 
  , endpointSettingsGlobalIpv6PrefixLen :: !(Maybe Integer) -- ^ "GlobalIPv6PrefixLen" - Mask length of the global IPv6 address. 
  , endpointSettingsMacAddress :: !(Maybe Text) -- ^ "MacAddress" - MAC address for the endpoint on this network. 
  , endpointSettingsDriverOpts :: !(Maybe (Map.Map String Text)) -- ^ "DriverOpts" - DriverOpts is a mapping of driver options and values. These options are passed directly to the driver and are driver specific. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EndpointSettings
instance A.FromJSON EndpointSettings where
  parseJSON = A.withObject "EndpointSettings" $ \o ->
    EndpointSettings
      <$> (o .:? "IPAMConfig")
      <*> (o .:? "Links")
      <*> (o .:? "Aliases")
      <*> (o .:? "NetworkID")
      <*> (o .:? "EndpointID")
      <*> (o .:? "Gateway")
      <*> (o .:? "IPAddress")
      <*> (o .:? "IPPrefixLen")
      <*> (o .:? "IPv6Gateway")
      <*> (o .:? "GlobalIPv6Address")
      <*> (o .:? "GlobalIPv6PrefixLen")
      <*> (o .:? "MacAddress")
      <*> (o .:? "DriverOpts")

-- | ToJSON EndpointSettings
instance A.ToJSON EndpointSettings where
  toJSON EndpointSettings {..} =
   _omitNulls
      [ "IPAMConfig" .= endpointSettingsIpamConfig
      , "Links" .= endpointSettingsLinks
      , "Aliases" .= endpointSettingsAliases
      , "NetworkID" .= endpointSettingsNetworkId
      , "EndpointID" .= endpointSettingsEndpointId
      , "Gateway" .= endpointSettingsGateway
      , "IPAddress" .= endpointSettingsIpAddress
      , "IPPrefixLen" .= endpointSettingsIpPrefixLen
      , "IPv6Gateway" .= endpointSettingsIpv6Gateway
      , "GlobalIPv6Address" .= endpointSettingsGlobalIpv6Address
      , "GlobalIPv6PrefixLen" .= endpointSettingsGlobalIpv6PrefixLen
      , "MacAddress" .= endpointSettingsMacAddress
      , "DriverOpts" .= endpointSettingsDriverOpts
      ]


-- | Construct a value of type 'EndpointSettings' (by applying it's required fields, if any)
mkEndpointSettings
  :: EndpointSettings
mkEndpointSettings =
  EndpointSettings
  { endpointSettingsIpamConfig = Nothing
  , endpointSettingsLinks = Nothing
  , endpointSettingsAliases = Nothing
  , endpointSettingsNetworkId = Nothing
  , endpointSettingsEndpointId = Nothing
  , endpointSettingsGateway = Nothing
  , endpointSettingsIpAddress = Nothing
  , endpointSettingsIpPrefixLen = Nothing
  , endpointSettingsIpv6Gateway = Nothing
  , endpointSettingsGlobalIpv6Address = Nothing
  , endpointSettingsGlobalIpv6PrefixLen = Nothing
  , endpointSettingsMacAddress = Nothing
  , endpointSettingsDriverOpts = Nothing
  }

-- ** EndpointSpec
-- | EndpointSpec
-- Properties that can be configured to access and load balance a service.
data EndpointSpec = EndpointSpec
  { endpointSpecMode :: !(Maybe E'Mode) -- ^ "Mode" - The mode of resolution to use for internal load balancing between tasks. 
  , endpointSpecPorts :: !(Maybe [EndpointPortConfig]) -- ^ "Ports" - List of exposed ports that this service is accessible on from the outside. Ports can only be provided if &#x60;vip&#x60; resolution mode is used. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EndpointSpec
instance A.FromJSON EndpointSpec where
  parseJSON = A.withObject "EndpointSpec" $ \o ->
    EndpointSpec
      <$> (o .:? "Mode")
      <*> (o .:? "Ports")

-- | ToJSON EndpointSpec
instance A.ToJSON EndpointSpec where
  toJSON EndpointSpec {..} =
   _omitNulls
      [ "Mode" .= endpointSpecMode
      , "Ports" .= endpointSpecPorts
      ]


-- | Construct a value of type 'EndpointSpec' (by applying it's required fields, if any)
mkEndpointSpec
  :: EndpointSpec
mkEndpointSpec =
  EndpointSpec
  { endpointSpecMode = Nothing
  , endpointSpecPorts = Nothing
  }

-- ** EngineDescription
-- | EngineDescription
-- EngineDescription provides information about an engine.
data EngineDescription = EngineDescription
  { engineDescriptionEngineVersion :: !(Maybe Text) -- ^ "EngineVersion"
  , engineDescriptionLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels"
  , engineDescriptionPlugins :: !(Maybe [EngineDescriptionPlugins]) -- ^ "Plugins"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EngineDescription
instance A.FromJSON EngineDescription where
  parseJSON = A.withObject "EngineDescription" $ \o ->
    EngineDescription
      <$> (o .:? "EngineVersion")
      <*> (o .:? "Labels")
      <*> (o .:? "Plugins")

-- | ToJSON EngineDescription
instance A.ToJSON EngineDescription where
  toJSON EngineDescription {..} =
   _omitNulls
      [ "EngineVersion" .= engineDescriptionEngineVersion
      , "Labels" .= engineDescriptionLabels
      , "Plugins" .= engineDescriptionPlugins
      ]


-- | Construct a value of type 'EngineDescription' (by applying it's required fields, if any)
mkEngineDescription
  :: EngineDescription
mkEngineDescription =
  EngineDescription
  { engineDescriptionEngineVersion = Nothing
  , engineDescriptionLabels = Nothing
  , engineDescriptionPlugins = Nothing
  }

-- ** EngineDescriptionPlugins
-- | EngineDescriptionPlugins
data EngineDescriptionPlugins = EngineDescriptionPlugins
  { engineDescriptionPluginsType :: !(Maybe Text) -- ^ "Type"
  , engineDescriptionPluginsName :: !(Maybe Text) -- ^ "Name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EngineDescriptionPlugins
instance A.FromJSON EngineDescriptionPlugins where
  parseJSON = A.withObject "EngineDescriptionPlugins" $ \o ->
    EngineDescriptionPlugins
      <$> (o .:? "Type")
      <*> (o .:? "Name")

-- | ToJSON EngineDescriptionPlugins
instance A.ToJSON EngineDescriptionPlugins where
  toJSON EngineDescriptionPlugins {..} =
   _omitNulls
      [ "Type" .= engineDescriptionPluginsType
      , "Name" .= engineDescriptionPluginsName
      ]


-- | Construct a value of type 'EngineDescriptionPlugins' (by applying it's required fields, if any)
mkEngineDescriptionPlugins
  :: EngineDescriptionPlugins
mkEngineDescriptionPlugins =
  EngineDescriptionPlugins
  { engineDescriptionPluginsType = Nothing
  , engineDescriptionPluginsName = Nothing
  }

-- ** ErrorDetail
-- | ErrorDetail
data ErrorDetail = ErrorDetail
  { errorDetailCode :: !(Maybe Int) -- ^ "code"
  , errorDetailMessage :: !(Maybe Text) -- ^ "message"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ErrorDetail
instance A.FromJSON ErrorDetail where
  parseJSON = A.withObject "ErrorDetail" $ \o ->
    ErrorDetail
      <$> (o .:? "code")
      <*> (o .:? "message")

-- | ToJSON ErrorDetail
instance A.ToJSON ErrorDetail where
  toJSON ErrorDetail {..} =
   _omitNulls
      [ "code" .= errorDetailCode
      , "message" .= errorDetailMessage
      ]


-- | Construct a value of type 'ErrorDetail' (by applying it's required fields, if any)
mkErrorDetail
  :: ErrorDetail
mkErrorDetail =
  ErrorDetail
  { errorDetailCode = Nothing
  , errorDetailMessage = Nothing
  }

-- ** ErrorResponse
-- | ErrorResponse
-- Represents an error.
data ErrorResponse = ErrorResponse
  { errorResponseMessage :: !(Text) -- ^ /Required/ "message" - The error message.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ErrorResponse
instance A.FromJSON ErrorResponse where
  parseJSON = A.withObject "ErrorResponse" $ \o ->
    ErrorResponse
      <$> (o .:  "message")

-- | ToJSON ErrorResponse
instance A.ToJSON ErrorResponse where
  toJSON ErrorResponse {..} =
   _omitNulls
      [ "message" .= errorResponseMessage
      ]


-- | Construct a value of type 'ErrorResponse' (by applying it's required fields, if any)
mkErrorResponse
  :: Text -- ^ 'errorResponseMessage': The error message.
  -> ErrorResponse
mkErrorResponse errorResponseMessage =
  ErrorResponse
  { errorResponseMessage
  }

-- ** EventActor
-- | EventActor
-- Actor describes something that generates events, like a container, network, or a volume. 
data EventActor = EventActor
  { eventActorId :: !(Maybe Text) -- ^ "ID" - The ID of the object emitting the event
  , eventActorAttributes :: !(Maybe (Map.Map String Text)) -- ^ "Attributes" - Various key/value attributes of the object, depending on its type. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EventActor
instance A.FromJSON EventActor where
  parseJSON = A.withObject "EventActor" $ \o ->
    EventActor
      <$> (o .:? "ID")
      <*> (o .:? "Attributes")

-- | ToJSON EventActor
instance A.ToJSON EventActor where
  toJSON EventActor {..} =
   _omitNulls
      [ "ID" .= eventActorId
      , "Attributes" .= eventActorAttributes
      ]


-- | Construct a value of type 'EventActor' (by applying it's required fields, if any)
mkEventActor
  :: EventActor
mkEventActor =
  EventActor
  { eventActorId = Nothing
  , eventActorAttributes = Nothing
  }

-- ** EventMessage
-- | EventMessage
-- SystemEventsResponse
-- 
-- EventMessage represents the information an event contains. 
data EventMessage = EventMessage
  { eventMessageType :: !(Maybe E'Type3) -- ^ "Type" - The type of object emitting the event
  , eventMessageAction :: !(Maybe Text) -- ^ "Action" - The type of event
  , eventMessageActor :: !(Maybe EventActor) -- ^ "Actor"
  , eventMessageScope :: !(Maybe E'Scope2) -- ^ "scope" - Scope of the event. Engine events are &#x60;local&#x60; scope. Cluster (Swarm) events are &#x60;swarm&#x60; scope. 
  , eventMessageTime :: !(Maybe Integer) -- ^ "time" - Timestamp of event
  , eventMessageTimeNano :: !(Maybe Integer) -- ^ "timeNano" - Timestamp of event, with nanosecond accuracy
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EventMessage
instance A.FromJSON EventMessage where
  parseJSON = A.withObject "EventMessage" $ \o ->
    EventMessage
      <$> (o .:? "Type")
      <*> (o .:? "Action")
      <*> (o .:? "Actor")
      <*> (o .:? "scope")
      <*> (o .:? "time")
      <*> (o .:? "timeNano")

-- | ToJSON EventMessage
instance A.ToJSON EventMessage where
  toJSON EventMessage {..} =
   _omitNulls
      [ "Type" .= eventMessageType
      , "Action" .= eventMessageAction
      , "Actor" .= eventMessageActor
      , "scope" .= eventMessageScope
      , "time" .= eventMessageTime
      , "timeNano" .= eventMessageTimeNano
      ]


-- | Construct a value of type 'EventMessage' (by applying it's required fields, if any)
mkEventMessage
  :: EventMessage
mkEventMessage =
  EventMessage
  { eventMessageType = Nothing
  , eventMessageAction = Nothing
  , eventMessageActor = Nothing
  , eventMessageScope = Nothing
  , eventMessageTime = Nothing
  , eventMessageTimeNano = Nothing
  }

-- ** ExecConfig
-- | ExecConfig
-- ExecConfig
-- 
data ExecConfig = ExecConfig
  { execConfigAttachStdin :: !(Maybe Bool) -- ^ "AttachStdin" - Attach to &#x60;stdin&#x60; of the exec command.
  , execConfigAttachStdout :: !(Maybe Bool) -- ^ "AttachStdout" - Attach to &#x60;stdout&#x60; of the exec command.
  , execConfigAttachStderr :: !(Maybe Bool) -- ^ "AttachStderr" - Attach to &#x60;stderr&#x60; of the exec command.
  , execConfigDetachKeys :: !(Maybe Text) -- ^ "DetachKeys" - Override the key sequence for detaching a container. Format is a single character &#x60;[a-Z]&#x60; or &#x60;ctrl-&lt;value&gt;&#x60; where &#x60;&lt;value&gt;&#x60; is one of: &#x60;a-z&#x60;, &#x60;@&#x60;, &#x60;^&#x60;, &#x60;[&#x60;, &#x60;,&#x60; or &#x60;_&#x60;. 
  , execConfigTty :: !(Maybe Bool) -- ^ "Tty" - Allocate a pseudo-TTY.
  , execConfigEnv :: !(Maybe [Text]) -- ^ "Env" - A list of environment variables in the form &#x60;[\&quot;VAR&#x3D;value\&quot;, ...]&#x60;. 
  , execConfigCmd :: !(Maybe [Text]) -- ^ "Cmd" - Command to run, as a string or array of strings.
  , execConfigPrivileged :: !(Maybe Bool) -- ^ "Privileged" - Runs the exec process with extended privileges.
  , execConfigUser :: !(Maybe Text) -- ^ "User" - The user, and optionally, group to run the exec process inside the container. Format is one of: &#x60;user&#x60;, &#x60;user:group&#x60;, &#x60;uid&#x60;, or &#x60;uid:gid&#x60;. 
  , execConfigWorkingDir :: !(Maybe Text) -- ^ "WorkingDir" - The working directory for the exec process inside the container. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExecConfig
instance A.FromJSON ExecConfig where
  parseJSON = A.withObject "ExecConfig" $ \o ->
    ExecConfig
      <$> (o .:? "AttachStdin")
      <*> (o .:? "AttachStdout")
      <*> (o .:? "AttachStderr")
      <*> (o .:? "DetachKeys")
      <*> (o .:? "Tty")
      <*> (o .:? "Env")
      <*> (o .:? "Cmd")
      <*> (o .:? "Privileged")
      <*> (o .:? "User")
      <*> (o .:? "WorkingDir")

-- | ToJSON ExecConfig
instance A.ToJSON ExecConfig where
  toJSON ExecConfig {..} =
   _omitNulls
      [ "AttachStdin" .= execConfigAttachStdin
      , "AttachStdout" .= execConfigAttachStdout
      , "AttachStderr" .= execConfigAttachStderr
      , "DetachKeys" .= execConfigDetachKeys
      , "Tty" .= execConfigTty
      , "Env" .= execConfigEnv
      , "Cmd" .= execConfigCmd
      , "Privileged" .= execConfigPrivileged
      , "User" .= execConfigUser
      , "WorkingDir" .= execConfigWorkingDir
      ]


-- | Construct a value of type 'ExecConfig' (by applying it's required fields, if any)
mkExecConfig
  :: ExecConfig
mkExecConfig =
  ExecConfig
  { execConfigAttachStdin = Nothing
  , execConfigAttachStdout = Nothing
  , execConfigAttachStderr = Nothing
  , execConfigDetachKeys = Nothing
  , execConfigTty = Nothing
  , execConfigEnv = Nothing
  , execConfigCmd = Nothing
  , execConfigPrivileged = Nothing
  , execConfigUser = Nothing
  , execConfigWorkingDir = Nothing
  }

-- ** ExecInspectResponse
-- | ExecInspectResponse
-- ExecInspectResponse
-- 
data ExecInspectResponse = ExecInspectResponse
  { execInspectResponseCanRemove :: !(Maybe Bool) -- ^ "CanRemove"
  , execInspectResponseDetachKeys :: !(Maybe Text) -- ^ "DetachKeys"
  , execInspectResponseId :: !(Maybe Text) -- ^ "ID"
  , execInspectResponseRunning :: !(Maybe Bool) -- ^ "Running"
  , execInspectResponseExitCode :: !(Maybe Int) -- ^ "ExitCode"
  , execInspectResponseProcessConfig :: !(Maybe ProcessConfig) -- ^ "ProcessConfig"
  , execInspectResponseOpenStdin :: !(Maybe Bool) -- ^ "OpenStdin"
  , execInspectResponseOpenStderr :: !(Maybe Bool) -- ^ "OpenStderr"
  , execInspectResponseOpenStdout :: !(Maybe Bool) -- ^ "OpenStdout"
  , execInspectResponseContainerId :: !(Maybe Text) -- ^ "ContainerID"
  , execInspectResponsePid :: !(Maybe Int) -- ^ "Pid" - The system process ID for the exec process.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExecInspectResponse
instance A.FromJSON ExecInspectResponse where
  parseJSON = A.withObject "ExecInspectResponse" $ \o ->
    ExecInspectResponse
      <$> (o .:? "CanRemove")
      <*> (o .:? "DetachKeys")
      <*> (o .:? "ID")
      <*> (o .:? "Running")
      <*> (o .:? "ExitCode")
      <*> (o .:? "ProcessConfig")
      <*> (o .:? "OpenStdin")
      <*> (o .:? "OpenStderr")
      <*> (o .:? "OpenStdout")
      <*> (o .:? "ContainerID")
      <*> (o .:? "Pid")

-- | ToJSON ExecInspectResponse
instance A.ToJSON ExecInspectResponse where
  toJSON ExecInspectResponse {..} =
   _omitNulls
      [ "CanRemove" .= execInspectResponseCanRemove
      , "DetachKeys" .= execInspectResponseDetachKeys
      , "ID" .= execInspectResponseId
      , "Running" .= execInspectResponseRunning
      , "ExitCode" .= execInspectResponseExitCode
      , "ProcessConfig" .= execInspectResponseProcessConfig
      , "OpenStdin" .= execInspectResponseOpenStdin
      , "OpenStderr" .= execInspectResponseOpenStderr
      , "OpenStdout" .= execInspectResponseOpenStdout
      , "ContainerID" .= execInspectResponseContainerId
      , "Pid" .= execInspectResponsePid
      ]


-- | Construct a value of type 'ExecInspectResponse' (by applying it's required fields, if any)
mkExecInspectResponse
  :: ExecInspectResponse
mkExecInspectResponse =
  ExecInspectResponse
  { execInspectResponseCanRemove = Nothing
  , execInspectResponseDetachKeys = Nothing
  , execInspectResponseId = Nothing
  , execInspectResponseRunning = Nothing
  , execInspectResponseExitCode = Nothing
  , execInspectResponseProcessConfig = Nothing
  , execInspectResponseOpenStdin = Nothing
  , execInspectResponseOpenStderr = Nothing
  , execInspectResponseOpenStdout = Nothing
  , execInspectResponseContainerId = Nothing
  , execInspectResponsePid = Nothing
  }

-- ** ExecStartConfig
-- | ExecStartConfig
-- ExecStartConfig
-- 
data ExecStartConfig = ExecStartConfig
  { execStartConfigDetach :: !(Maybe Bool) -- ^ "Detach" - Detach from the command.
  , execStartConfigTty :: !(Maybe Bool) -- ^ "Tty" - Allocate a pseudo-TTY.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExecStartConfig
instance A.FromJSON ExecStartConfig where
  parseJSON = A.withObject "ExecStartConfig" $ \o ->
    ExecStartConfig
      <$> (o .:? "Detach")
      <*> (o .:? "Tty")

-- | ToJSON ExecStartConfig
instance A.ToJSON ExecStartConfig where
  toJSON ExecStartConfig {..} =
   _omitNulls
      [ "Detach" .= execStartConfigDetach
      , "Tty" .= execStartConfigTty
      ]


-- | Construct a value of type 'ExecStartConfig' (by applying it's required fields, if any)
mkExecStartConfig
  :: ExecStartConfig
mkExecStartConfig =
  ExecStartConfig
  { execStartConfigDetach = Nothing
  , execStartConfigTty = Nothing
  }

-- ** GraphDriverData
-- | GraphDriverData
-- Information about the storage driver used to store the container's and image's filesystem. 
data GraphDriverData = GraphDriverData
  { graphDriverDataName :: !(Text) -- ^ /Required/ "Name" - Name of the storage driver.
  , graphDriverDataData :: !((Map.Map String Text)) -- ^ /Required/ "Data" - Low-level storage metadata, provided as key/value pairs.  This information is driver-specific, and depends on the storage-driver in use, and should be used for informational purposes only. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GraphDriverData
instance A.FromJSON GraphDriverData where
  parseJSON = A.withObject "GraphDriverData" $ \o ->
    GraphDriverData
      <$> (o .:  "Name")
      <*> (o .:  "Data")

-- | ToJSON GraphDriverData
instance A.ToJSON GraphDriverData where
  toJSON GraphDriverData {..} =
   _omitNulls
      [ "Name" .= graphDriverDataName
      , "Data" .= graphDriverDataData
      ]


-- | Construct a value of type 'GraphDriverData' (by applying it's required fields, if any)
mkGraphDriverData
  :: Text -- ^ 'graphDriverDataName': Name of the storage driver.
  -> (Map.Map String Text) -- ^ 'graphDriverDataData': Low-level storage metadata, provided as key/value pairs.  This information is driver-specific, and depends on the storage-driver in use, and should be used for informational purposes only. 
  -> GraphDriverData
mkGraphDriverData graphDriverDataName graphDriverDataData =
  GraphDriverData
  { graphDriverDataName
  , graphDriverDataData
  }

-- ** Health
-- | Health
-- Health stores information about the container's healthcheck results. 
data Health = Health
  { healthStatus :: !(Maybe E'Status) -- ^ "Status" - Status is one of &#x60;none&#x60;, &#x60;starting&#x60;, &#x60;healthy&#x60; or &#x60;unhealthy&#x60;  - \&quot;none\&quot;      Indicates there is no healthcheck - \&quot;starting\&quot;  Starting indicates that the container is not yet ready - \&quot;healthy\&quot;   Healthy indicates that the container is running correctly - \&quot;unhealthy\&quot; Unhealthy indicates that the container has a problem 
  , healthFailingStreak :: !(Maybe Int) -- ^ "FailingStreak" - FailingStreak is the number of consecutive failures
  , healthLog :: !(Maybe [HealthcheckResult]) -- ^ "Log" - Log contains the last few results (oldest first) 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Health
instance A.FromJSON Health where
  parseJSON = A.withObject "Health" $ \o ->
    Health
      <$> (o .:? "Status")
      <*> (o .:? "FailingStreak")
      <*> (o .:? "Log")

-- | ToJSON Health
instance A.ToJSON Health where
  toJSON Health {..} =
   _omitNulls
      [ "Status" .= healthStatus
      , "FailingStreak" .= healthFailingStreak
      , "Log" .= healthLog
      ]


-- | Construct a value of type 'Health' (by applying it's required fields, if any)
mkHealth
  :: Health
mkHealth =
  Health
  { healthStatus = Nothing
  , healthFailingStreak = Nothing
  , healthLog = Nothing
  }

-- ** HealthConfig
-- | HealthConfig
-- A test to perform to check that the container is healthy.
data HealthConfig = HealthConfig
  { healthConfigTest :: !(Maybe [Text]) -- ^ "Test" - The test to perform. Possible values are:  - &#x60;[]&#x60; inherit healthcheck from image or parent image - &#x60;[\&quot;NONE\&quot;]&#x60; disable healthcheck - &#x60;[\&quot;CMD\&quot;, args...]&#x60; exec arguments directly - &#x60;[\&quot;CMD-SHELL\&quot;, command]&#x60; run command with system&#39;s default shell 
  , healthConfigInterval :: !(Maybe Int) -- ^ "Interval" - The time to wait between checks in nanoseconds. It should be 0 or at least 1000000 (1 ms). 0 means inherit. 
  , healthConfigTimeout :: !(Maybe Int) -- ^ "Timeout" - The time to wait before considering the check to have hung. It should be 0 or at least 1000000 (1 ms). 0 means inherit. 
  , healthConfigRetries :: !(Maybe Int) -- ^ "Retries" - The number of consecutive failures needed to consider a container as unhealthy. 0 means inherit. 
  , healthConfigStartPeriod :: !(Maybe Int) -- ^ "StartPeriod" - Start period for the container to initialize before starting health-retries countdown in nanoseconds. It should be 0 or at least 1000000 (1 ms). 0 means inherit. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HealthConfig
instance A.FromJSON HealthConfig where
  parseJSON = A.withObject "HealthConfig" $ \o ->
    HealthConfig
      <$> (o .:? "Test")
      <*> (o .:? "Interval")
      <*> (o .:? "Timeout")
      <*> (o .:? "Retries")
      <*> (o .:? "StartPeriod")

-- | ToJSON HealthConfig
instance A.ToJSON HealthConfig where
  toJSON HealthConfig {..} =
   _omitNulls
      [ "Test" .= healthConfigTest
      , "Interval" .= healthConfigInterval
      , "Timeout" .= healthConfigTimeout
      , "Retries" .= healthConfigRetries
      , "StartPeriod" .= healthConfigStartPeriod
      ]


-- | Construct a value of type 'HealthConfig' (by applying it's required fields, if any)
mkHealthConfig
  :: HealthConfig
mkHealthConfig =
  HealthConfig
  { healthConfigTest = Nothing
  , healthConfigInterval = Nothing
  , healthConfigTimeout = Nothing
  , healthConfigRetries = Nothing
  , healthConfigStartPeriod = Nothing
  }

-- ** HealthcheckResult
-- | HealthcheckResult
-- HealthcheckResult stores information about a single run of a healthcheck probe 
data HealthcheckResult = HealthcheckResult
  { healthcheckResultStart :: !(Maybe DateTime) -- ^ "Start" - Date and time at which this check started in [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds. 
  , healthcheckResultEnd :: !(Maybe Text) -- ^ "End" - Date and time at which this check ended in [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds. 
  , healthcheckResultExitCode :: !(Maybe Int) -- ^ "ExitCode" - ExitCode meanings:  - &#x60;0&#x60; healthy - &#x60;1&#x60; unhealthy - &#x60;2&#x60; reserved (considered unhealthy) - other values: error running probe 
  , healthcheckResultOutput :: !(Maybe Text) -- ^ "Output" - Output from last check
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HealthcheckResult
instance A.FromJSON HealthcheckResult where
  parseJSON = A.withObject "HealthcheckResult" $ \o ->
    HealthcheckResult
      <$> (o .:? "Start")
      <*> (o .:? "End")
      <*> (o .:? "ExitCode")
      <*> (o .:? "Output")

-- | ToJSON HealthcheckResult
instance A.ToJSON HealthcheckResult where
  toJSON HealthcheckResult {..} =
   _omitNulls
      [ "Start" .= healthcheckResultStart
      , "End" .= healthcheckResultEnd
      , "ExitCode" .= healthcheckResultExitCode
      , "Output" .= healthcheckResultOutput
      ]


-- | Construct a value of type 'HealthcheckResult' (by applying it's required fields, if any)
mkHealthcheckResult
  :: HealthcheckResult
mkHealthcheckResult =
  HealthcheckResult
  { healthcheckResultStart = Nothing
  , healthcheckResultEnd = Nothing
  , healthcheckResultExitCode = Nothing
  , healthcheckResultOutput = Nothing
  }

-- ** HistoryResponseItem
-- | HistoryResponseItem
-- HistoryResponseItem
-- 
-- individual image layer information in response to ImageHistory operation
data HistoryResponseItem = HistoryResponseItem
  { historyResponseItemId :: !(Text) -- ^ /Required/ "Id"
  , historyResponseItemCreated :: !(Integer) -- ^ /Required/ "Created"
  , historyResponseItemCreatedBy :: !(Text) -- ^ /Required/ "CreatedBy"
  , historyResponseItemTags :: !([Text]) -- ^ /Required/ "Tags"
  , historyResponseItemSize :: !(Integer) -- ^ /Required/ "Size"
  , historyResponseItemComment :: !(Text) -- ^ /Required/ "Comment"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HistoryResponseItem
instance A.FromJSON HistoryResponseItem where
  parseJSON = A.withObject "HistoryResponseItem" $ \o ->
    HistoryResponseItem
      <$> (o .:  "Id")
      <*> (o .:  "Created")
      <*> (o .:  "CreatedBy")
      <*> (o .:  "Tags")
      <*> (o .:  "Size")
      <*> (o .:  "Comment")

-- | ToJSON HistoryResponseItem
instance A.ToJSON HistoryResponseItem where
  toJSON HistoryResponseItem {..} =
   _omitNulls
      [ "Id" .= historyResponseItemId
      , "Created" .= historyResponseItemCreated
      , "CreatedBy" .= historyResponseItemCreatedBy
      , "Tags" .= historyResponseItemTags
      , "Size" .= historyResponseItemSize
      , "Comment" .= historyResponseItemComment
      ]


-- | Construct a value of type 'HistoryResponseItem' (by applying it's required fields, if any)
mkHistoryResponseItem
  :: Text -- ^ 'historyResponseItemId' 
  -> Integer -- ^ 'historyResponseItemCreated' 
  -> Text -- ^ 'historyResponseItemCreatedBy' 
  -> [Text] -- ^ 'historyResponseItemTags' 
  -> Integer -- ^ 'historyResponseItemSize' 
  -> Text -- ^ 'historyResponseItemComment' 
  -> HistoryResponseItem
mkHistoryResponseItem historyResponseItemId historyResponseItemCreated historyResponseItemCreatedBy historyResponseItemTags historyResponseItemSize historyResponseItemComment =
  HistoryResponseItem
  { historyResponseItemId
  , historyResponseItemCreated
  , historyResponseItemCreatedBy
  , historyResponseItemTags
  , historyResponseItemSize
  , historyResponseItemComment
  }

-- ** HostConfig
-- | HostConfig
-- Container configuration that depends on the host we are running on
data HostConfig = HostConfig
  { hostConfigCpuShares :: !(Maybe Int) -- ^ "CpuShares" - An integer value representing this container&#39;s relative CPU weight versus other containers. 
  , hostConfigMemory :: !(Maybe Integer) -- ^ "Memory" - Memory limit in bytes.
  , hostConfigCgroupParent :: !(Maybe Text) -- ^ "CgroupParent" - Path to &#x60;cgroups&#x60; under which the container&#39;s &#x60;cgroup&#x60; is created. If the path is not absolute, the path is considered to be relative to the &#x60;cgroups&#x60; path of the init process. Cgroups are created if they do not already exist. 
  , hostConfigBlkioWeight :: !(Maybe Int) -- ^ "BlkioWeight" - Block IO weight (relative weight).
  , hostConfigBlkioWeightDevice :: !(Maybe [ResourcesBlkioWeightDevice]) -- ^ "BlkioWeightDevice" - Block IO weight (relative device weight) in the form:  &#x60;&#x60;&#x60; [{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Weight\&quot;: weight}] &#x60;&#x60;&#x60; 
  , hostConfigBlkioDeviceReadBps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceReadBps" - Limit read rate (bytes per second) from a device, in the form:  &#x60;&#x60;&#x60; [{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}] &#x60;&#x60;&#x60; 
  , hostConfigBlkioDeviceWriteBps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceWriteBps" - Limit write rate (bytes per second) to a device, in the form:  &#x60;&#x60;&#x60; [{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}] &#x60;&#x60;&#x60; 
  , hostConfigBlkioDeviceReadIOps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceReadIOps" - Limit read rate (IO per second) from a device, in the form:  &#x60;&#x60;&#x60; [{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}] &#x60;&#x60;&#x60; 
  , hostConfigBlkioDeviceWriteIOps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceWriteIOps" - Limit write rate (IO per second) to a device, in the form:  &#x60;&#x60;&#x60; [{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}] &#x60;&#x60;&#x60; 
  , hostConfigCpuPeriod :: !(Maybe Integer) -- ^ "CpuPeriod" - The length of a CPU period in microseconds.
  , hostConfigCpuQuota :: !(Maybe Integer) -- ^ "CpuQuota" - Microseconds of CPU time that the container can get in a CPU period. 
  , hostConfigCpuRealtimePeriod :: !(Maybe Integer) -- ^ "CpuRealtimePeriod" - The length of a CPU real-time period in microseconds. Set to 0 to allocate no time allocated to real-time tasks. 
  , hostConfigCpuRealtimeRuntime :: !(Maybe Integer) -- ^ "CpuRealtimeRuntime" - The length of a CPU real-time runtime in microseconds. Set to 0 to allocate no time allocated to real-time tasks. 
  , hostConfigCpusetCpus :: !(Maybe Text) -- ^ "CpusetCpus" - CPUs in which to allow execution (e.g., &#x60;0-3&#x60;, &#x60;0,1&#x60;). 
  , hostConfigCpusetMems :: !(Maybe Text) -- ^ "CpusetMems" - Memory nodes (MEMs) in which to allow execution (0-3, 0,1). Only effective on NUMA systems. 
  , hostConfigDevices :: !(Maybe [DeviceMapping]) -- ^ "Devices" - A list of devices to add to the container.
  , hostConfigDeviceCgroupRules :: !(Maybe [Text]) -- ^ "DeviceCgroupRules" - a list of cgroup rules to apply to the container
  , hostConfigDeviceRequests :: !(Maybe [DeviceRequest]) -- ^ "DeviceRequests" - A list of requests for devices to be sent to device drivers. 
  , hostConfigKernelMemory :: !(Maybe Integer) -- ^ "KernelMemory" - Kernel memory limit in bytes.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Deprecated**: This field is deprecated as the kernel 5.4 deprecated &gt; &#x60;kmem.limit_in_bytes&#x60;. 
  , hostConfigKernelMemoryTcp :: !(Maybe Integer) -- ^ "KernelMemoryTCP" - Hard limit for kernel TCP buffer memory (in bytes).
  , hostConfigMemoryReservation :: !(Maybe Integer) -- ^ "MemoryReservation" - Memory soft limit in bytes.
  , hostConfigMemorySwap :: !(Maybe Integer) -- ^ "MemorySwap" - Total memory limit (memory + swap). Set as &#x60;-1&#x60; to enable unlimited swap. 
  , hostConfigMemorySwappiness :: !(Maybe Integer) -- ^ "MemorySwappiness" - Tune a container&#39;s memory swappiness behavior. Accepts an integer between 0 and 100. 
  , hostConfigNanoCpus :: !(Maybe Integer) -- ^ "NanoCpus" - CPU quota in units of 10&lt;sup&gt;-9&lt;/sup&gt; CPUs.
  , hostConfigOomKillDisable :: !(Maybe Bool) -- ^ "OomKillDisable" - Disable OOM Killer for the container.
  , hostConfigInit :: !(Maybe Bool) -- ^ "Init" - Run an init inside the container that forwards signals and reaps processes. This field is omitted if empty, and the default (as configured on the daemon) is used. 
  , hostConfigPidsLimit :: !(Maybe Integer) -- ^ "PidsLimit" - Tune a container&#39;s PIDs limit. Set &#x60;0&#x60; or &#x60;-1&#x60; for unlimited, or &#x60;null&#x60; to not change. 
  , hostConfigUlimits :: !(Maybe [ResourcesUlimits]) -- ^ "Ulimits" - A list of resource limits to set in the container. For example:  &#x60;&#x60;&#x60; {\&quot;Name\&quot;: \&quot;nofile\&quot;, \&quot;Soft\&quot;: 1024, \&quot;Hard\&quot;: 2048} &#x60;&#x60;&#x60; 
  , hostConfigCpuCount :: !(Maybe Integer) -- ^ "CpuCount" - The number of usable CPUs (Windows only).  On Windows Server containers, the processor resource controls are mutually exclusive. The order of precedence is &#x60;CPUCount&#x60; first, then &#x60;CPUShares&#x60;, and &#x60;CPUPercent&#x60; last. 
  , hostConfigCpuPercent :: !(Maybe Integer) -- ^ "CpuPercent" - The usable percentage of the available CPUs (Windows only).  On Windows Server containers, the processor resource controls are mutually exclusive. The order of precedence is &#x60;CPUCount&#x60; first, then &#x60;CPUShares&#x60;, and &#x60;CPUPercent&#x60; last. 
  , hostConfigIoMaximumIOps :: !(Maybe Integer) -- ^ "IOMaximumIOps" - Maximum IOps for the container system drive (Windows only)
  , hostConfigIoMaximumBandwidth :: !(Maybe Integer) -- ^ "IOMaximumBandwidth" - Maximum IO in bytes per second for the container system drive (Windows only). 
  , hostConfigBinds :: !(Maybe [Text]) -- ^ "Binds" - A list of volume bindings for this container. Each volume binding is a string in one of these forms:  - &#x60;host-src:container-dest[:options]&#x60; to bind-mount a host path   into the container. Both &#x60;host-src&#x60;, and &#x60;container-dest&#x60; must   be an _absolute_ path. - &#x60;volume-name:container-dest[:options]&#x60; to bind-mount a volume   managed by a volume driver into the container. &#x60;container-dest&#x60;   must be an _absolute_ path.  &#x60;options&#x60; is an optional, comma-delimited list of:  - &#x60;nocopy&#x60; disables automatic copying of data from the container   path to the volume. The &#x60;nocopy&#x60; flag only applies to named volumes. - &#x60;[ro|rw]&#x60; mounts a volume read-only or read-write, respectively.   If omitted or set to &#x60;rw&#x60;, volumes are mounted read-write. - &#x60;[z|Z]&#x60; applies SELinux labels to allow or deny multiple containers   to read and write to the same volume.     - &#x60;z&#x60;: a _shared_ content label is applied to the content. This       label indicates that multiple containers can share the volume       content, for both reading and writing.     - &#x60;Z&#x60;: a _private unshared_ label is applied to the content.       This label indicates that only the current container can use       a private volume. Labeling systems such as SELinux require       proper labels to be placed on volume content that is mounted       into a container. Without a label, the security system can       prevent a container&#39;s processes from using the content. By       default, the labels set by the host operating system are not       modified. - &#x60;[[r]shared|[r]slave|[r]private]&#x60; specifies mount   [propagation behavior](https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt).   This only applies to bind-mounted volumes, not internal volumes   or named volumes. Mount propagation requires the source mount   point (the location where the source directory is mounted in the   host operating system) to have the correct propagation properties.   For shared volumes, the source mount point must be set to &#x60;shared&#x60;.   For slave volumes, the mount must be set to either &#x60;shared&#x60; or   &#x60;slave&#x60;. 
  , hostConfigContainerIdFile :: !(Maybe Text) -- ^ "ContainerIDFile" - Path to a file where the container ID is written
  , hostConfigLogConfig :: !(Maybe HostConfigAllOfLogConfig) -- ^ "LogConfig"
  , hostConfigNetworkMode :: !(Maybe Text) -- ^ "NetworkMode" - Network mode to use for this container. Supported standard values are: &#x60;bridge&#x60;, &#x60;host&#x60;, &#x60;none&#x60;, and &#x60;container:&lt;name|id&gt;&#x60;. Any other value is taken as a custom network&#39;s name to which this container should connect to. 
  , hostConfigPortBindings :: !(Maybe (Map.Map String [PortBinding])) -- ^ "PortBindings" - PortMap describes the mapping of container ports to host ports, using the container&#39;s port-number and protocol as key in the format &#x60;&lt;port&gt;/&lt;protocol&gt;&#x60;, for example, &#x60;80/udp&#x60;.  If a container&#39;s port is mapped for multiple protocols, separate entries are added to the mapping table. 
  , hostConfigRestartPolicy :: !(Maybe RestartPolicy) -- ^ "RestartPolicy"
  , hostConfigAutoRemove :: !(Maybe Bool) -- ^ "AutoRemove" - Automatically remove the container when the container&#39;s process exits. This has no effect if &#x60;RestartPolicy&#x60; is set. 
  , hostConfigVolumeDriver :: !(Maybe Text) -- ^ "VolumeDriver" - Driver that this container uses to mount volumes.
  , hostConfigVolumesFrom :: !(Maybe [Text]) -- ^ "VolumesFrom" - A list of volumes to inherit from another container, specified in the form &#x60;&lt;container name&gt;[:&lt;ro|rw&gt;]&#x60;. 
  , hostConfigMounts :: !(Maybe [Mount]) -- ^ "Mounts" - Specification for mounts to be added to the container. 
  , hostConfigCapAdd :: !(Maybe [Text]) -- ^ "CapAdd" - A list of kernel capabilities to add to the container. Conflicts with option &#39;Capabilities&#39;. 
  , hostConfigCapDrop :: !(Maybe [Text]) -- ^ "CapDrop" - A list of kernel capabilities to drop from the container. Conflicts with option &#39;Capabilities&#39;. 
  , hostConfigCgroupnsMode :: !(Maybe E'CgroupnsMode) -- ^ "CgroupnsMode" - cgroup namespace mode for the container. Possible values are:  - &#x60;\&quot;private\&quot;&#x60;: the container runs in its own private cgroup namespace - &#x60;\&quot;host\&quot;&#x60;: use the host system&#39;s cgroup namespace  If not specified, the daemon default is used, which can either be &#x60;\&quot;private\&quot;&#x60; or &#x60;\&quot;host\&quot;&#x60;, depending on daemon version, kernel support and configuration. 
  , hostConfigDns :: !(Maybe [Text]) -- ^ "Dns" - A list of DNS servers for the container to use.
  , hostConfigDnsOptions :: !(Maybe [Text]) -- ^ "DnsOptions" - A list of DNS options.
  , hostConfigDnsSearch :: !(Maybe [Text]) -- ^ "DnsSearch" - A list of DNS search domains.
  , hostConfigExtraHosts :: !(Maybe [Text]) -- ^ "ExtraHosts" - A list of hostnames/IP mappings to add to the container&#39;s &#x60;/etc/hosts&#x60; file. Specified in the form &#x60;[\&quot;hostname:IP\&quot;]&#x60;. 
  , hostConfigGroupAdd :: !(Maybe [Text]) -- ^ "GroupAdd" - A list of additional groups that the container process will run as. 
  , hostConfigIpcMode :: !(Maybe Text) -- ^ "IpcMode" - IPC sharing mode for the container. Possible values are:  - &#x60;\&quot;none\&quot;&#x60;: own private IPC namespace, with /dev/shm not mounted - &#x60;\&quot;private\&quot;&#x60;: own private IPC namespace - &#x60;\&quot;shareable\&quot;&#x60;: own private IPC namespace, with a possibility to share it with other containers - &#x60;\&quot;container:&lt;name|id&gt;\&quot;&#x60;: join another (shareable) container&#39;s IPC namespace - &#x60;\&quot;host\&quot;&#x60;: use the host system&#39;s IPC namespace  If not specified, daemon default is used, which can either be &#x60;\&quot;private\&quot;&#x60; or &#x60;\&quot;shareable\&quot;&#x60;, depending on daemon version and configuration. 
  , hostConfigCgroup :: !(Maybe Text) -- ^ "Cgroup" - Cgroup to use for the container.
  , hostConfigLinks :: !(Maybe [Text]) -- ^ "Links" - A list of links for the container in the form &#x60;container_name:alias&#x60;. 
  , hostConfigOomScoreAdj :: !(Maybe Int) -- ^ "OomScoreAdj" - An integer value containing the score given to the container in order to tune OOM killer preferences. 
  , hostConfigPidMode :: !(Maybe Text) -- ^ "PidMode" - Set the PID (Process) Namespace mode for the container. It can be either:  - &#x60;\&quot;container:&lt;name|id&gt;\&quot;&#x60;: joins another container&#39;s PID namespace - &#x60;\&quot;host\&quot;&#x60;: use the host&#39;s PID namespace inside the container 
  , hostConfigPrivileged :: !(Maybe Bool) -- ^ "Privileged" - Gives the container full access to the host.
  , hostConfigPublishAllPorts :: !(Maybe Bool) -- ^ "PublishAllPorts" - Allocates an ephemeral host port for all of a container&#39;s exposed ports.  Ports are de-allocated when the container stops and allocated when the container starts. The allocated port might be changed when restarting the container.  The port is selected from the ephemeral port range that depends on the kernel. For example, on Linux the range is defined by &#x60;/proc/sys/net/ipv4/ip_local_port_range&#x60;. 
  , hostConfigReadonlyRootfs :: !(Maybe Bool) -- ^ "ReadonlyRootfs" - Mount the container&#39;s root filesystem as read only.
  , hostConfigSecurityOpt :: !(Maybe [Text]) -- ^ "SecurityOpt" - A list of string values to customize labels for MLS systems, such as SELinux. 
  , hostConfigStorageOpt :: !(Maybe (Map.Map String Text)) -- ^ "StorageOpt" - Storage driver options for this container, in the form &#x60;{\&quot;size\&quot;: \&quot;120G\&quot;}&#x60;. 
  , hostConfigTmpfs :: !(Maybe (Map.Map String Text)) -- ^ "Tmpfs" - A map of container directories which should be replaced by tmpfs mounts, and their corresponding mount options. For example:  &#x60;&#x60;&#x60; { \&quot;/run\&quot;: \&quot;rw,noexec,nosuid,size&#x3D;65536k\&quot; } &#x60;&#x60;&#x60; 
  , hostConfigUtsMode :: !(Maybe Text) -- ^ "UTSMode" - UTS namespace to use for the container.
  , hostConfigUsernsMode :: !(Maybe Text) -- ^ "UsernsMode" - Sets the usernamespace mode for the container when usernamespace remapping option is enabled. 
  , hostConfigShmSize :: !(Maybe Int) -- ^ "ShmSize" - Size of &#x60;/dev/shm&#x60; in bytes. If omitted, the system uses 64MB. 
  , hostConfigSysctls :: !(Maybe (Map.Map String Text)) -- ^ "Sysctls" - A list of kernel parameters (sysctls) to set in the container. For example:  &#x60;&#x60;&#x60; {\&quot;net.ipv4.ip_forward\&quot;: \&quot;1\&quot;} &#x60;&#x60;&#x60; 
  , hostConfigRuntime :: !(Maybe Text) -- ^ "Runtime" - Runtime to use with this container.
  , hostConfigConsoleSize :: !(Maybe [Int]) -- ^ "ConsoleSize" - Initial console size, as an &#x60;[height, width]&#x60; array. (Windows only) 
  , hostConfigIsolation :: !(Maybe E'Isolation) -- ^ "Isolation" - Isolation technology of the container. (Windows only) 
  , hostConfigMaskedPaths :: !(Maybe [Text]) -- ^ "MaskedPaths" - The list of paths to be masked inside the container (this overrides the default set of paths). 
  , hostConfigReadonlyPaths :: !(Maybe [Text]) -- ^ "ReadonlyPaths" - The list of paths to be set as read-only inside the container (this overrides the default set of paths). 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HostConfig
instance A.FromJSON HostConfig where
  parseJSON = A.withObject "HostConfig" $ \o ->
    HostConfig
      <$> (o .:? "CpuShares")
      <*> (o .:? "Memory")
      <*> (o .:? "CgroupParent")
      <*> (o .:? "BlkioWeight")
      <*> (o .:? "BlkioWeightDevice")
      <*> (o .:? "BlkioDeviceReadBps")
      <*> (o .:? "BlkioDeviceWriteBps")
      <*> (o .:? "BlkioDeviceReadIOps")
      <*> (o .:? "BlkioDeviceWriteIOps")
      <*> (o .:? "CpuPeriod")
      <*> (o .:? "CpuQuota")
      <*> (o .:? "CpuRealtimePeriod")
      <*> (o .:? "CpuRealtimeRuntime")
      <*> (o .:? "CpusetCpus")
      <*> (o .:? "CpusetMems")
      <*> (o .:? "Devices")
      <*> (o .:? "DeviceCgroupRules")
      <*> (o .:? "DeviceRequests")
      <*> (o .:? "KernelMemory")
      <*> (o .:? "KernelMemoryTCP")
      <*> (o .:? "MemoryReservation")
      <*> (o .:? "MemorySwap")
      <*> (o .:? "MemorySwappiness")
      <*> (o .:? "NanoCpus")
      <*> (o .:? "OomKillDisable")
      <*> (o .:? "Init")
      <*> (o .:? "PidsLimit")
      <*> (o .:? "Ulimits")
      <*> (o .:? "CpuCount")
      <*> (o .:? "CpuPercent")
      <*> (o .:? "IOMaximumIOps")
      <*> (o .:? "IOMaximumBandwidth")
      <*> (o .:? "Binds")
      <*> (o .:? "ContainerIDFile")
      <*> (o .:? "LogConfig")
      <*> (o .:? "NetworkMode")
      <*> (o .:? "PortBindings")
      <*> (o .:? "RestartPolicy")
      <*> (o .:? "AutoRemove")
      <*> (o .:? "VolumeDriver")
      <*> (o .:? "VolumesFrom")
      <*> (o .:? "Mounts")
      <*> (o .:? "CapAdd")
      <*> (o .:? "CapDrop")
      <*> (o .:? "CgroupnsMode")
      <*> (o .:? "Dns")
      <*> (o .:? "DnsOptions")
      <*> (o .:? "DnsSearch")
      <*> (o .:? "ExtraHosts")
      <*> (o .:? "GroupAdd")
      <*> (o .:? "IpcMode")
      <*> (o .:? "Cgroup")
      <*> (o .:? "Links")
      <*> (o .:? "OomScoreAdj")
      <*> (o .:? "PidMode")
      <*> (o .:? "Privileged")
      <*> (o .:? "PublishAllPorts")
      <*> (o .:? "ReadonlyRootfs")
      <*> (o .:? "SecurityOpt")
      <*> (o .:? "StorageOpt")
      <*> (o .:? "Tmpfs")
      <*> (o .:? "UTSMode")
      <*> (o .:? "UsernsMode")
      <*> (o .:? "ShmSize")
      <*> (o .:? "Sysctls")
      <*> (o .:? "Runtime")
      <*> (o .:? "ConsoleSize")
      <*> (o .:? "Isolation")
      <*> (o .:? "MaskedPaths")
      <*> (o .:? "ReadonlyPaths")

-- | ToJSON HostConfig
instance A.ToJSON HostConfig where
  toJSON HostConfig {..} =
   _omitNulls
      [ "CpuShares" .= hostConfigCpuShares
      , "Memory" .= hostConfigMemory
      , "CgroupParent" .= hostConfigCgroupParent
      , "BlkioWeight" .= hostConfigBlkioWeight
      , "BlkioWeightDevice" .= hostConfigBlkioWeightDevice
      , "BlkioDeviceReadBps" .= hostConfigBlkioDeviceReadBps
      , "BlkioDeviceWriteBps" .= hostConfigBlkioDeviceWriteBps
      , "BlkioDeviceReadIOps" .= hostConfigBlkioDeviceReadIOps
      , "BlkioDeviceWriteIOps" .= hostConfigBlkioDeviceWriteIOps
      , "CpuPeriod" .= hostConfigCpuPeriod
      , "CpuQuota" .= hostConfigCpuQuota
      , "CpuRealtimePeriod" .= hostConfigCpuRealtimePeriod
      , "CpuRealtimeRuntime" .= hostConfigCpuRealtimeRuntime
      , "CpusetCpus" .= hostConfigCpusetCpus
      , "CpusetMems" .= hostConfigCpusetMems
      , "Devices" .= hostConfigDevices
      , "DeviceCgroupRules" .= hostConfigDeviceCgroupRules
      , "DeviceRequests" .= hostConfigDeviceRequests
      , "KernelMemory" .= hostConfigKernelMemory
      , "KernelMemoryTCP" .= hostConfigKernelMemoryTcp
      , "MemoryReservation" .= hostConfigMemoryReservation
      , "MemorySwap" .= hostConfigMemorySwap
      , "MemorySwappiness" .= hostConfigMemorySwappiness
      , "NanoCpus" .= hostConfigNanoCpus
      , "OomKillDisable" .= hostConfigOomKillDisable
      , "Init" .= hostConfigInit
      , "PidsLimit" .= hostConfigPidsLimit
      , "Ulimits" .= hostConfigUlimits
      , "CpuCount" .= hostConfigCpuCount
      , "CpuPercent" .= hostConfigCpuPercent
      , "IOMaximumIOps" .= hostConfigIoMaximumIOps
      , "IOMaximumBandwidth" .= hostConfigIoMaximumBandwidth
      , "Binds" .= hostConfigBinds
      , "ContainerIDFile" .= hostConfigContainerIdFile
      , "LogConfig" .= hostConfigLogConfig
      , "NetworkMode" .= hostConfigNetworkMode
      , "PortBindings" .= hostConfigPortBindings
      , "RestartPolicy" .= hostConfigRestartPolicy
      , "AutoRemove" .= hostConfigAutoRemove
      , "VolumeDriver" .= hostConfigVolumeDriver
      , "VolumesFrom" .= hostConfigVolumesFrom
      , "Mounts" .= hostConfigMounts
      , "CapAdd" .= hostConfigCapAdd
      , "CapDrop" .= hostConfigCapDrop
      , "CgroupnsMode" .= hostConfigCgroupnsMode
      , "Dns" .= hostConfigDns
      , "DnsOptions" .= hostConfigDnsOptions
      , "DnsSearch" .= hostConfigDnsSearch
      , "ExtraHosts" .= hostConfigExtraHosts
      , "GroupAdd" .= hostConfigGroupAdd
      , "IpcMode" .= hostConfigIpcMode
      , "Cgroup" .= hostConfigCgroup
      , "Links" .= hostConfigLinks
      , "OomScoreAdj" .= hostConfigOomScoreAdj
      , "PidMode" .= hostConfigPidMode
      , "Privileged" .= hostConfigPrivileged
      , "PublishAllPorts" .= hostConfigPublishAllPorts
      , "ReadonlyRootfs" .= hostConfigReadonlyRootfs
      , "SecurityOpt" .= hostConfigSecurityOpt
      , "StorageOpt" .= hostConfigStorageOpt
      , "Tmpfs" .= hostConfigTmpfs
      , "UTSMode" .= hostConfigUtsMode
      , "UsernsMode" .= hostConfigUsernsMode
      , "ShmSize" .= hostConfigShmSize
      , "Sysctls" .= hostConfigSysctls
      , "Runtime" .= hostConfigRuntime
      , "ConsoleSize" .= hostConfigConsoleSize
      , "Isolation" .= hostConfigIsolation
      , "MaskedPaths" .= hostConfigMaskedPaths
      , "ReadonlyPaths" .= hostConfigReadonlyPaths
      ]


-- | Construct a value of type 'HostConfig' (by applying it's required fields, if any)
mkHostConfig
  :: HostConfig
mkHostConfig =
  HostConfig
  { hostConfigCpuShares = Nothing
  , hostConfigMemory = Nothing
  , hostConfigCgroupParent = Nothing
  , hostConfigBlkioWeight = Nothing
  , hostConfigBlkioWeightDevice = Nothing
  , hostConfigBlkioDeviceReadBps = Nothing
  , hostConfigBlkioDeviceWriteBps = Nothing
  , hostConfigBlkioDeviceReadIOps = Nothing
  , hostConfigBlkioDeviceWriteIOps = Nothing
  , hostConfigCpuPeriod = Nothing
  , hostConfigCpuQuota = Nothing
  , hostConfigCpuRealtimePeriod = Nothing
  , hostConfigCpuRealtimeRuntime = Nothing
  , hostConfigCpusetCpus = Nothing
  , hostConfigCpusetMems = Nothing
  , hostConfigDevices = Nothing
  , hostConfigDeviceCgroupRules = Nothing
  , hostConfigDeviceRequests = Nothing
  , hostConfigKernelMemory = Nothing
  , hostConfigKernelMemoryTcp = Nothing
  , hostConfigMemoryReservation = Nothing
  , hostConfigMemorySwap = Nothing
  , hostConfigMemorySwappiness = Nothing
  , hostConfigNanoCpus = Nothing
  , hostConfigOomKillDisable = Nothing
  , hostConfigInit = Nothing
  , hostConfigPidsLimit = Nothing
  , hostConfigUlimits = Nothing
  , hostConfigCpuCount = Nothing
  , hostConfigCpuPercent = Nothing
  , hostConfigIoMaximumIOps = Nothing
  , hostConfigIoMaximumBandwidth = Nothing
  , hostConfigBinds = Nothing
  , hostConfigContainerIdFile = Nothing
  , hostConfigLogConfig = Nothing
  , hostConfigNetworkMode = Nothing
  , hostConfigPortBindings = Nothing
  , hostConfigRestartPolicy = Nothing
  , hostConfigAutoRemove = Nothing
  , hostConfigVolumeDriver = Nothing
  , hostConfigVolumesFrom = Nothing
  , hostConfigMounts = Nothing
  , hostConfigCapAdd = Nothing
  , hostConfigCapDrop = Nothing
  , hostConfigCgroupnsMode = Nothing
  , hostConfigDns = Nothing
  , hostConfigDnsOptions = Nothing
  , hostConfigDnsSearch = Nothing
  , hostConfigExtraHosts = Nothing
  , hostConfigGroupAdd = Nothing
  , hostConfigIpcMode = Nothing
  , hostConfigCgroup = Nothing
  , hostConfigLinks = Nothing
  , hostConfigOomScoreAdj = Nothing
  , hostConfigPidMode = Nothing
  , hostConfigPrivileged = Nothing
  , hostConfigPublishAllPorts = Nothing
  , hostConfigReadonlyRootfs = Nothing
  , hostConfigSecurityOpt = Nothing
  , hostConfigStorageOpt = Nothing
  , hostConfigTmpfs = Nothing
  , hostConfigUtsMode = Nothing
  , hostConfigUsernsMode = Nothing
  , hostConfigShmSize = Nothing
  , hostConfigSysctls = Nothing
  , hostConfigRuntime = Nothing
  , hostConfigConsoleSize = Nothing
  , hostConfigIsolation = Nothing
  , hostConfigMaskedPaths = Nothing
  , hostConfigReadonlyPaths = Nothing
  }

-- ** HostConfigAllOf
-- | HostConfigAllOf
data HostConfigAllOf = HostConfigAllOf
  { hostConfigAllOfBinds :: !(Maybe [Text]) -- ^ "Binds" - A list of volume bindings for this container. Each volume binding is a string in one of these forms:  - &#x60;host-src:container-dest[:options]&#x60; to bind-mount a host path   into the container. Both &#x60;host-src&#x60;, and &#x60;container-dest&#x60; must   be an _absolute_ path. - &#x60;volume-name:container-dest[:options]&#x60; to bind-mount a volume   managed by a volume driver into the container. &#x60;container-dest&#x60;   must be an _absolute_ path.  &#x60;options&#x60; is an optional, comma-delimited list of:  - &#x60;nocopy&#x60; disables automatic copying of data from the container   path to the volume. The &#x60;nocopy&#x60; flag only applies to named volumes. - &#x60;[ro|rw]&#x60; mounts a volume read-only or read-write, respectively.   If omitted or set to &#x60;rw&#x60;, volumes are mounted read-write. - &#x60;[z|Z]&#x60; applies SELinux labels to allow or deny multiple containers   to read and write to the same volume.     - &#x60;z&#x60;: a _shared_ content label is applied to the content. This       label indicates that multiple containers can share the volume       content, for both reading and writing.     - &#x60;Z&#x60;: a _private unshared_ label is applied to the content.       This label indicates that only the current container can use       a private volume. Labeling systems such as SELinux require       proper labels to be placed on volume content that is mounted       into a container. Without a label, the security system can       prevent a container&#39;s processes from using the content. By       default, the labels set by the host operating system are not       modified. - &#x60;[[r]shared|[r]slave|[r]private]&#x60; specifies mount   [propagation behavior](https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt).   This only applies to bind-mounted volumes, not internal volumes   or named volumes. Mount propagation requires the source mount   point (the location where the source directory is mounted in the   host operating system) to have the correct propagation properties.   For shared volumes, the source mount point must be set to &#x60;shared&#x60;.   For slave volumes, the mount must be set to either &#x60;shared&#x60; or   &#x60;slave&#x60;. 
  , hostConfigAllOfContainerIdFile :: !(Maybe Text) -- ^ "ContainerIDFile" - Path to a file where the container ID is written
  , hostConfigAllOfLogConfig :: !(Maybe HostConfigAllOfLogConfig) -- ^ "LogConfig"
  , hostConfigAllOfNetworkMode :: !(Maybe Text) -- ^ "NetworkMode" - Network mode to use for this container. Supported standard values are: &#x60;bridge&#x60;, &#x60;host&#x60;, &#x60;none&#x60;, and &#x60;container:&lt;name|id&gt;&#x60;. Any other value is taken as a custom network&#39;s name to which this container should connect to. 
  , hostConfigAllOfPortBindings :: !(Maybe (Map.Map String [PortBinding])) -- ^ "PortBindings" - PortMap describes the mapping of container ports to host ports, using the container&#39;s port-number and protocol as key in the format &#x60;&lt;port&gt;/&lt;protocol&gt;&#x60;, for example, &#x60;80/udp&#x60;.  If a container&#39;s port is mapped for multiple protocols, separate entries are added to the mapping table. 
  , hostConfigAllOfRestartPolicy :: !(Maybe RestartPolicy) -- ^ "RestartPolicy"
  , hostConfigAllOfAutoRemove :: !(Maybe Bool) -- ^ "AutoRemove" - Automatically remove the container when the container&#39;s process exits. This has no effect if &#x60;RestartPolicy&#x60; is set. 
  , hostConfigAllOfVolumeDriver :: !(Maybe Text) -- ^ "VolumeDriver" - Driver that this container uses to mount volumes.
  , hostConfigAllOfVolumesFrom :: !(Maybe [Text]) -- ^ "VolumesFrom" - A list of volumes to inherit from another container, specified in the form &#x60;&lt;container name&gt;[:&lt;ro|rw&gt;]&#x60;. 
  , hostConfigAllOfMounts :: !(Maybe [Mount]) -- ^ "Mounts" - Specification for mounts to be added to the container. 
  , hostConfigAllOfCapAdd :: !(Maybe [Text]) -- ^ "CapAdd" - A list of kernel capabilities to add to the container. Conflicts with option &#39;Capabilities&#39;. 
  , hostConfigAllOfCapDrop :: !(Maybe [Text]) -- ^ "CapDrop" - A list of kernel capabilities to drop from the container. Conflicts with option &#39;Capabilities&#39;. 
  , hostConfigAllOfCgroupnsMode :: !(Maybe E'CgroupnsMode) -- ^ "CgroupnsMode" - cgroup namespace mode for the container. Possible values are:  - &#x60;\&quot;private\&quot;&#x60;: the container runs in its own private cgroup namespace - &#x60;\&quot;host\&quot;&#x60;: use the host system&#39;s cgroup namespace  If not specified, the daemon default is used, which can either be &#x60;\&quot;private\&quot;&#x60; or &#x60;\&quot;host\&quot;&#x60;, depending on daemon version, kernel support and configuration. 
  , hostConfigAllOfDns :: !(Maybe [Text]) -- ^ "Dns" - A list of DNS servers for the container to use.
  , hostConfigAllOfDnsOptions :: !(Maybe [Text]) -- ^ "DnsOptions" - A list of DNS options.
  , hostConfigAllOfDnsSearch :: !(Maybe [Text]) -- ^ "DnsSearch" - A list of DNS search domains.
  , hostConfigAllOfExtraHosts :: !(Maybe [Text]) -- ^ "ExtraHosts" - A list of hostnames/IP mappings to add to the container&#39;s &#x60;/etc/hosts&#x60; file. Specified in the form &#x60;[\&quot;hostname:IP\&quot;]&#x60;. 
  , hostConfigAllOfGroupAdd :: !(Maybe [Text]) -- ^ "GroupAdd" - A list of additional groups that the container process will run as. 
  , hostConfigAllOfIpcMode :: !(Maybe Text) -- ^ "IpcMode" - IPC sharing mode for the container. Possible values are:  - &#x60;\&quot;none\&quot;&#x60;: own private IPC namespace, with /dev/shm not mounted - &#x60;\&quot;private\&quot;&#x60;: own private IPC namespace - &#x60;\&quot;shareable\&quot;&#x60;: own private IPC namespace, with a possibility to share it with other containers - &#x60;\&quot;container:&lt;name|id&gt;\&quot;&#x60;: join another (shareable) container&#39;s IPC namespace - &#x60;\&quot;host\&quot;&#x60;: use the host system&#39;s IPC namespace  If not specified, daemon default is used, which can either be &#x60;\&quot;private\&quot;&#x60; or &#x60;\&quot;shareable\&quot;&#x60;, depending on daemon version and configuration. 
  , hostConfigAllOfCgroup :: !(Maybe Text) -- ^ "Cgroup" - Cgroup to use for the container.
  , hostConfigAllOfLinks :: !(Maybe [Text]) -- ^ "Links" - A list of links for the container in the form &#x60;container_name:alias&#x60;. 
  , hostConfigAllOfOomScoreAdj :: !(Maybe Int) -- ^ "OomScoreAdj" - An integer value containing the score given to the container in order to tune OOM killer preferences. 
  , hostConfigAllOfPidMode :: !(Maybe Text) -- ^ "PidMode" - Set the PID (Process) Namespace mode for the container. It can be either:  - &#x60;\&quot;container:&lt;name|id&gt;\&quot;&#x60;: joins another container&#39;s PID namespace - &#x60;\&quot;host\&quot;&#x60;: use the host&#39;s PID namespace inside the container 
  , hostConfigAllOfPrivileged :: !(Maybe Bool) -- ^ "Privileged" - Gives the container full access to the host.
  , hostConfigAllOfPublishAllPorts :: !(Maybe Bool) -- ^ "PublishAllPorts" - Allocates an ephemeral host port for all of a container&#39;s exposed ports.  Ports are de-allocated when the container stops and allocated when the container starts. The allocated port might be changed when restarting the container.  The port is selected from the ephemeral port range that depends on the kernel. For example, on Linux the range is defined by &#x60;/proc/sys/net/ipv4/ip_local_port_range&#x60;. 
  , hostConfigAllOfReadonlyRootfs :: !(Maybe Bool) -- ^ "ReadonlyRootfs" - Mount the container&#39;s root filesystem as read only.
  , hostConfigAllOfSecurityOpt :: !(Maybe [Text]) -- ^ "SecurityOpt" - A list of string values to customize labels for MLS systems, such as SELinux. 
  , hostConfigAllOfStorageOpt :: !(Maybe (Map.Map String Text)) -- ^ "StorageOpt" - Storage driver options for this container, in the form &#x60;{\&quot;size\&quot;: \&quot;120G\&quot;}&#x60;. 
  , hostConfigAllOfTmpfs :: !(Maybe (Map.Map String Text)) -- ^ "Tmpfs" - A map of container directories which should be replaced by tmpfs mounts, and their corresponding mount options. For example:  &#x60;&#x60;&#x60; { \&quot;/run\&quot;: \&quot;rw,noexec,nosuid,size&#x3D;65536k\&quot; } &#x60;&#x60;&#x60; 
  , hostConfigAllOfUtsMode :: !(Maybe Text) -- ^ "UTSMode" - UTS namespace to use for the container.
  , hostConfigAllOfUsernsMode :: !(Maybe Text) -- ^ "UsernsMode" - Sets the usernamespace mode for the container when usernamespace remapping option is enabled. 
  , hostConfigAllOfShmSize :: !(Maybe Int) -- ^ "ShmSize" - Size of &#x60;/dev/shm&#x60; in bytes. If omitted, the system uses 64MB. 
  , hostConfigAllOfSysctls :: !(Maybe (Map.Map String Text)) -- ^ "Sysctls" - A list of kernel parameters (sysctls) to set in the container. For example:  &#x60;&#x60;&#x60; {\&quot;net.ipv4.ip_forward\&quot;: \&quot;1\&quot;} &#x60;&#x60;&#x60; 
  , hostConfigAllOfRuntime :: !(Maybe Text) -- ^ "Runtime" - Runtime to use with this container.
  , hostConfigAllOfConsoleSize :: !(Maybe [Int]) -- ^ "ConsoleSize" - Initial console size, as an &#x60;[height, width]&#x60; array. (Windows only) 
  , hostConfigAllOfIsolation :: !(Maybe E'Isolation) -- ^ "Isolation" - Isolation technology of the container. (Windows only) 
  , hostConfigAllOfMaskedPaths :: !(Maybe [Text]) -- ^ "MaskedPaths" - The list of paths to be masked inside the container (this overrides the default set of paths). 
  , hostConfigAllOfReadonlyPaths :: !(Maybe [Text]) -- ^ "ReadonlyPaths" - The list of paths to be set as read-only inside the container (this overrides the default set of paths). 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HostConfigAllOf
instance A.FromJSON HostConfigAllOf where
  parseJSON = A.withObject "HostConfigAllOf" $ \o ->
    HostConfigAllOf
      <$> (o .:? "Binds")
      <*> (o .:? "ContainerIDFile")
      <*> (o .:? "LogConfig")
      <*> (o .:? "NetworkMode")
      <*> (o .:? "PortBindings")
      <*> (o .:? "RestartPolicy")
      <*> (o .:? "AutoRemove")
      <*> (o .:? "VolumeDriver")
      <*> (o .:? "VolumesFrom")
      <*> (o .:? "Mounts")
      <*> (o .:? "CapAdd")
      <*> (o .:? "CapDrop")
      <*> (o .:? "CgroupnsMode")
      <*> (o .:? "Dns")
      <*> (o .:? "DnsOptions")
      <*> (o .:? "DnsSearch")
      <*> (o .:? "ExtraHosts")
      <*> (o .:? "GroupAdd")
      <*> (o .:? "IpcMode")
      <*> (o .:? "Cgroup")
      <*> (o .:? "Links")
      <*> (o .:? "OomScoreAdj")
      <*> (o .:? "PidMode")
      <*> (o .:? "Privileged")
      <*> (o .:? "PublishAllPorts")
      <*> (o .:? "ReadonlyRootfs")
      <*> (o .:? "SecurityOpt")
      <*> (o .:? "StorageOpt")
      <*> (o .:? "Tmpfs")
      <*> (o .:? "UTSMode")
      <*> (o .:? "UsernsMode")
      <*> (o .:? "ShmSize")
      <*> (o .:? "Sysctls")
      <*> (o .:? "Runtime")
      <*> (o .:? "ConsoleSize")
      <*> (o .:? "Isolation")
      <*> (o .:? "MaskedPaths")
      <*> (o .:? "ReadonlyPaths")

-- | ToJSON HostConfigAllOf
instance A.ToJSON HostConfigAllOf where
  toJSON HostConfigAllOf {..} =
   _omitNulls
      [ "Binds" .= hostConfigAllOfBinds
      , "ContainerIDFile" .= hostConfigAllOfContainerIdFile
      , "LogConfig" .= hostConfigAllOfLogConfig
      , "NetworkMode" .= hostConfigAllOfNetworkMode
      , "PortBindings" .= hostConfigAllOfPortBindings
      , "RestartPolicy" .= hostConfigAllOfRestartPolicy
      , "AutoRemove" .= hostConfigAllOfAutoRemove
      , "VolumeDriver" .= hostConfigAllOfVolumeDriver
      , "VolumesFrom" .= hostConfigAllOfVolumesFrom
      , "Mounts" .= hostConfigAllOfMounts
      , "CapAdd" .= hostConfigAllOfCapAdd
      , "CapDrop" .= hostConfigAllOfCapDrop
      , "CgroupnsMode" .= hostConfigAllOfCgroupnsMode
      , "Dns" .= hostConfigAllOfDns
      , "DnsOptions" .= hostConfigAllOfDnsOptions
      , "DnsSearch" .= hostConfigAllOfDnsSearch
      , "ExtraHosts" .= hostConfigAllOfExtraHosts
      , "GroupAdd" .= hostConfigAllOfGroupAdd
      , "IpcMode" .= hostConfigAllOfIpcMode
      , "Cgroup" .= hostConfigAllOfCgroup
      , "Links" .= hostConfigAllOfLinks
      , "OomScoreAdj" .= hostConfigAllOfOomScoreAdj
      , "PidMode" .= hostConfigAllOfPidMode
      , "Privileged" .= hostConfigAllOfPrivileged
      , "PublishAllPorts" .= hostConfigAllOfPublishAllPorts
      , "ReadonlyRootfs" .= hostConfigAllOfReadonlyRootfs
      , "SecurityOpt" .= hostConfigAllOfSecurityOpt
      , "StorageOpt" .= hostConfigAllOfStorageOpt
      , "Tmpfs" .= hostConfigAllOfTmpfs
      , "UTSMode" .= hostConfigAllOfUtsMode
      , "UsernsMode" .= hostConfigAllOfUsernsMode
      , "ShmSize" .= hostConfigAllOfShmSize
      , "Sysctls" .= hostConfigAllOfSysctls
      , "Runtime" .= hostConfigAllOfRuntime
      , "ConsoleSize" .= hostConfigAllOfConsoleSize
      , "Isolation" .= hostConfigAllOfIsolation
      , "MaskedPaths" .= hostConfigAllOfMaskedPaths
      , "ReadonlyPaths" .= hostConfigAllOfReadonlyPaths
      ]


-- | Construct a value of type 'HostConfigAllOf' (by applying it's required fields, if any)
mkHostConfigAllOf
  :: HostConfigAllOf
mkHostConfigAllOf =
  HostConfigAllOf
  { hostConfigAllOfBinds = Nothing
  , hostConfigAllOfContainerIdFile = Nothing
  , hostConfigAllOfLogConfig = Nothing
  , hostConfigAllOfNetworkMode = Nothing
  , hostConfigAllOfPortBindings = Nothing
  , hostConfigAllOfRestartPolicy = Nothing
  , hostConfigAllOfAutoRemove = Nothing
  , hostConfigAllOfVolumeDriver = Nothing
  , hostConfigAllOfVolumesFrom = Nothing
  , hostConfigAllOfMounts = Nothing
  , hostConfigAllOfCapAdd = Nothing
  , hostConfigAllOfCapDrop = Nothing
  , hostConfigAllOfCgroupnsMode = Nothing
  , hostConfigAllOfDns = Nothing
  , hostConfigAllOfDnsOptions = Nothing
  , hostConfigAllOfDnsSearch = Nothing
  , hostConfigAllOfExtraHosts = Nothing
  , hostConfigAllOfGroupAdd = Nothing
  , hostConfigAllOfIpcMode = Nothing
  , hostConfigAllOfCgroup = Nothing
  , hostConfigAllOfLinks = Nothing
  , hostConfigAllOfOomScoreAdj = Nothing
  , hostConfigAllOfPidMode = Nothing
  , hostConfigAllOfPrivileged = Nothing
  , hostConfigAllOfPublishAllPorts = Nothing
  , hostConfigAllOfReadonlyRootfs = Nothing
  , hostConfigAllOfSecurityOpt = Nothing
  , hostConfigAllOfStorageOpt = Nothing
  , hostConfigAllOfTmpfs = Nothing
  , hostConfigAllOfUtsMode = Nothing
  , hostConfigAllOfUsernsMode = Nothing
  , hostConfigAllOfShmSize = Nothing
  , hostConfigAllOfSysctls = Nothing
  , hostConfigAllOfRuntime = Nothing
  , hostConfigAllOfConsoleSize = Nothing
  , hostConfigAllOfIsolation = Nothing
  , hostConfigAllOfMaskedPaths = Nothing
  , hostConfigAllOfReadonlyPaths = Nothing
  }

-- ** HostConfigAllOfLogConfig
-- | HostConfigAllOfLogConfig
-- The logging configuration for this container
data HostConfigAllOfLogConfig = HostConfigAllOfLogConfig
  { hostConfigAllOfLogConfigType :: !(Maybe E'Type4) -- ^ "Type"
  , hostConfigAllOfLogConfigConfig :: !(Maybe (Map.Map String Text)) -- ^ "Config"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HostConfigAllOfLogConfig
instance A.FromJSON HostConfigAllOfLogConfig where
  parseJSON = A.withObject "HostConfigAllOfLogConfig" $ \o ->
    HostConfigAllOfLogConfig
      <$> (o .:? "Type")
      <*> (o .:? "Config")

-- | ToJSON HostConfigAllOfLogConfig
instance A.ToJSON HostConfigAllOfLogConfig where
  toJSON HostConfigAllOfLogConfig {..} =
   _omitNulls
      [ "Type" .= hostConfigAllOfLogConfigType
      , "Config" .= hostConfigAllOfLogConfigConfig
      ]


-- | Construct a value of type 'HostConfigAllOfLogConfig' (by applying it's required fields, if any)
mkHostConfigAllOfLogConfig
  :: HostConfigAllOfLogConfig
mkHostConfigAllOfLogConfig =
  HostConfigAllOfLogConfig
  { hostConfigAllOfLogConfigType = Nothing
  , hostConfigAllOfLogConfigConfig = Nothing
  }

-- ** IPAM
-- | IPAM
data IPAM = IPAM
  { iPAMDriver :: !(Maybe Text) -- ^ "Driver" - Name of the IPAM driver to use.
  , iPAMConfig :: !(Maybe [IPAMConfig]) -- ^ "Config" - List of IPAM configuration options, specified as a map:  &#x60;&#x60;&#x60; {\&quot;Subnet\&quot;: &lt;CIDR&gt;, \&quot;IPRange\&quot;: &lt;CIDR&gt;, \&quot;Gateway\&quot;: &lt;IP address&gt;, \&quot;AuxAddress\&quot;: &lt;device_name:IP address&gt;} &#x60;&#x60;&#x60; 
  , iPAMOptions :: !(Maybe (Map.Map String Text)) -- ^ "Options" - Driver-specific options, specified as a map.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IPAM
instance A.FromJSON IPAM where
  parseJSON = A.withObject "IPAM" $ \o ->
    IPAM
      <$> (o .:? "Driver")
      <*> (o .:? "Config")
      <*> (o .:? "Options")

-- | ToJSON IPAM
instance A.ToJSON IPAM where
  toJSON IPAM {..} =
   _omitNulls
      [ "Driver" .= iPAMDriver
      , "Config" .= iPAMConfig
      , "Options" .= iPAMOptions
      ]


-- | Construct a value of type 'IPAM' (by applying it's required fields, if any)
mkIPAM
  :: IPAM
mkIPAM =
  IPAM
  { iPAMDriver = Nothing
  , iPAMConfig = Nothing
  , iPAMOptions = Nothing
  }

-- ** IPAMConfig
-- | IPAMConfig
data IPAMConfig = IPAMConfig
  { iPAMConfigSubnet :: !(Maybe Text) -- ^ "Subnet"
  , iPAMConfigIpRange :: !(Maybe Text) -- ^ "IPRange"
  , iPAMConfigGateway :: !(Maybe Text) -- ^ "Gateway"
  , iPAMConfigAuxiliaryAddresses :: !(Maybe (Map.Map String Text)) -- ^ "AuxiliaryAddresses"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IPAMConfig
instance A.FromJSON IPAMConfig where
  parseJSON = A.withObject "IPAMConfig" $ \o ->
    IPAMConfig
      <$> (o .:? "Subnet")
      <*> (o .:? "IPRange")
      <*> (o .:? "Gateway")
      <*> (o .:? "AuxiliaryAddresses")

-- | ToJSON IPAMConfig
instance A.ToJSON IPAMConfig where
  toJSON IPAMConfig {..} =
   _omitNulls
      [ "Subnet" .= iPAMConfigSubnet
      , "IPRange" .= iPAMConfigIpRange
      , "Gateway" .= iPAMConfigGateway
      , "AuxiliaryAddresses" .= iPAMConfigAuxiliaryAddresses
      ]


-- | Construct a value of type 'IPAMConfig' (by applying it's required fields, if any)
mkIPAMConfig
  :: IPAMConfig
mkIPAMConfig =
  IPAMConfig
  { iPAMConfigSubnet = Nothing
  , iPAMConfigIpRange = Nothing
  , iPAMConfigGateway = Nothing
  , iPAMConfigAuxiliaryAddresses = Nothing
  }

-- ** IdResponse
-- | IdResponse
-- Response to an API call that returns just an Id
data IdResponse = IdResponse
  { idResponseId :: !(Text) -- ^ /Required/ "Id" - The id of the newly created object.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IdResponse
instance A.FromJSON IdResponse where
  parseJSON = A.withObject "IdResponse" $ \o ->
    IdResponse
      <$> (o .:  "Id")

-- | ToJSON IdResponse
instance A.ToJSON IdResponse where
  toJSON IdResponse {..} =
   _omitNulls
      [ "Id" .= idResponseId
      ]


-- | Construct a value of type 'IdResponse' (by applying it's required fields, if any)
mkIdResponse
  :: Text -- ^ 'idResponseId': The id of the newly created object.
  -> IdResponse
mkIdResponse idResponseId =
  IdResponse
  { idResponseId
  }

-- ** ImageDeleteResponseItem
-- | ImageDeleteResponseItem
data ImageDeleteResponseItem = ImageDeleteResponseItem
  { imageDeleteResponseItemUntagged :: !(Maybe Text) -- ^ "Untagged" - The image ID of an image that was untagged
  , imageDeleteResponseItemDeleted :: !(Maybe Text) -- ^ "Deleted" - The image ID of an image that was deleted
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ImageDeleteResponseItem
instance A.FromJSON ImageDeleteResponseItem where
  parseJSON = A.withObject "ImageDeleteResponseItem" $ \o ->
    ImageDeleteResponseItem
      <$> (o .:? "Untagged")
      <*> (o .:? "Deleted")

-- | ToJSON ImageDeleteResponseItem
instance A.ToJSON ImageDeleteResponseItem where
  toJSON ImageDeleteResponseItem {..} =
   _omitNulls
      [ "Untagged" .= imageDeleteResponseItemUntagged
      , "Deleted" .= imageDeleteResponseItemDeleted
      ]


-- | Construct a value of type 'ImageDeleteResponseItem' (by applying it's required fields, if any)
mkImageDeleteResponseItem
  :: ImageDeleteResponseItem
mkImageDeleteResponseItem =
  ImageDeleteResponseItem
  { imageDeleteResponseItemUntagged = Nothing
  , imageDeleteResponseItemDeleted = Nothing
  }

-- ** ImageID
-- | ImageID
-- Image ID or Digest
data ImageID = ImageID
  { imageIDId :: !(Maybe Text) -- ^ "ID"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ImageID
instance A.FromJSON ImageID where
  parseJSON = A.withObject "ImageID" $ \o ->
    ImageID
      <$> (o .:? "ID")

-- | ToJSON ImageID
instance A.ToJSON ImageID where
  toJSON ImageID {..} =
   _omitNulls
      [ "ID" .= imageIDId
      ]


-- | Construct a value of type 'ImageID' (by applying it's required fields, if any)
mkImageID
  :: ImageID
mkImageID =
  ImageID
  { imageIDId = Nothing
  }

-- ** ImageInspect
-- | ImageInspect
-- Information about an image in the local image cache. 
data ImageInspect = ImageInspect
  { imageInspectId :: !(Maybe Text) -- ^ "Id" - ID is the content-addressable ID of an image.  This identified is a content-addressable digest calculated from the image&#39;s configuration (which includes the digests of layers used by the image).  Note that this digest differs from the &#x60;RepoDigests&#x60; below, which holds digests of image manifests that reference the image. 
  , imageInspectRepoTags :: !(Maybe [Text]) -- ^ "RepoTags" - List of image names/tags in the local image cache that reference this image.  Multiple image tags can refer to the same imagem and this list may be empty if no tags reference the image, in which case the image is \&quot;untagged\&quot;, in which case it can still be referenced by its ID. 
  , imageInspectRepoDigests :: !(Maybe [Text]) -- ^ "RepoDigests" - List of content-addressable digests of locally available image manifests that the image is referenced from. Multiple manifests can refer to the same image.  These digests are usually only available if the image was either pulled from a registry, or if the image was pushed to a registry, which is when the manifest is generated and its digest calculated. 
  , imageInspectParent :: !(Maybe Text) -- ^ "Parent" - ID of the parent image.  Depending on how the image was created, this field may be empty and is only set for images that were built/created locally. This field is empty if the image was pulled from an image registry. 
  , imageInspectComment :: !(Maybe Text) -- ^ "Comment" - Optional message that was set when committing or importing the image. 
  , imageInspectCreated :: !(Maybe Text) -- ^ "Created" - Date and time at which the image was created, formatted in [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds. 
  , imageInspectContainer :: !(Maybe Text) -- ^ "Container" - The ID of the container that was used to create the image.  Depending on how the image was created, this field may be empty. 
  , imageInspectContainerConfig :: !(Maybe ContainerConfig) -- ^ "ContainerConfig"
  , imageInspectDockerVersion :: !(Maybe Text) -- ^ "DockerVersion" - The version of Docker that was used to build the image.  Depending on how the image was created, this field may be empty. 
  , imageInspectAuthor :: !(Maybe Text) -- ^ "Author" - Name of the author that was specified when committing the image, or as specified through MAINTAINER (deprecated) in the Dockerfile. 
  , imageInspectConfig :: !(Maybe ContainerConfig) -- ^ "Config"
  , imageInspectArchitecture :: !(Maybe Text) -- ^ "Architecture" - Hardware CPU architecture that the image runs on. 
  , imageInspectVariant :: !(Maybe Text) -- ^ "Variant" - CPU architecture variant (presently ARM-only). 
  , imageInspectOs :: !(Maybe Text) -- ^ "Os" - Operating System the image is built to run on. 
  , imageInspectOsVersion :: !(Maybe Text) -- ^ "OsVersion" - Operating System version the image is built to run on (especially for Windows). 
  , imageInspectSize :: !(Maybe Integer) -- ^ "Size" - Total size of the image including all layers it is composed of. 
  , imageInspectVirtualSize :: !(Maybe Integer) -- ^ "VirtualSize" - Total size of the image including all layers it is composed of.  In versions of Docker before v1.10, this field was calculated from the image itself and all of its parent images. Docker v1.10 and up store images self-contained, and no longer use a parent-chain, making this field an equivalent of the Size field.  This field is kept for backward compatibility, but may be removed in a future version of the API. 
  , imageInspectGraphDriver :: !(Maybe GraphDriverData) -- ^ "GraphDriver"
  , imageInspectRootFs :: !(Maybe ImageInspectRootFS) -- ^ "RootFS"
  , imageInspectMetadata :: !(Maybe ImageInspectMetadata) -- ^ "Metadata"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ImageInspect
instance A.FromJSON ImageInspect where
  parseJSON = A.withObject "ImageInspect" $ \o ->
    ImageInspect
      <$> (o .:? "Id")
      <*> (o .:? "RepoTags")
      <*> (o .:? "RepoDigests")
      <*> (o .:? "Parent")
      <*> (o .:? "Comment")
      <*> (o .:? "Created")
      <*> (o .:? "Container")
      <*> (o .:? "ContainerConfig")
      <*> (o .:? "DockerVersion")
      <*> (o .:? "Author")
      <*> (o .:? "Config")
      <*> (o .:? "Architecture")
      <*> (o .:? "Variant")
      <*> (o .:? "Os")
      <*> (o .:? "OsVersion")
      <*> (o .:? "Size")
      <*> (o .:? "VirtualSize")
      <*> (o .:? "GraphDriver")
      <*> (o .:? "RootFS")
      <*> (o .:? "Metadata")

-- | ToJSON ImageInspect
instance A.ToJSON ImageInspect where
  toJSON ImageInspect {..} =
   _omitNulls
      [ "Id" .= imageInspectId
      , "RepoTags" .= imageInspectRepoTags
      , "RepoDigests" .= imageInspectRepoDigests
      , "Parent" .= imageInspectParent
      , "Comment" .= imageInspectComment
      , "Created" .= imageInspectCreated
      , "Container" .= imageInspectContainer
      , "ContainerConfig" .= imageInspectContainerConfig
      , "DockerVersion" .= imageInspectDockerVersion
      , "Author" .= imageInspectAuthor
      , "Config" .= imageInspectConfig
      , "Architecture" .= imageInspectArchitecture
      , "Variant" .= imageInspectVariant
      , "Os" .= imageInspectOs
      , "OsVersion" .= imageInspectOsVersion
      , "Size" .= imageInspectSize
      , "VirtualSize" .= imageInspectVirtualSize
      , "GraphDriver" .= imageInspectGraphDriver
      , "RootFS" .= imageInspectRootFs
      , "Metadata" .= imageInspectMetadata
      ]


-- | Construct a value of type 'ImageInspect' (by applying it's required fields, if any)
mkImageInspect
  :: ImageInspect
mkImageInspect =
  ImageInspect
  { imageInspectId = Nothing
  , imageInspectRepoTags = Nothing
  , imageInspectRepoDigests = Nothing
  , imageInspectParent = Nothing
  , imageInspectComment = Nothing
  , imageInspectCreated = Nothing
  , imageInspectContainer = Nothing
  , imageInspectContainerConfig = Nothing
  , imageInspectDockerVersion = Nothing
  , imageInspectAuthor = Nothing
  , imageInspectConfig = Nothing
  , imageInspectArchitecture = Nothing
  , imageInspectVariant = Nothing
  , imageInspectOs = Nothing
  , imageInspectOsVersion = Nothing
  , imageInspectSize = Nothing
  , imageInspectVirtualSize = Nothing
  , imageInspectGraphDriver = Nothing
  , imageInspectRootFs = Nothing
  , imageInspectMetadata = Nothing
  }

-- ** ImageInspectMetadata
-- | ImageInspectMetadata
-- Additional metadata of the image in the local cache. This information is local to the daemon, and not part of the image itself. 
data ImageInspectMetadata = ImageInspectMetadata
  { imageInspectMetadataLastTagTime :: !(Maybe Text) -- ^ "LastTagTime" - Date and time at which the image was last tagged in [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.  This information is only available if the image was tagged locally, and omitted otherwise. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ImageInspectMetadata
instance A.FromJSON ImageInspectMetadata where
  parseJSON = A.withObject "ImageInspectMetadata" $ \o ->
    ImageInspectMetadata
      <$> (o .:? "LastTagTime")

-- | ToJSON ImageInspectMetadata
instance A.ToJSON ImageInspectMetadata where
  toJSON ImageInspectMetadata {..} =
   _omitNulls
      [ "LastTagTime" .= imageInspectMetadataLastTagTime
      ]


-- | Construct a value of type 'ImageInspectMetadata' (by applying it's required fields, if any)
mkImageInspectMetadata
  :: ImageInspectMetadata
mkImageInspectMetadata =
  ImageInspectMetadata
  { imageInspectMetadataLastTagTime = Nothing
  }

-- ** ImageInspectRootFS
-- | ImageInspectRootFS
-- Information about the image's RootFS, including the layer IDs. 
data ImageInspectRootFS = ImageInspectRootFS
  { imageInspectRootFSType :: !(Text) -- ^ /Required/ "Type"
  , imageInspectRootFSLayers :: !(Maybe [Text]) -- ^ "Layers"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ImageInspectRootFS
instance A.FromJSON ImageInspectRootFS where
  parseJSON = A.withObject "ImageInspectRootFS" $ \o ->
    ImageInspectRootFS
      <$> (o .:  "Type")
      <*> (o .:? "Layers")

-- | ToJSON ImageInspectRootFS
instance A.ToJSON ImageInspectRootFS where
  toJSON ImageInspectRootFS {..} =
   _omitNulls
      [ "Type" .= imageInspectRootFSType
      , "Layers" .= imageInspectRootFSLayers
      ]


-- | Construct a value of type 'ImageInspectRootFS' (by applying it's required fields, if any)
mkImageInspectRootFS
  :: Text -- ^ 'imageInspectRootFSType' 
  -> ImageInspectRootFS
mkImageInspectRootFS imageInspectRootFSType =
  ImageInspectRootFS
  { imageInspectRootFSType
  , imageInspectRootFSLayers = Nothing
  }

-- ** ImagePruneResponse
-- | ImagePruneResponse
-- ImagePruneResponse
-- 
data ImagePruneResponse = ImagePruneResponse
  { imagePruneResponseImagesDeleted :: !(Maybe [ImageDeleteResponseItem]) -- ^ "ImagesDeleted" - Images that were deleted
  , imagePruneResponseSpaceReclaimed :: !(Maybe Integer) -- ^ "SpaceReclaimed" - Disk space reclaimed in bytes
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ImagePruneResponse
instance A.FromJSON ImagePruneResponse where
  parseJSON = A.withObject "ImagePruneResponse" $ \o ->
    ImagePruneResponse
      <$> (o .:? "ImagesDeleted")
      <*> (o .:? "SpaceReclaimed")

-- | ToJSON ImagePruneResponse
instance A.ToJSON ImagePruneResponse where
  toJSON ImagePruneResponse {..} =
   _omitNulls
      [ "ImagesDeleted" .= imagePruneResponseImagesDeleted
      , "SpaceReclaimed" .= imagePruneResponseSpaceReclaimed
      ]


-- | Construct a value of type 'ImagePruneResponse' (by applying it's required fields, if any)
mkImagePruneResponse
  :: ImagePruneResponse
mkImagePruneResponse =
  ImagePruneResponse
  { imagePruneResponseImagesDeleted = Nothing
  , imagePruneResponseSpaceReclaimed = Nothing
  }

-- ** ImageSearchResponseItem
-- | ImageSearchResponseItem
-- ImageSearchResponseItem
-- 
data ImageSearchResponseItem = ImageSearchResponseItem
  { imageSearchResponseItemDescription :: !(Maybe Text) -- ^ "description"
  , imageSearchResponseItemIsOfficial :: !(Maybe Bool) -- ^ "is_official"
  , imageSearchResponseItemIsAutomated :: !(Maybe Bool) -- ^ "is_automated"
  , imageSearchResponseItemName :: !(Maybe Text) -- ^ "name"
  , imageSearchResponseItemStarCount :: !(Maybe Int) -- ^ "star_count"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ImageSearchResponseItem
instance A.FromJSON ImageSearchResponseItem where
  parseJSON = A.withObject "ImageSearchResponseItem" $ \o ->
    ImageSearchResponseItem
      <$> (o .:? "description")
      <*> (o .:? "is_official")
      <*> (o .:? "is_automated")
      <*> (o .:? "name")
      <*> (o .:? "star_count")

-- | ToJSON ImageSearchResponseItem
instance A.ToJSON ImageSearchResponseItem where
  toJSON ImageSearchResponseItem {..} =
   _omitNulls
      [ "description" .= imageSearchResponseItemDescription
      , "is_official" .= imageSearchResponseItemIsOfficial
      , "is_automated" .= imageSearchResponseItemIsAutomated
      , "name" .= imageSearchResponseItemName
      , "star_count" .= imageSearchResponseItemStarCount
      ]


-- | Construct a value of type 'ImageSearchResponseItem' (by applying it's required fields, if any)
mkImageSearchResponseItem
  :: ImageSearchResponseItem
mkImageSearchResponseItem =
  ImageSearchResponseItem
  { imageSearchResponseItemDescription = Nothing
  , imageSearchResponseItemIsOfficial = Nothing
  , imageSearchResponseItemIsAutomated = Nothing
  , imageSearchResponseItemName = Nothing
  , imageSearchResponseItemStarCount = Nothing
  }

-- ** ImageSummary
-- | ImageSummary
data ImageSummary = ImageSummary
  { imageSummaryId :: !(Text) -- ^ /Required/ "Id"
  , imageSummaryParentId :: !(Text) -- ^ /Required/ "ParentId"
  , imageSummaryRepoTags :: !([Text]) -- ^ /Required/ "RepoTags"
  , imageSummaryRepoDigests :: !([Text]) -- ^ /Required/ "RepoDigests"
  , imageSummaryCreated :: !(Int) -- ^ /Required/ "Created"
  , imageSummarySize :: !(Int) -- ^ /Required/ "Size"
  , imageSummarySharedSize :: !(Int) -- ^ /Required/ "SharedSize"
  , imageSummaryVirtualSize :: !(Int) -- ^ /Required/ "VirtualSize"
  , imageSummaryLabels :: !((Map.Map String Text)) -- ^ /Required/ "Labels"
  , imageSummaryContainers :: !(Int) -- ^ /Required/ "Containers"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ImageSummary
instance A.FromJSON ImageSummary where
  parseJSON = A.withObject "ImageSummary" $ \o ->
    ImageSummary
      <$> (o .:  "Id")
      <*> (o .:  "ParentId")
      <*> (o .:  "RepoTags")
      <*> (o .:  "RepoDigests")
      <*> (o .:  "Created")
      <*> (o .:  "Size")
      <*> (o .:  "SharedSize")
      <*> (o .:  "VirtualSize")
      <*> (o .:  "Labels")
      <*> (o .:  "Containers")

-- | ToJSON ImageSummary
instance A.ToJSON ImageSummary where
  toJSON ImageSummary {..} =
   _omitNulls
      [ "Id" .= imageSummaryId
      , "ParentId" .= imageSummaryParentId
      , "RepoTags" .= imageSummaryRepoTags
      , "RepoDigests" .= imageSummaryRepoDigests
      , "Created" .= imageSummaryCreated
      , "Size" .= imageSummarySize
      , "SharedSize" .= imageSummarySharedSize
      , "VirtualSize" .= imageSummaryVirtualSize
      , "Labels" .= imageSummaryLabels
      , "Containers" .= imageSummaryContainers
      ]


-- | Construct a value of type 'ImageSummary' (by applying it's required fields, if any)
mkImageSummary
  :: Text -- ^ 'imageSummaryId' 
  -> Text -- ^ 'imageSummaryParentId' 
  -> [Text] -- ^ 'imageSummaryRepoTags' 
  -> [Text] -- ^ 'imageSummaryRepoDigests' 
  -> Int -- ^ 'imageSummaryCreated' 
  -> Int -- ^ 'imageSummarySize' 
  -> Int -- ^ 'imageSummarySharedSize' 
  -> Int -- ^ 'imageSummaryVirtualSize' 
  -> (Map.Map String Text) -- ^ 'imageSummaryLabels' 
  -> Int -- ^ 'imageSummaryContainers' 
  -> ImageSummary
mkImageSummary imageSummaryId imageSummaryParentId imageSummaryRepoTags imageSummaryRepoDigests imageSummaryCreated imageSummarySize imageSummarySharedSize imageSummaryVirtualSize imageSummaryLabels imageSummaryContainers =
  ImageSummary
  { imageSummaryId
  , imageSummaryParentId
  , imageSummaryRepoTags
  , imageSummaryRepoDigests
  , imageSummaryCreated
  , imageSummarySize
  , imageSummarySharedSize
  , imageSummaryVirtualSize
  , imageSummaryLabels
  , imageSummaryContainers
  }

-- ** IndexInfo
-- | IndexInfo
-- IndexInfo contains information about a registry.
data IndexInfo = IndexInfo
  { indexInfoName :: !(Maybe Text) -- ^ "Name" - Name of the registry, such as \&quot;docker.io\&quot;. 
  , indexInfoMirrors :: !(Maybe [Text]) -- ^ "Mirrors" - List of mirrors, expressed as URIs. 
  , indexInfoSecure :: !(Maybe Bool) -- ^ "Secure" - Indicates if the registry is part of the list of insecure registries.  If &#x60;false&#x60;, the registry is insecure. Insecure registries accept un-encrypted (HTTP) and/or untrusted (HTTPS with certificates from unknown CAs) communication.  &gt; **Warning**: Insecure registries can be useful when running a local &gt; registry. However, because its use creates security vulnerabilities &gt; it should ONLY be enabled for testing purposes. For increased &gt; security, users should add their CA to their system&#39;s list of &gt; trusted CAs instead of enabling this option. 
  , indexInfoOfficial :: !(Maybe Bool) -- ^ "Official" - Indicates whether this is an official registry (i.e., Docker Hub / docker.io) 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IndexInfo
instance A.FromJSON IndexInfo where
  parseJSON = A.withObject "IndexInfo" $ \o ->
    IndexInfo
      <$> (o .:? "Name")
      <*> (o .:? "Mirrors")
      <*> (o .:? "Secure")
      <*> (o .:? "Official")

-- | ToJSON IndexInfo
instance A.ToJSON IndexInfo where
  toJSON IndexInfo {..} =
   _omitNulls
      [ "Name" .= indexInfoName
      , "Mirrors" .= indexInfoMirrors
      , "Secure" .= indexInfoSecure
      , "Official" .= indexInfoOfficial
      ]


-- | Construct a value of type 'IndexInfo' (by applying it's required fields, if any)
mkIndexInfo
  :: IndexInfo
mkIndexInfo =
  IndexInfo
  { indexInfoName = Nothing
  , indexInfoMirrors = Nothing
  , indexInfoSecure = Nothing
  , indexInfoOfficial = Nothing
  }

-- ** JoinTokens
-- | JoinTokens
-- JoinTokens contains the tokens workers and managers need to join the swarm. 
data JoinTokens = JoinTokens
  { joinTokensWorker :: !(Maybe Text) -- ^ "Worker" - The token workers can use to join the swarm. 
  , joinTokensManager :: !(Maybe Text) -- ^ "Manager" - The token managers can use to join the swarm. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON JoinTokens
instance A.FromJSON JoinTokens where
  parseJSON = A.withObject "JoinTokens" $ \o ->
    JoinTokens
      <$> (o .:? "Worker")
      <*> (o .:? "Manager")

-- | ToJSON JoinTokens
instance A.ToJSON JoinTokens where
  toJSON JoinTokens {..} =
   _omitNulls
      [ "Worker" .= joinTokensWorker
      , "Manager" .= joinTokensManager
      ]


-- | Construct a value of type 'JoinTokens' (by applying it's required fields, if any)
mkJoinTokens
  :: JoinTokens
mkJoinTokens =
  JoinTokens
  { joinTokensWorker = Nothing
  , joinTokensManager = Nothing
  }

-- ** Limit
-- | Limit
-- An object describing a limit on resources which can be requested by a task. 
data Limit = Limit
  { limitNanoCpus :: !(Maybe Integer) -- ^ "NanoCPUs"
  , limitMemoryBytes :: !(Maybe Integer) -- ^ "MemoryBytes"
  , limitPids :: !(Maybe Integer) -- ^ "Pids" - Limits the maximum number of PIDs in the container. Set &#x60;0&#x60; for unlimited. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Limit
instance A.FromJSON Limit where
  parseJSON = A.withObject "Limit" $ \o ->
    Limit
      <$> (o .:? "NanoCPUs")
      <*> (o .:? "MemoryBytes")
      <*> (o .:? "Pids")

-- | ToJSON Limit
instance A.ToJSON Limit where
  toJSON Limit {..} =
   _omitNulls
      [ "NanoCPUs" .= limitNanoCpus
      , "MemoryBytes" .= limitMemoryBytes
      , "Pids" .= limitPids
      ]


-- | Construct a value of type 'Limit' (by applying it's required fields, if any)
mkLimit
  :: Limit
mkLimit =
  Limit
  { limitNanoCpus = Nothing
  , limitMemoryBytes = Nothing
  , limitPids = Nothing
  }

-- ** ManagerStatus
-- | ManagerStatus
-- ManagerStatus represents the status of a manager.  It provides the current status of a node's manager component, if the node is a manager. 
data ManagerStatus = ManagerStatus
  { managerStatusLeader :: !(Maybe Bool) -- ^ "Leader"
  , managerStatusReachability :: !(Maybe Reachability) -- ^ "Reachability"
  , managerStatusAddr :: !(Maybe Text) -- ^ "Addr" - The IP address and port at which the manager is reachable. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ManagerStatus
instance A.FromJSON ManagerStatus where
  parseJSON = A.withObject "ManagerStatus" $ \o ->
    ManagerStatus
      <$> (o .:? "Leader")
      <*> (o .:? "Reachability")
      <*> (o .:? "Addr")

-- | ToJSON ManagerStatus
instance A.ToJSON ManagerStatus where
  toJSON ManagerStatus {..} =
   _omitNulls
      [ "Leader" .= managerStatusLeader
      , "Reachability" .= managerStatusReachability
      , "Addr" .= managerStatusAddr
      ]


-- | Construct a value of type 'ManagerStatus' (by applying it's required fields, if any)
mkManagerStatus
  :: ManagerStatus
mkManagerStatus =
  ManagerStatus
  { managerStatusLeader = Nothing
  , managerStatusReachability = Nothing
  , managerStatusAddr = Nothing
  }

-- ** Mount
-- | Mount
data Mount = Mount
  { mountTarget :: !(Maybe Text) -- ^ "Target" - Container path.
  , mountSource :: !(Maybe Text) -- ^ "Source" - Mount source (e.g. a volume name, a host path).
  , mountType :: !(Maybe E'Type2) -- ^ "Type" - The mount type. Available types:  - &#x60;bind&#x60; Mounts a file or directory from the host into the container. Must exist prior to creating the container. - &#x60;volume&#x60; Creates a volume with the given name and options (or uses a pre-existing volume with the same name and options). These are **not** removed when the container is removed. - &#x60;tmpfs&#x60; Create a tmpfs with the given options. The mount source cannot be specified for tmpfs. - &#x60;npipe&#x60; Mounts a named pipe from the host into the container. Must exist prior to creating the container. 
  , mountReadOnly :: !(Maybe Bool) -- ^ "ReadOnly" - Whether the mount should be read-only.
  , mountConsistency :: !(Maybe Text) -- ^ "Consistency" - The consistency requirement for the mount: &#x60;default&#x60;, &#x60;consistent&#x60;, &#x60;cached&#x60;, or &#x60;delegated&#x60;.
  , mountBindOptions :: !(Maybe MountBindOptions) -- ^ "BindOptions"
  , mountVolumeOptions :: !(Maybe MountVolumeOptions) -- ^ "VolumeOptions"
  , mountTmpfsOptions :: !(Maybe MountTmpfsOptions) -- ^ "TmpfsOptions"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Mount
instance A.FromJSON Mount where
  parseJSON = A.withObject "Mount" $ \o ->
    Mount
      <$> (o .:? "Target")
      <*> (o .:? "Source")
      <*> (o .:? "Type")
      <*> (o .:? "ReadOnly")
      <*> (o .:? "Consistency")
      <*> (o .:? "BindOptions")
      <*> (o .:? "VolumeOptions")
      <*> (o .:? "TmpfsOptions")

-- | ToJSON Mount
instance A.ToJSON Mount where
  toJSON Mount {..} =
   _omitNulls
      [ "Target" .= mountTarget
      , "Source" .= mountSource
      , "Type" .= mountType
      , "ReadOnly" .= mountReadOnly
      , "Consistency" .= mountConsistency
      , "BindOptions" .= mountBindOptions
      , "VolumeOptions" .= mountVolumeOptions
      , "TmpfsOptions" .= mountTmpfsOptions
      ]


-- | Construct a value of type 'Mount' (by applying it's required fields, if any)
mkMount
  :: Mount
mkMount =
  Mount
  { mountTarget = Nothing
  , mountSource = Nothing
  , mountType = Nothing
  , mountReadOnly = Nothing
  , mountConsistency = Nothing
  , mountBindOptions = Nothing
  , mountVolumeOptions = Nothing
  , mountTmpfsOptions = Nothing
  }

-- ** MountBindOptions
-- | MountBindOptions
-- Optional configuration for the `bind` type.
data MountBindOptions = MountBindOptions
  { mountBindOptionsPropagation :: !(Maybe E'Propagation) -- ^ "Propagation" - A propagation mode with the value &#x60;[r]private&#x60;, &#x60;[r]shared&#x60;, or &#x60;[r]slave&#x60;.
  , mountBindOptionsNonRecursive :: !(Maybe Bool) -- ^ "NonRecursive" - Disable recursive bind mount.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MountBindOptions
instance A.FromJSON MountBindOptions where
  parseJSON = A.withObject "MountBindOptions" $ \o ->
    MountBindOptions
      <$> (o .:? "Propagation")
      <*> (o .:? "NonRecursive")

-- | ToJSON MountBindOptions
instance A.ToJSON MountBindOptions where
  toJSON MountBindOptions {..} =
   _omitNulls
      [ "Propagation" .= mountBindOptionsPropagation
      , "NonRecursive" .= mountBindOptionsNonRecursive
      ]


-- | Construct a value of type 'MountBindOptions' (by applying it's required fields, if any)
mkMountBindOptions
  :: MountBindOptions
mkMountBindOptions =
  MountBindOptions
  { mountBindOptionsPropagation = Nothing
  , mountBindOptionsNonRecursive = Nothing
  }

-- ** MountPoint
-- | MountPoint
-- MountPoint represents a mount point configuration inside the container. This is used for reporting the mountpoints in use by a container. 
data MountPoint = MountPoint
  { mountPointType :: !(Maybe E'Type2) -- ^ "Type" - The mount type:  - &#x60;bind&#x60; a mount of a file or directory from the host into the container. - &#x60;volume&#x60; a docker volume with the given &#x60;Name&#x60;. - &#x60;tmpfs&#x60; a &#x60;tmpfs&#x60;. - &#x60;npipe&#x60; a named pipe from the host into the container. 
  , mountPointName :: !(Maybe Text) -- ^ "Name" - Name is the name reference to the underlying data defined by &#x60;Source&#x60; e.g., the volume name. 
  , mountPointSource :: !(Maybe Text) -- ^ "Source" - Source location of the mount.  For volumes, this contains the storage location of the volume (within &#x60;/var/lib/docker/volumes/&#x60;). For bind-mounts, and &#x60;npipe&#x60;, this contains the source (host) part of the bind-mount. For &#x60;tmpfs&#x60; mount points, this field is empty. 
  , mountPointDestination :: !(Maybe Text) -- ^ "Destination" - Destination is the path relative to the container root (&#x60;/&#x60;) where the &#x60;Source&#x60; is mounted inside the container. 
  , mountPointDriver :: !(Maybe Text) -- ^ "Driver" - Driver is the volume driver used to create the volume (if it is a volume). 
  , mountPointMode :: !(Maybe Text) -- ^ "Mode" - Mode is a comma separated list of options supplied by the user when creating the bind/volume mount.  The default is platform-specific (&#x60;\&quot;z\&quot;&#x60; on Linux, empty on Windows). 
  , mountPointRw :: !(Maybe Bool) -- ^ "RW" - Whether the mount is mounted writable (read-write). 
  , mountPointPropagation :: !(Maybe Text) -- ^ "Propagation" - Propagation describes how mounts are propagated from the host into the mount point, and vice-versa. Refer to the [Linux kernel documentation](https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt) for details. This field is not used on Windows. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MountPoint
instance A.FromJSON MountPoint where
  parseJSON = A.withObject "MountPoint" $ \o ->
    MountPoint
      <$> (o .:? "Type")
      <*> (o .:? "Name")
      <*> (o .:? "Source")
      <*> (o .:? "Destination")
      <*> (o .:? "Driver")
      <*> (o .:? "Mode")
      <*> (o .:? "RW")
      <*> (o .:? "Propagation")

-- | ToJSON MountPoint
instance A.ToJSON MountPoint where
  toJSON MountPoint {..} =
   _omitNulls
      [ "Type" .= mountPointType
      , "Name" .= mountPointName
      , "Source" .= mountPointSource
      , "Destination" .= mountPointDestination
      , "Driver" .= mountPointDriver
      , "Mode" .= mountPointMode
      , "RW" .= mountPointRw
      , "Propagation" .= mountPointPropagation
      ]


-- | Construct a value of type 'MountPoint' (by applying it's required fields, if any)
mkMountPoint
  :: MountPoint
mkMountPoint =
  MountPoint
  { mountPointType = Nothing
  , mountPointName = Nothing
  , mountPointSource = Nothing
  , mountPointDestination = Nothing
  , mountPointDriver = Nothing
  , mountPointMode = Nothing
  , mountPointRw = Nothing
  , mountPointPropagation = Nothing
  }

-- ** MountTmpfsOptions
-- | MountTmpfsOptions
-- Optional configuration for the `tmpfs` type.
data MountTmpfsOptions = MountTmpfsOptions
  { mountTmpfsOptionsSizeBytes :: !(Maybe Integer) -- ^ "SizeBytes" - The size for the tmpfs mount in bytes.
  , mountTmpfsOptionsMode :: !(Maybe Int) -- ^ "Mode" - The permission mode for the tmpfs mount in an integer.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MountTmpfsOptions
instance A.FromJSON MountTmpfsOptions where
  parseJSON = A.withObject "MountTmpfsOptions" $ \o ->
    MountTmpfsOptions
      <$> (o .:? "SizeBytes")
      <*> (o .:? "Mode")

-- | ToJSON MountTmpfsOptions
instance A.ToJSON MountTmpfsOptions where
  toJSON MountTmpfsOptions {..} =
   _omitNulls
      [ "SizeBytes" .= mountTmpfsOptionsSizeBytes
      , "Mode" .= mountTmpfsOptionsMode
      ]


-- | Construct a value of type 'MountTmpfsOptions' (by applying it's required fields, if any)
mkMountTmpfsOptions
  :: MountTmpfsOptions
mkMountTmpfsOptions =
  MountTmpfsOptions
  { mountTmpfsOptionsSizeBytes = Nothing
  , mountTmpfsOptionsMode = Nothing
  }

-- ** MountVolumeOptions
-- | MountVolumeOptions
-- Optional configuration for the `volume` type.
data MountVolumeOptions = MountVolumeOptions
  { mountVolumeOptionsNoCopy :: !(Maybe Bool) -- ^ "NoCopy" - Populate volume with data from the target.
  , mountVolumeOptionsLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , mountVolumeOptionsDriverConfig :: !(Maybe MountVolumeOptionsDriverConfig) -- ^ "DriverConfig"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MountVolumeOptions
instance A.FromJSON MountVolumeOptions where
  parseJSON = A.withObject "MountVolumeOptions" $ \o ->
    MountVolumeOptions
      <$> (o .:? "NoCopy")
      <*> (o .:? "Labels")
      <*> (o .:? "DriverConfig")

-- | ToJSON MountVolumeOptions
instance A.ToJSON MountVolumeOptions where
  toJSON MountVolumeOptions {..} =
   _omitNulls
      [ "NoCopy" .= mountVolumeOptionsNoCopy
      , "Labels" .= mountVolumeOptionsLabels
      , "DriverConfig" .= mountVolumeOptionsDriverConfig
      ]


-- | Construct a value of type 'MountVolumeOptions' (by applying it's required fields, if any)
mkMountVolumeOptions
  :: MountVolumeOptions
mkMountVolumeOptions =
  MountVolumeOptions
  { mountVolumeOptionsNoCopy = Nothing
  , mountVolumeOptionsLabels = Nothing
  , mountVolumeOptionsDriverConfig = Nothing
  }

-- ** MountVolumeOptionsDriverConfig
-- | MountVolumeOptionsDriverConfig
-- Map of driver specific options
data MountVolumeOptionsDriverConfig = MountVolumeOptionsDriverConfig
  { mountVolumeOptionsDriverConfigName :: !(Maybe Text) -- ^ "Name" - Name of the driver to use to create the volume.
  , mountVolumeOptionsDriverConfigOptions :: !(Maybe (Map.Map String Text)) -- ^ "Options" - key/value map of driver specific options.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MountVolumeOptionsDriverConfig
instance A.FromJSON MountVolumeOptionsDriverConfig where
  parseJSON = A.withObject "MountVolumeOptionsDriverConfig" $ \o ->
    MountVolumeOptionsDriverConfig
      <$> (o .:? "Name")
      <*> (o .:? "Options")

-- | ToJSON MountVolumeOptionsDriverConfig
instance A.ToJSON MountVolumeOptionsDriverConfig where
  toJSON MountVolumeOptionsDriverConfig {..} =
   _omitNulls
      [ "Name" .= mountVolumeOptionsDriverConfigName
      , "Options" .= mountVolumeOptionsDriverConfigOptions
      ]


-- | Construct a value of type 'MountVolumeOptionsDriverConfig' (by applying it's required fields, if any)
mkMountVolumeOptionsDriverConfig
  :: MountVolumeOptionsDriverConfig
mkMountVolumeOptionsDriverConfig =
  MountVolumeOptionsDriverConfig
  { mountVolumeOptionsDriverConfigName = Nothing
  , mountVolumeOptionsDriverConfigOptions = Nothing
  }

-- ** Network
-- | Network
data Network = Network
  { networkName :: !(Maybe Text) -- ^ "Name"
  , networkId :: !(Maybe Text) -- ^ "Id"
  , networkCreated :: !(Maybe Text) -- ^ "Created"
  , networkScope :: !(Maybe Text) -- ^ "Scope"
  , networkDriver :: !(Maybe Text) -- ^ "Driver"
  , networkEnableIpv6 :: !(Maybe Bool) -- ^ "EnableIPv6"
  , networkIpam :: !(Maybe IPAM) -- ^ "IPAM"
  , networkInternal :: !(Maybe Bool) -- ^ "Internal"
  , networkAttachable :: !(Maybe Bool) -- ^ "Attachable"
  , networkIngress :: !(Maybe Bool) -- ^ "Ingress"
  , networkContainers :: !(Maybe (Map.Map String NetworkContainer)) -- ^ "Containers"
  , networkOptions :: !(Maybe (Map.Map String Text)) -- ^ "Options"
  , networkLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Network
instance A.FromJSON Network where
  parseJSON = A.withObject "Network" $ \o ->
    Network
      <$> (o .:? "Name")
      <*> (o .:? "Id")
      <*> (o .:? "Created")
      <*> (o .:? "Scope")
      <*> (o .:? "Driver")
      <*> (o .:? "EnableIPv6")
      <*> (o .:? "IPAM")
      <*> (o .:? "Internal")
      <*> (o .:? "Attachable")
      <*> (o .:? "Ingress")
      <*> (o .:? "Containers")
      <*> (o .:? "Options")
      <*> (o .:? "Labels")

-- | ToJSON Network
instance A.ToJSON Network where
  toJSON Network {..} =
   _omitNulls
      [ "Name" .= networkName
      , "Id" .= networkId
      , "Created" .= networkCreated
      , "Scope" .= networkScope
      , "Driver" .= networkDriver
      , "EnableIPv6" .= networkEnableIpv6
      , "IPAM" .= networkIpam
      , "Internal" .= networkInternal
      , "Attachable" .= networkAttachable
      , "Ingress" .= networkIngress
      , "Containers" .= networkContainers
      , "Options" .= networkOptions
      , "Labels" .= networkLabels
      ]


-- | Construct a value of type 'Network' (by applying it's required fields, if any)
mkNetwork
  :: Network
mkNetwork =
  Network
  { networkName = Nothing
  , networkId = Nothing
  , networkCreated = Nothing
  , networkScope = Nothing
  , networkDriver = Nothing
  , networkEnableIpv6 = Nothing
  , networkIpam = Nothing
  , networkInternal = Nothing
  , networkAttachable = Nothing
  , networkIngress = Nothing
  , networkContainers = Nothing
  , networkOptions = Nothing
  , networkLabels = Nothing
  }

-- ** NetworkAttachmentConfig
-- | NetworkAttachmentConfig
-- Specifies how a service should be attached to a particular network. 
data NetworkAttachmentConfig = NetworkAttachmentConfig
  { networkAttachmentConfigTarget :: !(Maybe Text) -- ^ "Target" - The target network for attachment. Must be a network name or ID. 
  , networkAttachmentConfigAliases :: !(Maybe [Text]) -- ^ "Aliases" - Discoverable alternate names for the service on this network. 
  , networkAttachmentConfigDriverOpts :: !(Maybe (Map.Map String Text)) -- ^ "DriverOpts" - Driver attachment options for the network target. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NetworkAttachmentConfig
instance A.FromJSON NetworkAttachmentConfig where
  parseJSON = A.withObject "NetworkAttachmentConfig" $ \o ->
    NetworkAttachmentConfig
      <$> (o .:? "Target")
      <*> (o .:? "Aliases")
      <*> (o .:? "DriverOpts")

-- | ToJSON NetworkAttachmentConfig
instance A.ToJSON NetworkAttachmentConfig where
  toJSON NetworkAttachmentConfig {..} =
   _omitNulls
      [ "Target" .= networkAttachmentConfigTarget
      , "Aliases" .= networkAttachmentConfigAliases
      , "DriverOpts" .= networkAttachmentConfigDriverOpts
      ]


-- | Construct a value of type 'NetworkAttachmentConfig' (by applying it's required fields, if any)
mkNetworkAttachmentConfig
  :: NetworkAttachmentConfig
mkNetworkAttachmentConfig =
  NetworkAttachmentConfig
  { networkAttachmentConfigTarget = Nothing
  , networkAttachmentConfigAliases = Nothing
  , networkAttachmentConfigDriverOpts = Nothing
  }

-- ** NetworkConnectRequest
-- | NetworkConnectRequest
-- NetworkConnectRequest
-- 
data NetworkConnectRequest = NetworkConnectRequest
  { networkConnectRequestContainer :: !(Maybe Text) -- ^ "Container" - The ID or name of the container to disconnect from the network. 
  , networkConnectRequestForce :: !(Maybe Bool) -- ^ "Force" - Force the container to disconnect from the network. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NetworkConnectRequest
instance A.FromJSON NetworkConnectRequest where
  parseJSON = A.withObject "NetworkConnectRequest" $ \o ->
    NetworkConnectRequest
      <$> (o .:? "Container")
      <*> (o .:? "Force")

-- | ToJSON NetworkConnectRequest
instance A.ToJSON NetworkConnectRequest where
  toJSON NetworkConnectRequest {..} =
   _omitNulls
      [ "Container" .= networkConnectRequestContainer
      , "Force" .= networkConnectRequestForce
      ]


-- | Construct a value of type 'NetworkConnectRequest' (by applying it's required fields, if any)
mkNetworkConnectRequest
  :: NetworkConnectRequest
mkNetworkConnectRequest =
  NetworkConnectRequest
  { networkConnectRequestContainer = Nothing
  , networkConnectRequestForce = Nothing
  }

-- ** NetworkContainer
-- | NetworkContainer
data NetworkContainer = NetworkContainer
  { networkContainerName :: !(Maybe Text) -- ^ "Name"
  , networkContainerEndpointId :: !(Maybe Text) -- ^ "EndpointID"
  , networkContainerMacAddress :: !(Maybe Text) -- ^ "MacAddress"
  , networkContainerIpv4Address :: !(Maybe Text) -- ^ "IPv4Address"
  , networkContainerIpv6Address :: !(Maybe Text) -- ^ "IPv6Address"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NetworkContainer
instance A.FromJSON NetworkContainer where
  parseJSON = A.withObject "NetworkContainer" $ \o ->
    NetworkContainer
      <$> (o .:? "Name")
      <*> (o .:? "EndpointID")
      <*> (o .:? "MacAddress")
      <*> (o .:? "IPv4Address")
      <*> (o .:? "IPv6Address")

-- | ToJSON NetworkContainer
instance A.ToJSON NetworkContainer where
  toJSON NetworkContainer {..} =
   _omitNulls
      [ "Name" .= networkContainerName
      , "EndpointID" .= networkContainerEndpointId
      , "MacAddress" .= networkContainerMacAddress
      , "IPv4Address" .= networkContainerIpv4Address
      , "IPv6Address" .= networkContainerIpv6Address
      ]


-- | Construct a value of type 'NetworkContainer' (by applying it's required fields, if any)
mkNetworkContainer
  :: NetworkContainer
mkNetworkContainer =
  NetworkContainer
  { networkContainerName = Nothing
  , networkContainerEndpointId = Nothing
  , networkContainerMacAddress = Nothing
  , networkContainerIpv4Address = Nothing
  , networkContainerIpv6Address = Nothing
  }

-- ** NetworkCreateRequest
-- | NetworkCreateRequest
-- NetworkCreateRequest
-- 
data NetworkCreateRequest = NetworkCreateRequest
  { networkCreateRequestName :: !(Text) -- ^ /Required/ "Name" - The network&#39;s name.
  , networkCreateRequestCheckDuplicate :: !(Maybe Bool) -- ^ "CheckDuplicate" - Check for networks with duplicate names. Since Network is primarily keyed based on a random ID and not on the name, and network name is strictly a user-friendly alias to the network which is uniquely identified using ID, there is no guaranteed way to check for duplicates. CheckDuplicate is there to provide a best effort checking of any networks which has the same name but it is not guaranteed to catch all name collisions. 
  , networkCreateRequestDriver :: !(Maybe Text) -- ^ "Driver" - Name of the network driver plugin to use.
  , networkCreateRequestInternal :: !(Maybe Bool) -- ^ "Internal" - Restrict external access to the network.
  , networkCreateRequestAttachable :: !(Maybe Bool) -- ^ "Attachable" - Globally scoped network is manually attachable by regular containers from workers in swarm mode. 
  , networkCreateRequestIngress :: !(Maybe Bool) -- ^ "Ingress" - Ingress network is the network which provides the routing-mesh in swarm mode. 
  , networkCreateRequestIpam :: !(Maybe IPAM) -- ^ "IPAM"
  , networkCreateRequestEnableIpv6 :: !(Maybe Bool) -- ^ "EnableIPv6" - Enable IPv6 on the network.
  , networkCreateRequestOptions :: !(Maybe (Map.Map String Text)) -- ^ "Options" - Network specific options to be used by the drivers.
  , networkCreateRequestLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NetworkCreateRequest
instance A.FromJSON NetworkCreateRequest where
  parseJSON = A.withObject "NetworkCreateRequest" $ \o ->
    NetworkCreateRequest
      <$> (o .:  "Name")
      <*> (o .:? "CheckDuplicate")
      <*> (o .:? "Driver")
      <*> (o .:? "Internal")
      <*> (o .:? "Attachable")
      <*> (o .:? "Ingress")
      <*> (o .:? "IPAM")
      <*> (o .:? "EnableIPv6")
      <*> (o .:? "Options")
      <*> (o .:? "Labels")

-- | ToJSON NetworkCreateRequest
instance A.ToJSON NetworkCreateRequest where
  toJSON NetworkCreateRequest {..} =
   _omitNulls
      [ "Name" .= networkCreateRequestName
      , "CheckDuplicate" .= networkCreateRequestCheckDuplicate
      , "Driver" .= networkCreateRequestDriver
      , "Internal" .= networkCreateRequestInternal
      , "Attachable" .= networkCreateRequestAttachable
      , "Ingress" .= networkCreateRequestIngress
      , "IPAM" .= networkCreateRequestIpam
      , "EnableIPv6" .= networkCreateRequestEnableIpv6
      , "Options" .= networkCreateRequestOptions
      , "Labels" .= networkCreateRequestLabels
      ]


-- | Construct a value of type 'NetworkCreateRequest' (by applying it's required fields, if any)
mkNetworkCreateRequest
  :: Text -- ^ 'networkCreateRequestName': The network's name.
  -> NetworkCreateRequest
mkNetworkCreateRequest networkCreateRequestName =
  NetworkCreateRequest
  { networkCreateRequestName
  , networkCreateRequestCheckDuplicate = Nothing
  , networkCreateRequestDriver = Nothing
  , networkCreateRequestInternal = Nothing
  , networkCreateRequestAttachable = Nothing
  , networkCreateRequestIngress = Nothing
  , networkCreateRequestIpam = Nothing
  , networkCreateRequestEnableIpv6 = Nothing
  , networkCreateRequestOptions = Nothing
  , networkCreateRequestLabels = Nothing
  }

-- ** NetworkCreateResponse
-- | NetworkCreateResponse
-- NetworkCreateResponse
-- 
data NetworkCreateResponse = NetworkCreateResponse
  { networkCreateResponseId :: !(Maybe Text) -- ^ "Id" - The ID of the created network.
  , networkCreateResponseWarning :: !(Maybe Text) -- ^ "Warning"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NetworkCreateResponse
instance A.FromJSON NetworkCreateResponse where
  parseJSON = A.withObject "NetworkCreateResponse" $ \o ->
    NetworkCreateResponse
      <$> (o .:? "Id")
      <*> (o .:? "Warning")

-- | ToJSON NetworkCreateResponse
instance A.ToJSON NetworkCreateResponse where
  toJSON NetworkCreateResponse {..} =
   _omitNulls
      [ "Id" .= networkCreateResponseId
      , "Warning" .= networkCreateResponseWarning
      ]


-- | Construct a value of type 'NetworkCreateResponse' (by applying it's required fields, if any)
mkNetworkCreateResponse
  :: NetworkCreateResponse
mkNetworkCreateResponse =
  NetworkCreateResponse
  { networkCreateResponseId = Nothing
  , networkCreateResponseWarning = Nothing
  }

-- ** NetworkDisconnectRequest
-- | NetworkDisconnectRequest
-- NetworkDisconnectRequest
-- 
data NetworkDisconnectRequest = NetworkDisconnectRequest
  { networkDisconnectRequestContainer :: !(Maybe Text) -- ^ "Container" - The ID or name of the container to connect to the network.
  , networkDisconnectRequestEndpointConfig :: !(Maybe EndpointSettings) -- ^ "EndpointConfig"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NetworkDisconnectRequest
instance A.FromJSON NetworkDisconnectRequest where
  parseJSON = A.withObject "NetworkDisconnectRequest" $ \o ->
    NetworkDisconnectRequest
      <$> (o .:? "Container")
      <*> (o .:? "EndpointConfig")

-- | ToJSON NetworkDisconnectRequest
instance A.ToJSON NetworkDisconnectRequest where
  toJSON NetworkDisconnectRequest {..} =
   _omitNulls
      [ "Container" .= networkDisconnectRequestContainer
      , "EndpointConfig" .= networkDisconnectRequestEndpointConfig
      ]


-- | Construct a value of type 'NetworkDisconnectRequest' (by applying it's required fields, if any)
mkNetworkDisconnectRequest
  :: NetworkDisconnectRequest
mkNetworkDisconnectRequest =
  NetworkDisconnectRequest
  { networkDisconnectRequestContainer = Nothing
  , networkDisconnectRequestEndpointConfig = Nothing
  }

-- ** NetworkPruneResponse
-- | NetworkPruneResponse
-- NetworkPruneResponse
-- 
data NetworkPruneResponse = NetworkPruneResponse
  { networkPruneResponseNetworksDeleted :: !(Maybe [Text]) -- ^ "NetworksDeleted" - Networks that were deleted
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NetworkPruneResponse
instance A.FromJSON NetworkPruneResponse where
  parseJSON = A.withObject "NetworkPruneResponse" $ \o ->
    NetworkPruneResponse
      <$> (o .:? "NetworksDeleted")

-- | ToJSON NetworkPruneResponse
instance A.ToJSON NetworkPruneResponse where
  toJSON NetworkPruneResponse {..} =
   _omitNulls
      [ "NetworksDeleted" .= networkPruneResponseNetworksDeleted
      ]


-- | Construct a value of type 'NetworkPruneResponse' (by applying it's required fields, if any)
mkNetworkPruneResponse
  :: NetworkPruneResponse
mkNetworkPruneResponse =
  NetworkPruneResponse
  { networkPruneResponseNetworksDeleted = Nothing
  }

-- ** NetworkSettings
-- | NetworkSettings
-- NetworkSettings exposes the network settings in the API
data NetworkSettings = NetworkSettings
  { networkSettingsBridge :: !(Maybe Text) -- ^ "Bridge" - Name of the network&#39;a bridge (for example, &#x60;docker0&#x60;).
  , networkSettingsSandboxId :: !(Maybe Text) -- ^ "SandboxID" - SandboxID uniquely represents a container&#39;s network stack.
  , networkSettingsHairpinMode :: !(Maybe Bool) -- ^ "HairpinMode" - Indicates if hairpin NAT should be enabled on the virtual interface. 
  , networkSettingsLinkLocalIpv6Address :: !(Maybe Text) -- ^ "LinkLocalIPv6Address" - IPv6 unicast address using the link-local prefix.
  , networkSettingsLinkLocalIpv6PrefixLen :: !(Maybe Int) -- ^ "LinkLocalIPv6PrefixLen" - Prefix length of the IPv6 unicast address.
  , networkSettingsPorts :: !(Maybe (Map.Map String [PortBinding])) -- ^ "Ports" - PortMap describes the mapping of container ports to host ports, using the container&#39;s port-number and protocol as key in the format &#x60;&lt;port&gt;/&lt;protocol&gt;&#x60;, for example, &#x60;80/udp&#x60;.  If a container&#39;s port is mapped for multiple protocols, separate entries are added to the mapping table. 
  , networkSettingsSandboxKey :: !(Maybe Text) -- ^ "SandboxKey" - SandboxKey identifies the sandbox
  , networkSettingsSecondaryIpAddresses :: !(Maybe [Address]) -- ^ "SecondaryIPAddresses" - 
  , networkSettingsSecondaryIpv6Addresses :: !(Maybe [Address]) -- ^ "SecondaryIPv6Addresses" - 
  , networkSettingsEndpointId :: !(Maybe Text) -- ^ "EndpointID" - EndpointID uniquely represents a service endpoint in a Sandbox.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Deprecated**: This field is only propagated when attached to the &gt; default \&quot;bridge\&quot; network. Use the information from the \&quot;bridge\&quot; &gt; network inside the &#x60;Networks&#x60; map instead, which contains the same &gt; information. This field was deprecated in Docker 1.9 and is scheduled &gt; to be removed in Docker 17.12.0 
  , networkSettingsGateway :: !(Maybe Text) -- ^ "Gateway" - Gateway address for the default \&quot;bridge\&quot; network.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Deprecated**: This field is only propagated when attached to the &gt; default \&quot;bridge\&quot; network. Use the information from the \&quot;bridge\&quot; &gt; network inside the &#x60;Networks&#x60; map instead, which contains the same &gt; information. This field was deprecated in Docker 1.9 and is scheduled &gt; to be removed in Docker 17.12.0 
  , networkSettingsGlobalIpv6Address :: !(Maybe Text) -- ^ "GlobalIPv6Address" - Global IPv6 address for the default \&quot;bridge\&quot; network.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Deprecated**: This field is only propagated when attached to the &gt; default \&quot;bridge\&quot; network. Use the information from the \&quot;bridge\&quot; &gt; network inside the &#x60;Networks&#x60; map instead, which contains the same &gt; information. This field was deprecated in Docker 1.9 and is scheduled &gt; to be removed in Docker 17.12.0 
  , networkSettingsGlobalIpv6PrefixLen :: !(Maybe Int) -- ^ "GlobalIPv6PrefixLen" - Mask length of the global IPv6 address.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Deprecated**: This field is only propagated when attached to the &gt; default \&quot;bridge\&quot; network. Use the information from the \&quot;bridge\&quot; &gt; network inside the &#x60;Networks&#x60; map instead, which contains the same &gt; information. This field was deprecated in Docker 1.9 and is scheduled &gt; to be removed in Docker 17.12.0 
  , networkSettingsIpAddress :: !(Maybe Text) -- ^ "IPAddress" - IPv4 address for the default \&quot;bridge\&quot; network.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Deprecated**: This field is only propagated when attached to the &gt; default \&quot;bridge\&quot; network. Use the information from the \&quot;bridge\&quot; &gt; network inside the &#x60;Networks&#x60; map instead, which contains the same &gt; information. This field was deprecated in Docker 1.9 and is scheduled &gt; to be removed in Docker 17.12.0 
  , networkSettingsIpPrefixLen :: !(Maybe Int) -- ^ "IPPrefixLen" - Mask length of the IPv4 address.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Deprecated**: This field is only propagated when attached to the &gt; default \&quot;bridge\&quot; network. Use the information from the \&quot;bridge\&quot; &gt; network inside the &#x60;Networks&#x60; map instead, which contains the same &gt; information. This field was deprecated in Docker 1.9 and is scheduled &gt; to be removed in Docker 17.12.0 
  , networkSettingsIpv6Gateway :: !(Maybe Text) -- ^ "IPv6Gateway" - IPv6 gateway address for this network.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Deprecated**: This field is only propagated when attached to the &gt; default \&quot;bridge\&quot; network. Use the information from the \&quot;bridge\&quot; &gt; network inside the &#x60;Networks&#x60; map instead, which contains the same &gt; information. This field was deprecated in Docker 1.9 and is scheduled &gt; to be removed in Docker 17.12.0 
  , networkSettingsMacAddress :: !(Maybe Text) -- ^ "MacAddress" - MAC address for the container on the default \&quot;bridge\&quot; network.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Deprecated**: This field is only propagated when attached to the &gt; default \&quot;bridge\&quot; network. Use the information from the \&quot;bridge\&quot; &gt; network inside the &#x60;Networks&#x60; map instead, which contains the same &gt; information. This field was deprecated in Docker 1.9 and is scheduled &gt; to be removed in Docker 17.12.0 
  , networkSettingsNetworks :: !(Maybe (Map.Map String EndpointSettings)) -- ^ "Networks" - Information about all networks that the container is connected to. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NetworkSettings
instance A.FromJSON NetworkSettings where
  parseJSON = A.withObject "NetworkSettings" $ \o ->
    NetworkSettings
      <$> (o .:? "Bridge")
      <*> (o .:? "SandboxID")
      <*> (o .:? "HairpinMode")
      <*> (o .:? "LinkLocalIPv6Address")
      <*> (o .:? "LinkLocalIPv6PrefixLen")
      <*> (o .:? "Ports")
      <*> (o .:? "SandboxKey")
      <*> (o .:? "SecondaryIPAddresses")
      <*> (o .:? "SecondaryIPv6Addresses")
      <*> (o .:? "EndpointID")
      <*> (o .:? "Gateway")
      <*> (o .:? "GlobalIPv6Address")
      <*> (o .:? "GlobalIPv6PrefixLen")
      <*> (o .:? "IPAddress")
      <*> (o .:? "IPPrefixLen")
      <*> (o .:? "IPv6Gateway")
      <*> (o .:? "MacAddress")
      <*> (o .:? "Networks")

-- | ToJSON NetworkSettings
instance A.ToJSON NetworkSettings where
  toJSON NetworkSettings {..} =
   _omitNulls
      [ "Bridge" .= networkSettingsBridge
      , "SandboxID" .= networkSettingsSandboxId
      , "HairpinMode" .= networkSettingsHairpinMode
      , "LinkLocalIPv6Address" .= networkSettingsLinkLocalIpv6Address
      , "LinkLocalIPv6PrefixLen" .= networkSettingsLinkLocalIpv6PrefixLen
      , "Ports" .= networkSettingsPorts
      , "SandboxKey" .= networkSettingsSandboxKey
      , "SecondaryIPAddresses" .= networkSettingsSecondaryIpAddresses
      , "SecondaryIPv6Addresses" .= networkSettingsSecondaryIpv6Addresses
      , "EndpointID" .= networkSettingsEndpointId
      , "Gateway" .= networkSettingsGateway
      , "GlobalIPv6Address" .= networkSettingsGlobalIpv6Address
      , "GlobalIPv6PrefixLen" .= networkSettingsGlobalIpv6PrefixLen
      , "IPAddress" .= networkSettingsIpAddress
      , "IPPrefixLen" .= networkSettingsIpPrefixLen
      , "IPv6Gateway" .= networkSettingsIpv6Gateway
      , "MacAddress" .= networkSettingsMacAddress
      , "Networks" .= networkSettingsNetworks
      ]


-- | Construct a value of type 'NetworkSettings' (by applying it's required fields, if any)
mkNetworkSettings
  :: NetworkSettings
mkNetworkSettings =
  NetworkSettings
  { networkSettingsBridge = Nothing
  , networkSettingsSandboxId = Nothing
  , networkSettingsHairpinMode = Nothing
  , networkSettingsLinkLocalIpv6Address = Nothing
  , networkSettingsLinkLocalIpv6PrefixLen = Nothing
  , networkSettingsPorts = Nothing
  , networkSettingsSandboxKey = Nothing
  , networkSettingsSecondaryIpAddresses = Nothing
  , networkSettingsSecondaryIpv6Addresses = Nothing
  , networkSettingsEndpointId = Nothing
  , networkSettingsGateway = Nothing
  , networkSettingsGlobalIpv6Address = Nothing
  , networkSettingsGlobalIpv6PrefixLen = Nothing
  , networkSettingsIpAddress = Nothing
  , networkSettingsIpPrefixLen = Nothing
  , networkSettingsIpv6Gateway = Nothing
  , networkSettingsMacAddress = Nothing
  , networkSettingsNetworks = Nothing
  }

-- ** NetworkingConfig
-- | NetworkingConfig
-- NetworkingConfig represents the container's networking configuration for each of its interfaces. It is used for the networking configs specified in the `docker create` and `docker network connect` commands. 
data NetworkingConfig = NetworkingConfig
  { networkingConfigEndpointsConfig :: !(Maybe (Map.Map String EndpointSettings)) -- ^ "EndpointsConfig" - A mapping of network name to endpoint configuration for that network. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NetworkingConfig
instance A.FromJSON NetworkingConfig where
  parseJSON = A.withObject "NetworkingConfig" $ \o ->
    NetworkingConfig
      <$> (o .:? "EndpointsConfig")

-- | ToJSON NetworkingConfig
instance A.ToJSON NetworkingConfig where
  toJSON NetworkingConfig {..} =
   _omitNulls
      [ "EndpointsConfig" .= networkingConfigEndpointsConfig
      ]


-- | Construct a value of type 'NetworkingConfig' (by applying it's required fields, if any)
mkNetworkingConfig
  :: NetworkingConfig
mkNetworkingConfig =
  NetworkingConfig
  { networkingConfigEndpointsConfig = Nothing
  }

-- ** Node
-- | Node
data Node = Node
  { nodeId :: !(Maybe Text) -- ^ "ID"
  , nodeVersion :: !(Maybe ObjectVersion) -- ^ "Version"
  , nodeCreatedAt :: !(Maybe Text) -- ^ "CreatedAt" - Date and time at which the node was added to the swarm in [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds. 
  , nodeUpdatedAt :: !(Maybe Text) -- ^ "UpdatedAt" - Date and time at which the node was last updated in [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds. 
  , nodeSpec :: !(Maybe NodeSpec) -- ^ "Spec"
  , nodeDescription :: !(Maybe NodeDescription) -- ^ "Description"
  , nodeStatus :: !(Maybe NodeStatus) -- ^ "Status"
  , nodeManagerStatus :: !(Maybe ManagerStatus) -- ^ "ManagerStatus"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Node
instance A.FromJSON Node where
  parseJSON = A.withObject "Node" $ \o ->
    Node
      <$> (o .:? "ID")
      <*> (o .:? "Version")
      <*> (o .:? "CreatedAt")
      <*> (o .:? "UpdatedAt")
      <*> (o .:? "Spec")
      <*> (o .:? "Description")
      <*> (o .:? "Status")
      <*> (o .:? "ManagerStatus")

-- | ToJSON Node
instance A.ToJSON Node where
  toJSON Node {..} =
   _omitNulls
      [ "ID" .= nodeId
      , "Version" .= nodeVersion
      , "CreatedAt" .= nodeCreatedAt
      , "UpdatedAt" .= nodeUpdatedAt
      , "Spec" .= nodeSpec
      , "Description" .= nodeDescription
      , "Status" .= nodeStatus
      , "ManagerStatus" .= nodeManagerStatus
      ]


-- | Construct a value of type 'Node' (by applying it's required fields, if any)
mkNode
  :: Node
mkNode =
  Node
  { nodeId = Nothing
  , nodeVersion = Nothing
  , nodeCreatedAt = Nothing
  , nodeUpdatedAt = Nothing
  , nodeSpec = Nothing
  , nodeDescription = Nothing
  , nodeStatus = Nothing
  , nodeManagerStatus = Nothing
  }

-- ** NodeDescription
-- | NodeDescription
-- NodeDescription encapsulates the properties of the Node as reported by the agent. 
data NodeDescription = NodeDescription
  { nodeDescriptionHostname :: !(Maybe Text) -- ^ "Hostname"
  , nodeDescriptionPlatform :: !(Maybe Platform) -- ^ "Platform"
  , nodeDescriptionResources :: !(Maybe ResourceObject) -- ^ "Resources"
  , nodeDescriptionEngine :: !(Maybe EngineDescription) -- ^ "Engine"
  , nodeDescriptionTlsInfo :: !(Maybe TLSInfo) -- ^ "TLSInfo"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NodeDescription
instance A.FromJSON NodeDescription where
  parseJSON = A.withObject "NodeDescription" $ \o ->
    NodeDescription
      <$> (o .:? "Hostname")
      <*> (o .:? "Platform")
      <*> (o .:? "Resources")
      <*> (o .:? "Engine")
      <*> (o .:? "TLSInfo")

-- | ToJSON NodeDescription
instance A.ToJSON NodeDescription where
  toJSON NodeDescription {..} =
   _omitNulls
      [ "Hostname" .= nodeDescriptionHostname
      , "Platform" .= nodeDescriptionPlatform
      , "Resources" .= nodeDescriptionResources
      , "Engine" .= nodeDescriptionEngine
      , "TLSInfo" .= nodeDescriptionTlsInfo
      ]


-- | Construct a value of type 'NodeDescription' (by applying it's required fields, if any)
mkNodeDescription
  :: NodeDescription
mkNodeDescription =
  NodeDescription
  { nodeDescriptionHostname = Nothing
  , nodeDescriptionPlatform = Nothing
  , nodeDescriptionResources = Nothing
  , nodeDescriptionEngine = Nothing
  , nodeDescriptionTlsInfo = Nothing
  }

-- ** NodeSpec
-- | NodeSpec
data NodeSpec = NodeSpec
  { nodeSpecName :: !(Maybe Text) -- ^ "Name" - Name for the node.
  , nodeSpecLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , nodeSpecRole :: !(Maybe E'Role) -- ^ "Role" - Role of the node.
  , nodeSpecAvailability :: !(Maybe E'Availability) -- ^ "Availability" - Availability of the node.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NodeSpec
instance A.FromJSON NodeSpec where
  parseJSON = A.withObject "NodeSpec" $ \o ->
    NodeSpec
      <$> (o .:? "Name")
      <*> (o .:? "Labels")
      <*> (o .:? "Role")
      <*> (o .:? "Availability")

-- | ToJSON NodeSpec
instance A.ToJSON NodeSpec where
  toJSON NodeSpec {..} =
   _omitNulls
      [ "Name" .= nodeSpecName
      , "Labels" .= nodeSpecLabels
      , "Role" .= nodeSpecRole
      , "Availability" .= nodeSpecAvailability
      ]


-- | Construct a value of type 'NodeSpec' (by applying it's required fields, if any)
mkNodeSpec
  :: NodeSpec
mkNodeSpec =
  NodeSpec
  { nodeSpecName = Nothing
  , nodeSpecLabels = Nothing
  , nodeSpecRole = Nothing
  , nodeSpecAvailability = Nothing
  }

-- ** NodeStatus
-- | NodeStatus
-- NodeStatus represents the status of a node.  It provides the current status of the node, as seen by the manager. 
data NodeStatus = NodeStatus
  { nodeStatusState :: !(Maybe NodeState) -- ^ "State"
  , nodeStatusMessage :: !(Maybe Text) -- ^ "Message"
  , nodeStatusAddr :: !(Maybe Text) -- ^ "Addr" - IP address of the node.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NodeStatus
instance A.FromJSON NodeStatus where
  parseJSON = A.withObject "NodeStatus" $ \o ->
    NodeStatus
      <$> (o .:? "State")
      <*> (o .:? "Message")
      <*> (o .:? "Addr")

-- | ToJSON NodeStatus
instance A.ToJSON NodeStatus where
  toJSON NodeStatus {..} =
   _omitNulls
      [ "State" .= nodeStatusState
      , "Message" .= nodeStatusMessage
      , "Addr" .= nodeStatusAddr
      ]


-- | Construct a value of type 'NodeStatus' (by applying it's required fields, if any)
mkNodeStatus
  :: NodeStatus
mkNodeStatus =
  NodeStatus
  { nodeStatusState = Nothing
  , nodeStatusMessage = Nothing
  , nodeStatusAddr = Nothing
  }

-- ** OCIDescriptor
-- | OCIDescriptor
-- A descriptor struct containing digest, media type, and size, as defined in the [OCI Content Descriptors Specification](https://github.com/opencontainers/image-spec/blob/v1.0.1/descriptor.md). 
data OCIDescriptor = OCIDescriptor
  { oCIDescriptorMediaType :: !(Maybe Text) -- ^ "mediaType" - The media type of the object this schema refers to. 
  , oCIDescriptorDigest :: !(Maybe Text) -- ^ "digest" - The digest of the targeted content. 
  , oCIDescriptorSize :: !(Maybe Integer) -- ^ "size" - The size in bytes of the blob. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OCIDescriptor
instance A.FromJSON OCIDescriptor where
  parseJSON = A.withObject "OCIDescriptor" $ \o ->
    OCIDescriptor
      <$> (o .:? "mediaType")
      <*> (o .:? "digest")
      <*> (o .:? "size")

-- | ToJSON OCIDescriptor
instance A.ToJSON OCIDescriptor where
  toJSON OCIDescriptor {..} =
   _omitNulls
      [ "mediaType" .= oCIDescriptorMediaType
      , "digest" .= oCIDescriptorDigest
      , "size" .= oCIDescriptorSize
      ]


-- | Construct a value of type 'OCIDescriptor' (by applying it's required fields, if any)
mkOCIDescriptor
  :: OCIDescriptor
mkOCIDescriptor =
  OCIDescriptor
  { oCIDescriptorMediaType = Nothing
  , oCIDescriptorDigest = Nothing
  , oCIDescriptorSize = Nothing
  }

-- ** OCIPlatform
-- | OCIPlatform
-- Describes the platform which the image in the manifest runs on, as defined in the [OCI Image Index Specification](https://github.com/opencontainers/image-spec/blob/v1.0.1/image-index.md). 
data OCIPlatform = OCIPlatform
  { oCIPlatformArchitecture :: !(Maybe Text) -- ^ "architecture" - The CPU architecture, for example &#x60;amd64&#x60; or &#x60;ppc64&#x60;. 
  , oCIPlatformOs :: !(Maybe Text) -- ^ "os" - The operating system, for example &#x60;linux&#x60; or &#x60;windows&#x60;. 
  , oCIPlatformOsVersion :: !(Maybe Text) -- ^ "os.version" - Optional field specifying the operating system version, for example on Windows &#x60;10.0.19041.1165&#x60;. 
  , oCIPlatformOsFeatures :: !(Maybe [Text]) -- ^ "os.features" - Optional field specifying an array of strings, each listing a required OS feature (for example on Windows &#x60;win32k&#x60;). 
  , oCIPlatformVariant :: !(Maybe Text) -- ^ "variant" - Optional field specifying a variant of the CPU, for example &#x60;v7&#x60; to specify ARMv7 when architecture is &#x60;arm&#x60;. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OCIPlatform
instance A.FromJSON OCIPlatform where
  parseJSON = A.withObject "OCIPlatform" $ \o ->
    OCIPlatform
      <$> (o .:? "architecture")
      <*> (o .:? "os")
      <*> (o .:? "os.version")
      <*> (o .:? "os.features")
      <*> (o .:? "variant")

-- | ToJSON OCIPlatform
instance A.ToJSON OCIPlatform where
  toJSON OCIPlatform {..} =
   _omitNulls
      [ "architecture" .= oCIPlatformArchitecture
      , "os" .= oCIPlatformOs
      , "os.version" .= oCIPlatformOsVersion
      , "os.features" .= oCIPlatformOsFeatures
      , "variant" .= oCIPlatformVariant
      ]


-- | Construct a value of type 'OCIPlatform' (by applying it's required fields, if any)
mkOCIPlatform
  :: OCIPlatform
mkOCIPlatform =
  OCIPlatform
  { oCIPlatformArchitecture = Nothing
  , oCIPlatformOs = Nothing
  , oCIPlatformOsVersion = Nothing
  , oCIPlatformOsFeatures = Nothing
  , oCIPlatformVariant = Nothing
  }

-- ** ObjectVersion
-- | ObjectVersion
-- The version number of the object such as node, service, etc. This is needed to avoid conflicting writes. The client must send the version number along with the modified specification when updating these objects.  This approach ensures safe concurrency and determinism in that the change on the object may not be applied if the version number has changed from the last read. In other words, if two update requests specify the same base version, only one of the requests can succeed. As a result, two separate update requests that happen at the same time will not unintentionally overwrite each other. 
data ObjectVersion = ObjectVersion
  { objectVersionIndex :: !(Maybe Int) -- ^ "Index"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ObjectVersion
instance A.FromJSON ObjectVersion where
  parseJSON = A.withObject "ObjectVersion" $ \o ->
    ObjectVersion
      <$> (o .:? "Index")

-- | ToJSON ObjectVersion
instance A.ToJSON ObjectVersion where
  toJSON ObjectVersion {..} =
   _omitNulls
      [ "Index" .= objectVersionIndex
      ]


-- | Construct a value of type 'ObjectVersion' (by applying it's required fields, if any)
mkObjectVersion
  :: ObjectVersion
mkObjectVersion =
  ObjectVersion
  { objectVersionIndex = Nothing
  }

-- ** PeerNode
-- | PeerNode
-- Represents a peer-node in the swarm
data PeerNode = PeerNode
  { peerNodeNodeId :: !(Maybe Text) -- ^ "NodeID" - Unique identifier of for this node in the swarm.
  , peerNodeAddr :: !(Maybe Text) -- ^ "Addr" - IP address and ports at which this node can be reached. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PeerNode
instance A.FromJSON PeerNode where
  parseJSON = A.withObject "PeerNode" $ \o ->
    PeerNode
      <$> (o .:? "NodeID")
      <*> (o .:? "Addr")

-- | ToJSON PeerNode
instance A.ToJSON PeerNode where
  toJSON PeerNode {..} =
   _omitNulls
      [ "NodeID" .= peerNodeNodeId
      , "Addr" .= peerNodeAddr
      ]


-- | Construct a value of type 'PeerNode' (by applying it's required fields, if any)
mkPeerNode
  :: PeerNode
mkPeerNode =
  PeerNode
  { peerNodeNodeId = Nothing
  , peerNodeAddr = Nothing
  }

-- ** Platform
-- | Platform
-- Platform represents the platform (Arch/OS). 
data Platform = Platform
  { platformArchitecture :: !(Maybe Text) -- ^ "Architecture" - Architecture represents the hardware architecture (for example, &#x60;x86_64&#x60;). 
  , platformOs :: !(Maybe Text) -- ^ "OS" - OS represents the Operating System (for example, &#x60;linux&#x60; or &#x60;windows&#x60;). 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Platform
instance A.FromJSON Platform where
  parseJSON = A.withObject "Platform" $ \o ->
    Platform
      <$> (o .:? "Architecture")
      <*> (o .:? "OS")

-- | ToJSON Platform
instance A.ToJSON Platform where
  toJSON Platform {..} =
   _omitNulls
      [ "Architecture" .= platformArchitecture
      , "OS" .= platformOs
      ]


-- | Construct a value of type 'Platform' (by applying it's required fields, if any)
mkPlatform
  :: Platform
mkPlatform =
  Platform
  { platformArchitecture = Nothing
  , platformOs = Nothing
  }

-- ** Plugin
-- | Plugin
-- A plugin for the Engine API
data Plugin = Plugin
  { pluginId :: !(Maybe Text) -- ^ "Id"
  , pluginName :: !(Text) -- ^ /Required/ "Name"
  , pluginEnabled :: !(Bool) -- ^ /Required/ "Enabled" - True if the plugin is running. False if the plugin is not running, only installed.
  , pluginSettings :: !(PluginSettings) -- ^ /Required/ "Settings"
  , pluginPluginReference :: !(Maybe Text) -- ^ "PluginReference" - plugin remote reference used to push/pull the plugin
  , pluginConfig :: !(PluginConfig) -- ^ /Required/ "Config"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Plugin
instance A.FromJSON Plugin where
  parseJSON = A.withObject "Plugin" $ \o ->
    Plugin
      <$> (o .:? "Id")
      <*> (o .:  "Name")
      <*> (o .:  "Enabled")
      <*> (o .:  "Settings")
      <*> (o .:? "PluginReference")
      <*> (o .:  "Config")

-- | ToJSON Plugin
instance A.ToJSON Plugin where
  toJSON Plugin {..} =
   _omitNulls
      [ "Id" .= pluginId
      , "Name" .= pluginName
      , "Enabled" .= pluginEnabled
      , "Settings" .= pluginSettings
      , "PluginReference" .= pluginPluginReference
      , "Config" .= pluginConfig
      ]


-- | Construct a value of type 'Plugin' (by applying it's required fields, if any)
mkPlugin
  :: Text -- ^ 'pluginName' 
  -> Bool -- ^ 'pluginEnabled': True if the plugin is running. False if the plugin is not running, only installed.
  -> PluginSettings -- ^ 'pluginSettings' 
  -> PluginConfig -- ^ 'pluginConfig' 
  -> Plugin
mkPlugin pluginName pluginEnabled pluginSettings pluginConfig =
  Plugin
  { pluginId = Nothing
  , pluginName
  , pluginEnabled
  , pluginSettings
  , pluginPluginReference = Nothing
  , pluginConfig
  }

-- ** PluginConfig
-- | PluginConfig
-- The config of a plugin.
data PluginConfig = PluginConfig
  { pluginConfigDockerVersion :: !(Maybe Text) -- ^ "DockerVersion" - Docker Version used to create the plugin
  , pluginConfigDescription :: !(Text) -- ^ /Required/ "Description"
  , pluginConfigDocumentation :: !(Text) -- ^ /Required/ "Documentation"
  , pluginConfigInterface :: !(PluginConfigInterface) -- ^ /Required/ "Interface"
  , pluginConfigEntrypoint :: !([Text]) -- ^ /Required/ "Entrypoint"
  , pluginConfigWorkDir :: !(Text) -- ^ /Required/ "WorkDir"
  , pluginConfigUser :: !(Maybe PluginConfigUser) -- ^ "User"
  , pluginConfigNetwork :: !(PluginConfigNetwork) -- ^ /Required/ "Network"
  , pluginConfigLinux :: !(PluginConfigLinux) -- ^ /Required/ "Linux"
  , pluginConfigPropagatedMount :: !(Text) -- ^ /Required/ "PropagatedMount"
  , pluginConfigIpcHost :: !(Bool) -- ^ /Required/ "IpcHost"
  , pluginConfigPidHost :: !(Bool) -- ^ /Required/ "PidHost"
  , pluginConfigMounts :: !([PluginMount]) -- ^ /Required/ "Mounts"
  , pluginConfigEnv :: !([PluginEnv]) -- ^ /Required/ "Env"
  , pluginConfigArgs :: !(PluginConfigArgs) -- ^ /Required/ "Args"
  , pluginConfigRootfs :: !(Maybe PluginConfigRootfs) -- ^ "rootfs"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginConfig
instance A.FromJSON PluginConfig where
  parseJSON = A.withObject "PluginConfig" $ \o ->
    PluginConfig
      <$> (o .:? "DockerVersion")
      <*> (o .:  "Description")
      <*> (o .:  "Documentation")
      <*> (o .:  "Interface")
      <*> (o .:  "Entrypoint")
      <*> (o .:  "WorkDir")
      <*> (o .:? "User")
      <*> (o .:  "Network")
      <*> (o .:  "Linux")
      <*> (o .:  "PropagatedMount")
      <*> (o .:  "IpcHost")
      <*> (o .:  "PidHost")
      <*> (o .:  "Mounts")
      <*> (o .:  "Env")
      <*> (o .:  "Args")
      <*> (o .:? "rootfs")

-- | ToJSON PluginConfig
instance A.ToJSON PluginConfig where
  toJSON PluginConfig {..} =
   _omitNulls
      [ "DockerVersion" .= pluginConfigDockerVersion
      , "Description" .= pluginConfigDescription
      , "Documentation" .= pluginConfigDocumentation
      , "Interface" .= pluginConfigInterface
      , "Entrypoint" .= pluginConfigEntrypoint
      , "WorkDir" .= pluginConfigWorkDir
      , "User" .= pluginConfigUser
      , "Network" .= pluginConfigNetwork
      , "Linux" .= pluginConfigLinux
      , "PropagatedMount" .= pluginConfigPropagatedMount
      , "IpcHost" .= pluginConfigIpcHost
      , "PidHost" .= pluginConfigPidHost
      , "Mounts" .= pluginConfigMounts
      , "Env" .= pluginConfigEnv
      , "Args" .= pluginConfigArgs
      , "rootfs" .= pluginConfigRootfs
      ]


-- | Construct a value of type 'PluginConfig' (by applying it's required fields, if any)
mkPluginConfig
  :: Text -- ^ 'pluginConfigDescription' 
  -> Text -- ^ 'pluginConfigDocumentation' 
  -> PluginConfigInterface -- ^ 'pluginConfigInterface' 
  -> [Text] -- ^ 'pluginConfigEntrypoint' 
  -> Text -- ^ 'pluginConfigWorkDir' 
  -> PluginConfigNetwork -- ^ 'pluginConfigNetwork' 
  -> PluginConfigLinux -- ^ 'pluginConfigLinux' 
  -> Text -- ^ 'pluginConfigPropagatedMount' 
  -> Bool -- ^ 'pluginConfigIpcHost' 
  -> Bool -- ^ 'pluginConfigPidHost' 
  -> [PluginMount] -- ^ 'pluginConfigMounts' 
  -> [PluginEnv] -- ^ 'pluginConfigEnv' 
  -> PluginConfigArgs -- ^ 'pluginConfigArgs' 
  -> PluginConfig
mkPluginConfig pluginConfigDescription pluginConfigDocumentation pluginConfigInterface pluginConfigEntrypoint pluginConfigWorkDir pluginConfigNetwork pluginConfigLinux pluginConfigPropagatedMount pluginConfigIpcHost pluginConfigPidHost pluginConfigMounts pluginConfigEnv pluginConfigArgs =
  PluginConfig
  { pluginConfigDockerVersion = Nothing
  , pluginConfigDescription
  , pluginConfigDocumentation
  , pluginConfigInterface
  , pluginConfigEntrypoint
  , pluginConfigWorkDir
  , pluginConfigUser = Nothing
  , pluginConfigNetwork
  , pluginConfigLinux
  , pluginConfigPropagatedMount
  , pluginConfigIpcHost
  , pluginConfigPidHost
  , pluginConfigMounts
  , pluginConfigEnv
  , pluginConfigArgs
  , pluginConfigRootfs = Nothing
  }

-- ** PluginConfigArgs
-- | PluginConfigArgs
data PluginConfigArgs = PluginConfigArgs
  { pluginConfigArgsName :: !(Text) -- ^ /Required/ "Name"
  , pluginConfigArgsDescription :: !(Text) -- ^ /Required/ "Description"
  , pluginConfigArgsSettable :: !([Text]) -- ^ /Required/ "Settable"
  , pluginConfigArgsValue :: !([Text]) -- ^ /Required/ "Value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginConfigArgs
instance A.FromJSON PluginConfigArgs where
  parseJSON = A.withObject "PluginConfigArgs" $ \o ->
    PluginConfigArgs
      <$> (o .:  "Name")
      <*> (o .:  "Description")
      <*> (o .:  "Settable")
      <*> (o .:  "Value")

-- | ToJSON PluginConfigArgs
instance A.ToJSON PluginConfigArgs where
  toJSON PluginConfigArgs {..} =
   _omitNulls
      [ "Name" .= pluginConfigArgsName
      , "Description" .= pluginConfigArgsDescription
      , "Settable" .= pluginConfigArgsSettable
      , "Value" .= pluginConfigArgsValue
      ]


-- | Construct a value of type 'PluginConfigArgs' (by applying it's required fields, if any)
mkPluginConfigArgs
  :: Text -- ^ 'pluginConfigArgsName' 
  -> Text -- ^ 'pluginConfigArgsDescription' 
  -> [Text] -- ^ 'pluginConfigArgsSettable' 
  -> [Text] -- ^ 'pluginConfigArgsValue' 
  -> PluginConfigArgs
mkPluginConfigArgs pluginConfigArgsName pluginConfigArgsDescription pluginConfigArgsSettable pluginConfigArgsValue =
  PluginConfigArgs
  { pluginConfigArgsName
  , pluginConfigArgsDescription
  , pluginConfigArgsSettable
  , pluginConfigArgsValue
  }

-- ** PluginConfigInterface
-- | PluginConfigInterface
-- The interface between Docker and the plugin
data PluginConfigInterface = PluginConfigInterface
  { pluginConfigInterfaceTypes :: !([PluginInterfaceType]) -- ^ /Required/ "Types"
  , pluginConfigInterfaceSocket :: !(Text) -- ^ /Required/ "Socket"
  , pluginConfigInterfaceProtocolScheme :: !(Maybe E'ProtocolScheme) -- ^ "ProtocolScheme" - Protocol to use for clients connecting to the plugin.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginConfigInterface
instance A.FromJSON PluginConfigInterface where
  parseJSON = A.withObject "PluginConfigInterface" $ \o ->
    PluginConfigInterface
      <$> (o .:  "Types")
      <*> (o .:  "Socket")
      <*> (o .:? "ProtocolScheme")

-- | ToJSON PluginConfigInterface
instance A.ToJSON PluginConfigInterface where
  toJSON PluginConfigInterface {..} =
   _omitNulls
      [ "Types" .= pluginConfigInterfaceTypes
      , "Socket" .= pluginConfigInterfaceSocket
      , "ProtocolScheme" .= pluginConfigInterfaceProtocolScheme
      ]


-- | Construct a value of type 'PluginConfigInterface' (by applying it's required fields, if any)
mkPluginConfigInterface
  :: [PluginInterfaceType] -- ^ 'pluginConfigInterfaceTypes' 
  -> Text -- ^ 'pluginConfigInterfaceSocket' 
  -> PluginConfigInterface
mkPluginConfigInterface pluginConfigInterfaceTypes pluginConfigInterfaceSocket =
  PluginConfigInterface
  { pluginConfigInterfaceTypes
  , pluginConfigInterfaceSocket
  , pluginConfigInterfaceProtocolScheme = Nothing
  }

-- ** PluginConfigLinux
-- | PluginConfigLinux
data PluginConfigLinux = PluginConfigLinux
  { pluginConfigLinuxCapabilities :: !([Text]) -- ^ /Required/ "Capabilities"
  , pluginConfigLinuxAllowAllDevices :: !(Bool) -- ^ /Required/ "AllowAllDevices"
  , pluginConfigLinuxDevices :: !([PluginDevice]) -- ^ /Required/ "Devices"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginConfigLinux
instance A.FromJSON PluginConfigLinux where
  parseJSON = A.withObject "PluginConfigLinux" $ \o ->
    PluginConfigLinux
      <$> (o .:  "Capabilities")
      <*> (o .:  "AllowAllDevices")
      <*> (o .:  "Devices")

-- | ToJSON PluginConfigLinux
instance A.ToJSON PluginConfigLinux where
  toJSON PluginConfigLinux {..} =
   _omitNulls
      [ "Capabilities" .= pluginConfigLinuxCapabilities
      , "AllowAllDevices" .= pluginConfigLinuxAllowAllDevices
      , "Devices" .= pluginConfigLinuxDevices
      ]


-- | Construct a value of type 'PluginConfigLinux' (by applying it's required fields, if any)
mkPluginConfigLinux
  :: [Text] -- ^ 'pluginConfigLinuxCapabilities' 
  -> Bool -- ^ 'pluginConfigLinuxAllowAllDevices' 
  -> [PluginDevice] -- ^ 'pluginConfigLinuxDevices' 
  -> PluginConfigLinux
mkPluginConfigLinux pluginConfigLinuxCapabilities pluginConfigLinuxAllowAllDevices pluginConfigLinuxDevices =
  PluginConfigLinux
  { pluginConfigLinuxCapabilities
  , pluginConfigLinuxAllowAllDevices
  , pluginConfigLinuxDevices
  }

-- ** PluginConfigNetwork
-- | PluginConfigNetwork
data PluginConfigNetwork = PluginConfigNetwork
  { pluginConfigNetworkType :: !(Text) -- ^ /Required/ "Type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginConfigNetwork
instance A.FromJSON PluginConfigNetwork where
  parseJSON = A.withObject "PluginConfigNetwork" $ \o ->
    PluginConfigNetwork
      <$> (o .:  "Type")

-- | ToJSON PluginConfigNetwork
instance A.ToJSON PluginConfigNetwork where
  toJSON PluginConfigNetwork {..} =
   _omitNulls
      [ "Type" .= pluginConfigNetworkType
      ]


-- | Construct a value of type 'PluginConfigNetwork' (by applying it's required fields, if any)
mkPluginConfigNetwork
  :: Text -- ^ 'pluginConfigNetworkType' 
  -> PluginConfigNetwork
mkPluginConfigNetwork pluginConfigNetworkType =
  PluginConfigNetwork
  { pluginConfigNetworkType
  }

-- ** PluginConfigRootfs
-- | PluginConfigRootfs
data PluginConfigRootfs = PluginConfigRootfs
  { pluginConfigRootfsType :: !(Maybe Text) -- ^ "type"
  , pluginConfigRootfsDiffIds :: !(Maybe [Text]) -- ^ "diff_ids"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginConfigRootfs
instance A.FromJSON PluginConfigRootfs where
  parseJSON = A.withObject "PluginConfigRootfs" $ \o ->
    PluginConfigRootfs
      <$> (o .:? "type")
      <*> (o .:? "diff_ids")

-- | ToJSON PluginConfigRootfs
instance A.ToJSON PluginConfigRootfs where
  toJSON PluginConfigRootfs {..} =
   _omitNulls
      [ "type" .= pluginConfigRootfsType
      , "diff_ids" .= pluginConfigRootfsDiffIds
      ]


-- | Construct a value of type 'PluginConfigRootfs' (by applying it's required fields, if any)
mkPluginConfigRootfs
  :: PluginConfigRootfs
mkPluginConfigRootfs =
  PluginConfigRootfs
  { pluginConfigRootfsType = Nothing
  , pluginConfigRootfsDiffIds = Nothing
  }

-- ** PluginConfigUser
-- | PluginConfigUser
data PluginConfigUser = PluginConfigUser
  { pluginConfigUserUid :: !(Maybe Int) -- ^ "UID"
  , pluginConfigUserGid :: !(Maybe Int) -- ^ "GID"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginConfigUser
instance A.FromJSON PluginConfigUser where
  parseJSON = A.withObject "PluginConfigUser" $ \o ->
    PluginConfigUser
      <$> (o .:? "UID")
      <*> (o .:? "GID")

-- | ToJSON PluginConfigUser
instance A.ToJSON PluginConfigUser where
  toJSON PluginConfigUser {..} =
   _omitNulls
      [ "UID" .= pluginConfigUserUid
      , "GID" .= pluginConfigUserGid
      ]


-- | Construct a value of type 'PluginConfigUser' (by applying it's required fields, if any)
mkPluginConfigUser
  :: PluginConfigUser
mkPluginConfigUser =
  PluginConfigUser
  { pluginConfigUserUid = Nothing
  , pluginConfigUserGid = Nothing
  }

-- ** PluginDevice
-- | PluginDevice
data PluginDevice = PluginDevice
  { pluginDeviceName :: !(Text) -- ^ /Required/ "Name"
  , pluginDeviceDescription :: !(Text) -- ^ /Required/ "Description"
  , pluginDeviceSettable :: !([Text]) -- ^ /Required/ "Settable"
  , pluginDevicePath :: !(Text) -- ^ /Required/ "Path"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginDevice
instance A.FromJSON PluginDevice where
  parseJSON = A.withObject "PluginDevice" $ \o ->
    PluginDevice
      <$> (o .:  "Name")
      <*> (o .:  "Description")
      <*> (o .:  "Settable")
      <*> (o .:  "Path")

-- | ToJSON PluginDevice
instance A.ToJSON PluginDevice where
  toJSON PluginDevice {..} =
   _omitNulls
      [ "Name" .= pluginDeviceName
      , "Description" .= pluginDeviceDescription
      , "Settable" .= pluginDeviceSettable
      , "Path" .= pluginDevicePath
      ]


-- | Construct a value of type 'PluginDevice' (by applying it's required fields, if any)
mkPluginDevice
  :: Text -- ^ 'pluginDeviceName' 
  -> Text -- ^ 'pluginDeviceDescription' 
  -> [Text] -- ^ 'pluginDeviceSettable' 
  -> Text -- ^ 'pluginDevicePath' 
  -> PluginDevice
mkPluginDevice pluginDeviceName pluginDeviceDescription pluginDeviceSettable pluginDevicePath =
  PluginDevice
  { pluginDeviceName
  , pluginDeviceDescription
  , pluginDeviceSettable
  , pluginDevicePath
  }

-- ** PluginEnv
-- | PluginEnv
data PluginEnv = PluginEnv
  { pluginEnvName :: !(Text) -- ^ /Required/ "Name"
  , pluginEnvDescription :: !(Text) -- ^ /Required/ "Description"
  , pluginEnvSettable :: !([Text]) -- ^ /Required/ "Settable"
  , pluginEnvValue :: !(Text) -- ^ /Required/ "Value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginEnv
instance A.FromJSON PluginEnv where
  parseJSON = A.withObject "PluginEnv" $ \o ->
    PluginEnv
      <$> (o .:  "Name")
      <*> (o .:  "Description")
      <*> (o .:  "Settable")
      <*> (o .:  "Value")

-- | ToJSON PluginEnv
instance A.ToJSON PluginEnv where
  toJSON PluginEnv {..} =
   _omitNulls
      [ "Name" .= pluginEnvName
      , "Description" .= pluginEnvDescription
      , "Settable" .= pluginEnvSettable
      , "Value" .= pluginEnvValue
      ]


-- | Construct a value of type 'PluginEnv' (by applying it's required fields, if any)
mkPluginEnv
  :: Text -- ^ 'pluginEnvName' 
  -> Text -- ^ 'pluginEnvDescription' 
  -> [Text] -- ^ 'pluginEnvSettable' 
  -> Text -- ^ 'pluginEnvValue' 
  -> PluginEnv
mkPluginEnv pluginEnvName pluginEnvDescription pluginEnvSettable pluginEnvValue =
  PluginEnv
  { pluginEnvName
  , pluginEnvDescription
  , pluginEnvSettable
  , pluginEnvValue
  }

-- ** PluginInterfaceType
-- | PluginInterfaceType
data PluginInterfaceType = PluginInterfaceType
  { pluginInterfaceTypePrefix :: !(Text) -- ^ /Required/ "Prefix"
  , pluginInterfaceTypeCapability :: !(Text) -- ^ /Required/ "Capability"
  , pluginInterfaceTypeVersion :: !(Text) -- ^ /Required/ "Version"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginInterfaceType
instance A.FromJSON PluginInterfaceType where
  parseJSON = A.withObject "PluginInterfaceType" $ \o ->
    PluginInterfaceType
      <$> (o .:  "Prefix")
      <*> (o .:  "Capability")
      <*> (o .:  "Version")

-- | ToJSON PluginInterfaceType
instance A.ToJSON PluginInterfaceType where
  toJSON PluginInterfaceType {..} =
   _omitNulls
      [ "Prefix" .= pluginInterfaceTypePrefix
      , "Capability" .= pluginInterfaceTypeCapability
      , "Version" .= pluginInterfaceTypeVersion
      ]


-- | Construct a value of type 'PluginInterfaceType' (by applying it's required fields, if any)
mkPluginInterfaceType
  :: Text -- ^ 'pluginInterfaceTypePrefix' 
  -> Text -- ^ 'pluginInterfaceTypeCapability' 
  -> Text -- ^ 'pluginInterfaceTypeVersion' 
  -> PluginInterfaceType
mkPluginInterfaceType pluginInterfaceTypePrefix pluginInterfaceTypeCapability pluginInterfaceTypeVersion =
  PluginInterfaceType
  { pluginInterfaceTypePrefix
  , pluginInterfaceTypeCapability
  , pluginInterfaceTypeVersion
  }

-- ** PluginMount
-- | PluginMount
data PluginMount = PluginMount
  { pluginMountName :: !(Text) -- ^ /Required/ "Name"
  , pluginMountDescription :: !(Text) -- ^ /Required/ "Description"
  , pluginMountSettable :: !([Text]) -- ^ /Required/ "Settable"
  , pluginMountSource :: !(Text) -- ^ /Required/ "Source"
  , pluginMountDestination :: !(Text) -- ^ /Required/ "Destination"
  , pluginMountType :: !(Text) -- ^ /Required/ "Type"
  , pluginMountOptions :: !([Text]) -- ^ /Required/ "Options"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginMount
instance A.FromJSON PluginMount where
  parseJSON = A.withObject "PluginMount" $ \o ->
    PluginMount
      <$> (o .:  "Name")
      <*> (o .:  "Description")
      <*> (o .:  "Settable")
      <*> (o .:  "Source")
      <*> (o .:  "Destination")
      <*> (o .:  "Type")
      <*> (o .:  "Options")

-- | ToJSON PluginMount
instance A.ToJSON PluginMount where
  toJSON PluginMount {..} =
   _omitNulls
      [ "Name" .= pluginMountName
      , "Description" .= pluginMountDescription
      , "Settable" .= pluginMountSettable
      , "Source" .= pluginMountSource
      , "Destination" .= pluginMountDestination
      , "Type" .= pluginMountType
      , "Options" .= pluginMountOptions
      ]


-- | Construct a value of type 'PluginMount' (by applying it's required fields, if any)
mkPluginMount
  :: Text -- ^ 'pluginMountName' 
  -> Text -- ^ 'pluginMountDescription' 
  -> [Text] -- ^ 'pluginMountSettable' 
  -> Text -- ^ 'pluginMountSource' 
  -> Text -- ^ 'pluginMountDestination' 
  -> Text -- ^ 'pluginMountType' 
  -> [Text] -- ^ 'pluginMountOptions' 
  -> PluginMount
mkPluginMount pluginMountName pluginMountDescription pluginMountSettable pluginMountSource pluginMountDestination pluginMountType pluginMountOptions =
  PluginMount
  { pluginMountName
  , pluginMountDescription
  , pluginMountSettable
  , pluginMountSource
  , pluginMountDestination
  , pluginMountType
  , pluginMountOptions
  }

-- ** PluginPrivilege
-- | PluginPrivilege
-- Describes a permission the user has to accept upon installing the plugin. 
data PluginPrivilege = PluginPrivilege
  { pluginPrivilegeName :: !(Maybe Text) -- ^ "Name"
  , pluginPrivilegeDescription :: !(Maybe Text) -- ^ "Description"
  , pluginPrivilegeValue :: !(Maybe [Text]) -- ^ "Value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginPrivilege
instance A.FromJSON PluginPrivilege where
  parseJSON = A.withObject "PluginPrivilege" $ \o ->
    PluginPrivilege
      <$> (o .:? "Name")
      <*> (o .:? "Description")
      <*> (o .:? "Value")

-- | ToJSON PluginPrivilege
instance A.ToJSON PluginPrivilege where
  toJSON PluginPrivilege {..} =
   _omitNulls
      [ "Name" .= pluginPrivilegeName
      , "Description" .= pluginPrivilegeDescription
      , "Value" .= pluginPrivilegeValue
      ]


-- | Construct a value of type 'PluginPrivilege' (by applying it's required fields, if any)
mkPluginPrivilege
  :: PluginPrivilege
mkPluginPrivilege =
  PluginPrivilege
  { pluginPrivilegeName = Nothing
  , pluginPrivilegeDescription = Nothing
  , pluginPrivilegeValue = Nothing
  }

-- ** PluginSettings
-- | PluginSettings
-- Settings that can be modified by users.
data PluginSettings = PluginSettings
  { pluginSettingsMounts :: !([PluginMount]) -- ^ /Required/ "Mounts"
  , pluginSettingsEnv :: !([Text]) -- ^ /Required/ "Env"
  , pluginSettingsArgs :: !([Text]) -- ^ /Required/ "Args"
  , pluginSettingsDevices :: !([PluginDevice]) -- ^ /Required/ "Devices"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginSettings
instance A.FromJSON PluginSettings where
  parseJSON = A.withObject "PluginSettings" $ \o ->
    PluginSettings
      <$> (o .:  "Mounts")
      <*> (o .:  "Env")
      <*> (o .:  "Args")
      <*> (o .:  "Devices")

-- | ToJSON PluginSettings
instance A.ToJSON PluginSettings where
  toJSON PluginSettings {..} =
   _omitNulls
      [ "Mounts" .= pluginSettingsMounts
      , "Env" .= pluginSettingsEnv
      , "Args" .= pluginSettingsArgs
      , "Devices" .= pluginSettingsDevices
      ]


-- | Construct a value of type 'PluginSettings' (by applying it's required fields, if any)
mkPluginSettings
  :: [PluginMount] -- ^ 'pluginSettingsMounts' 
  -> [Text] -- ^ 'pluginSettingsEnv' 
  -> [Text] -- ^ 'pluginSettingsArgs' 
  -> [PluginDevice] -- ^ 'pluginSettingsDevices' 
  -> PluginSettings
mkPluginSettings pluginSettingsMounts pluginSettingsEnv pluginSettingsArgs pluginSettingsDevices =
  PluginSettings
  { pluginSettingsMounts
  , pluginSettingsEnv
  , pluginSettingsArgs
  , pluginSettingsDevices
  }

-- ** PluginsInfo
-- | PluginsInfo
-- Available plugins per type.  <p><br /></p>  > **Note**: Only unmanaged (V1) plugins are included in this list. > V1 plugins are \"lazily\" loaded, and are not returned in this list > if there is no resource using the plugin. 
data PluginsInfo = PluginsInfo
  { pluginsInfoVolume :: !(Maybe [Text]) -- ^ "Volume" - Names of available volume-drivers, and network-driver plugins.
  , pluginsInfoNetwork :: !(Maybe [Text]) -- ^ "Network" - Names of available network-drivers, and network-driver plugins.
  , pluginsInfoAuthorization :: !(Maybe [Text]) -- ^ "Authorization" - Names of available authorization plugins.
  , pluginsInfoLog :: !(Maybe [Text]) -- ^ "Log" - Names of available logging-drivers, and logging-driver plugins.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PluginsInfo
instance A.FromJSON PluginsInfo where
  parseJSON = A.withObject "PluginsInfo" $ \o ->
    PluginsInfo
      <$> (o .:? "Volume")
      <*> (o .:? "Network")
      <*> (o .:? "Authorization")
      <*> (o .:? "Log")

-- | ToJSON PluginsInfo
instance A.ToJSON PluginsInfo where
  toJSON PluginsInfo {..} =
   _omitNulls
      [ "Volume" .= pluginsInfoVolume
      , "Network" .= pluginsInfoNetwork
      , "Authorization" .= pluginsInfoAuthorization
      , "Log" .= pluginsInfoLog
      ]


-- | Construct a value of type 'PluginsInfo' (by applying it's required fields, if any)
mkPluginsInfo
  :: PluginsInfo
mkPluginsInfo =
  PluginsInfo
  { pluginsInfoVolume = Nothing
  , pluginsInfoNetwork = Nothing
  , pluginsInfoAuthorization = Nothing
  , pluginsInfoLog = Nothing
  }

-- ** Port
-- | Port
-- An open port on a container
data Port = Port
  { portIp :: !(Maybe Text) -- ^ "IP" - Host IP address that the container&#39;s port is mapped to
  , portPrivatePort :: !(Int) -- ^ /Required/ "PrivatePort" - Port on the container
  , portPublicPort :: !(Maybe Int) -- ^ "PublicPort" - Port exposed on the host
  , portType :: !(E'Type) -- ^ /Required/ "Type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Port
instance A.FromJSON Port where
  parseJSON = A.withObject "Port" $ \o ->
    Port
      <$> (o .:? "IP")
      <*> (o .:  "PrivatePort")
      <*> (o .:? "PublicPort")
      <*> (o .:  "Type")

-- | ToJSON Port
instance A.ToJSON Port where
  toJSON Port {..} =
   _omitNulls
      [ "IP" .= portIp
      , "PrivatePort" .= portPrivatePort
      , "PublicPort" .= portPublicPort
      , "Type" .= portType
      ]


-- | Construct a value of type 'Port' (by applying it's required fields, if any)
mkPort
  :: Int -- ^ 'portPrivatePort': Port on the container
  -> E'Type -- ^ 'portType' 
  -> Port
mkPort portPrivatePort portType =
  Port
  { portIp = Nothing
  , portPrivatePort
  , portPublicPort = Nothing
  , portType
  }

-- ** PortBinding
-- | PortBinding
-- PortBinding represents a binding between a host IP address and a host port. 
data PortBinding = PortBinding
  { portBindingHostIp :: !(Maybe Text) -- ^ "HostIp" - Host IP address that the container&#39;s port is mapped to.
  , portBindingHostPort :: !(Maybe Text) -- ^ "HostPort" - Host port number that the container&#39;s port is mapped to.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PortBinding
instance A.FromJSON PortBinding where
  parseJSON = A.withObject "PortBinding" $ \o ->
    PortBinding
      <$> (o .:? "HostIp")
      <*> (o .:? "HostPort")

-- | ToJSON PortBinding
instance A.ToJSON PortBinding where
  toJSON PortBinding {..} =
   _omitNulls
      [ "HostIp" .= portBindingHostIp
      , "HostPort" .= portBindingHostPort
      ]


-- | Construct a value of type 'PortBinding' (by applying it's required fields, if any)
mkPortBinding
  :: PortBinding
mkPortBinding =
  PortBinding
  { portBindingHostIp = Nothing
  , portBindingHostPort = Nothing
  }

-- ** ProcessConfig
-- | ProcessConfig
data ProcessConfig = ProcessConfig
  { processConfigPrivileged :: !(Maybe Bool) -- ^ "privileged"
  , processConfigUser :: !(Maybe Text) -- ^ "user"
  , processConfigTty :: !(Maybe Bool) -- ^ "tty"
  , processConfigEntrypoint :: !(Maybe Text) -- ^ "entrypoint"
  , processConfigArguments :: !(Maybe [Text]) -- ^ "arguments"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProcessConfig
instance A.FromJSON ProcessConfig where
  parseJSON = A.withObject "ProcessConfig" $ \o ->
    ProcessConfig
      <$> (o .:? "privileged")
      <*> (o .:? "user")
      <*> (o .:? "tty")
      <*> (o .:? "entrypoint")
      <*> (o .:? "arguments")

-- | ToJSON ProcessConfig
instance A.ToJSON ProcessConfig where
  toJSON ProcessConfig {..} =
   _omitNulls
      [ "privileged" .= processConfigPrivileged
      , "user" .= processConfigUser
      , "tty" .= processConfigTty
      , "entrypoint" .= processConfigEntrypoint
      , "arguments" .= processConfigArguments
      ]


-- | Construct a value of type 'ProcessConfig' (by applying it's required fields, if any)
mkProcessConfig
  :: ProcessConfig
mkProcessConfig =
  ProcessConfig
  { processConfigPrivileged = Nothing
  , processConfigUser = Nothing
  , processConfigTty = Nothing
  , processConfigEntrypoint = Nothing
  , processConfigArguments = Nothing
  }

-- ** ProgressDetail
-- | ProgressDetail
data ProgressDetail = ProgressDetail
  { progressDetailCurrent :: !(Maybe Int) -- ^ "current"
  , progressDetailTotal :: !(Maybe Int) -- ^ "total"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ProgressDetail
instance A.FromJSON ProgressDetail where
  parseJSON = A.withObject "ProgressDetail" $ \o ->
    ProgressDetail
      <$> (o .:? "current")
      <*> (o .:? "total")

-- | ToJSON ProgressDetail
instance A.ToJSON ProgressDetail where
  toJSON ProgressDetail {..} =
   _omitNulls
      [ "current" .= progressDetailCurrent
      , "total" .= progressDetailTotal
      ]


-- | Construct a value of type 'ProgressDetail' (by applying it's required fields, if any)
mkProgressDetail
  :: ProgressDetail
mkProgressDetail =
  ProgressDetail
  { progressDetailCurrent = Nothing
  , progressDetailTotal = Nothing
  }

-- ** PushImageInfo
-- | PushImageInfo
data PushImageInfo = PushImageInfo
  { pushImageInfoError :: !(Maybe Text) -- ^ "error"
  , pushImageInfoStatus :: !(Maybe Text) -- ^ "status"
  , pushImageInfoProgress :: !(Maybe Text) -- ^ "progress"
  , pushImageInfoProgressDetail :: !(Maybe ProgressDetail) -- ^ "progressDetail"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PushImageInfo
instance A.FromJSON PushImageInfo where
  parseJSON = A.withObject "PushImageInfo" $ \o ->
    PushImageInfo
      <$> (o .:? "error")
      <*> (o .:? "status")
      <*> (o .:? "progress")
      <*> (o .:? "progressDetail")

-- | ToJSON PushImageInfo
instance A.ToJSON PushImageInfo where
  toJSON PushImageInfo {..} =
   _omitNulls
      [ "error" .= pushImageInfoError
      , "status" .= pushImageInfoStatus
      , "progress" .= pushImageInfoProgress
      , "progressDetail" .= pushImageInfoProgressDetail
      ]


-- | Construct a value of type 'PushImageInfo' (by applying it's required fields, if any)
mkPushImageInfo
  :: PushImageInfo
mkPushImageInfo =
  PushImageInfo
  { pushImageInfoError = Nothing
  , pushImageInfoStatus = Nothing
  , pushImageInfoProgress = Nothing
  , pushImageInfoProgressDetail = Nothing
  }

-- ** RegistryServiceConfig
-- | RegistryServiceConfig
-- RegistryServiceConfig stores daemon registry services configuration. 
data RegistryServiceConfig = RegistryServiceConfig
  { registryServiceConfigAllowNondistributableArtifactsCidrs :: !(Maybe [Text]) -- ^ "AllowNondistributableArtifactsCIDRs" - List of IP ranges to which nondistributable artifacts can be pushed, using the CIDR syntax [RFC 4632](https://tools.ietf.org/html/4632).  Some images (for example, Windows base images) contain artifacts whose distribution is restricted by license. When these images are pushed to a registry, restricted artifacts are not included.  This configuration override this behavior, and enables the daemon to push nondistributable artifacts to all registries whose resolved IP address is within the subnet described by the CIDR syntax.  This option is useful when pushing images containing nondistributable artifacts to a registry on an air-gapped network so hosts on that network can pull the images without connecting to another server.  &gt; **Warning**: Nondistributable artifacts typically have restrictions &gt; on how and where they can be distributed and shared. Only use this &gt; feature to push artifacts to private registries and ensure that you &gt; are in compliance with any terms that cover redistributing &gt; nondistributable artifacts. 
  , registryServiceConfigAllowNondistributableArtifactsHostnames :: !(Maybe [Text]) -- ^ "AllowNondistributableArtifactsHostnames" - List of registry hostnames to which nondistributable artifacts can be pushed, using the format &#x60;&lt;hostname&gt;[:&lt;port&gt;]&#x60; or &#x60;&lt;IP address&gt;[:&lt;port&gt;]&#x60;.  Some images (for example, Windows base images) contain artifacts whose distribution is restricted by license. When these images are pushed to a registry, restricted artifacts are not included.  This configuration override this behavior for the specified registries.  This option is useful when pushing images containing nondistributable artifacts to a registry on an air-gapped network so hosts on that network can pull the images without connecting to another server.  &gt; **Warning**: Nondistributable artifacts typically have restrictions &gt; on how and where they can be distributed and shared. Only use this &gt; feature to push artifacts to private registries and ensure that you &gt; are in compliance with any terms that cover redistributing &gt; nondistributable artifacts. 
  , registryServiceConfigInsecureRegistryCidrs :: !(Maybe [Text]) -- ^ "InsecureRegistryCIDRs" - List of IP ranges of insecure registries, using the CIDR syntax ([RFC 4632](https://tools.ietf.org/html/4632)). Insecure registries accept un-encrypted (HTTP) and/or untrusted (HTTPS with certificates from unknown CAs) communication.  By default, local registries (&#x60;127.0.0.0/8&#x60;) are configured as insecure. All other registries are secure. Communicating with an insecure registry is not possible if the daemon assumes that registry is secure.  This configuration override this behavior, insecure communication with registries whose resolved IP address is within the subnet described by the CIDR syntax.  Registries can also be marked insecure by hostname. Those registries are listed under &#x60;IndexConfigs&#x60; and have their &#x60;Secure&#x60; field set to &#x60;false&#x60;.  &gt; **Warning**: Using this option can be useful when running a local &gt; registry, but introduces security vulnerabilities. This option &gt; should therefore ONLY be used for testing purposes. For increased &gt; security, users should add their CA to their system&#39;s list of trusted &gt; CAs instead of enabling this option. 
  , registryServiceConfigIndexConfigs :: !(Maybe (Map.Map String IndexInfo)) -- ^ "IndexConfigs"
  , registryServiceConfigMirrors :: !(Maybe [Text]) -- ^ "Mirrors" - List of registry URLs that act as a mirror for the official (&#x60;docker.io&#x60;) registry. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RegistryServiceConfig
instance A.FromJSON RegistryServiceConfig where
  parseJSON = A.withObject "RegistryServiceConfig" $ \o ->
    RegistryServiceConfig
      <$> (o .:? "AllowNondistributableArtifactsCIDRs")
      <*> (o .:? "AllowNondistributableArtifactsHostnames")
      <*> (o .:? "InsecureRegistryCIDRs")
      <*> (o .:? "IndexConfigs")
      <*> (o .:? "Mirrors")

-- | ToJSON RegistryServiceConfig
instance A.ToJSON RegistryServiceConfig where
  toJSON RegistryServiceConfig {..} =
   _omitNulls
      [ "AllowNondistributableArtifactsCIDRs" .= registryServiceConfigAllowNondistributableArtifactsCidrs
      , "AllowNondistributableArtifactsHostnames" .= registryServiceConfigAllowNondistributableArtifactsHostnames
      , "InsecureRegistryCIDRs" .= registryServiceConfigInsecureRegistryCidrs
      , "IndexConfigs" .= registryServiceConfigIndexConfigs
      , "Mirrors" .= registryServiceConfigMirrors
      ]


-- | Construct a value of type 'RegistryServiceConfig' (by applying it's required fields, if any)
mkRegistryServiceConfig
  :: RegistryServiceConfig
mkRegistryServiceConfig =
  RegistryServiceConfig
  { registryServiceConfigAllowNondistributableArtifactsCidrs = Nothing
  , registryServiceConfigAllowNondistributableArtifactsHostnames = Nothing
  , registryServiceConfigInsecureRegistryCidrs = Nothing
  , registryServiceConfigIndexConfigs = Nothing
  , registryServiceConfigMirrors = Nothing
  }

-- ** ResourceObject
-- | ResourceObject
-- An object describing the resources which can be advertised by a node and requested by a task. 
data ResourceObject = ResourceObject
  { resourceObjectNanoCpus :: !(Maybe Integer) -- ^ "NanoCPUs"
  , resourceObjectMemoryBytes :: !(Maybe Integer) -- ^ "MemoryBytes"
  , resourceObjectGenericResources :: !(Maybe [A.Value]) -- ^ "GenericResources" - User-defined resources can be either Integer resources (e.g, &#x60;SSD&#x3D;3&#x60;) or String resources (e.g, &#x60;GPU&#x3D;UUID1&#x60;). 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResourceObject
instance A.FromJSON ResourceObject where
  parseJSON = A.withObject "ResourceObject" $ \o ->
    ResourceObject
      <$> (o .:? "NanoCPUs")
      <*> (o .:? "MemoryBytes")
      <*> (o .:? "GenericResources")

-- | ToJSON ResourceObject
instance A.ToJSON ResourceObject where
  toJSON ResourceObject {..} =
   _omitNulls
      [ "NanoCPUs" .= resourceObjectNanoCpus
      , "MemoryBytes" .= resourceObjectMemoryBytes
      , "GenericResources" .= resourceObjectGenericResources
      ]


-- | Construct a value of type 'ResourceObject' (by applying it's required fields, if any)
mkResourceObject
  :: ResourceObject
mkResourceObject =
  ResourceObject
  { resourceObjectNanoCpus = Nothing
  , resourceObjectMemoryBytes = Nothing
  , resourceObjectGenericResources = Nothing
  }

-- ** Resources
-- | Resources
-- A container's resources (cgroups config, ulimits, etc)
data Resources = Resources
  { resourcesCpuShares :: !(Maybe Int) -- ^ "CpuShares" - An integer value representing this container&#39;s relative CPU weight versus other containers. 
  , resourcesMemory :: !(Maybe Integer) -- ^ "Memory" - Memory limit in bytes.
  , resourcesCgroupParent :: !(Maybe Text) -- ^ "CgroupParent" - Path to &#x60;cgroups&#x60; under which the container&#39;s &#x60;cgroup&#x60; is created. If the path is not absolute, the path is considered to be relative to the &#x60;cgroups&#x60; path of the init process. Cgroups are created if they do not already exist. 
  , resourcesBlkioWeight :: !(Maybe Int) -- ^ "BlkioWeight" - Block IO weight (relative weight).
  , resourcesBlkioWeightDevice :: !(Maybe [ResourcesBlkioWeightDevice]) -- ^ "BlkioWeightDevice" - Block IO weight (relative device weight) in the form:  &#x60;&#x60;&#x60; [{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Weight\&quot;: weight}] &#x60;&#x60;&#x60; 
  , resourcesBlkioDeviceReadBps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceReadBps" - Limit read rate (bytes per second) from a device, in the form:  &#x60;&#x60;&#x60; [{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}] &#x60;&#x60;&#x60; 
  , resourcesBlkioDeviceWriteBps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceWriteBps" - Limit write rate (bytes per second) to a device, in the form:  &#x60;&#x60;&#x60; [{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}] &#x60;&#x60;&#x60; 
  , resourcesBlkioDeviceReadIOps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceReadIOps" - Limit read rate (IO per second) from a device, in the form:  &#x60;&#x60;&#x60; [{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}] &#x60;&#x60;&#x60; 
  , resourcesBlkioDeviceWriteIOps :: !(Maybe [ThrottleDevice]) -- ^ "BlkioDeviceWriteIOps" - Limit write rate (IO per second) to a device, in the form:  &#x60;&#x60;&#x60; [{\&quot;Path\&quot;: \&quot;device_path\&quot;, \&quot;Rate\&quot;: rate}] &#x60;&#x60;&#x60; 
  , resourcesCpuPeriod :: !(Maybe Integer) -- ^ "CpuPeriod" - The length of a CPU period in microseconds.
  , resourcesCpuQuota :: !(Maybe Integer) -- ^ "CpuQuota" - Microseconds of CPU time that the container can get in a CPU period. 
  , resourcesCpuRealtimePeriod :: !(Maybe Integer) -- ^ "CpuRealtimePeriod" - The length of a CPU real-time period in microseconds. Set to 0 to allocate no time allocated to real-time tasks. 
  , resourcesCpuRealtimeRuntime :: !(Maybe Integer) -- ^ "CpuRealtimeRuntime" - The length of a CPU real-time runtime in microseconds. Set to 0 to allocate no time allocated to real-time tasks. 
  , resourcesCpusetCpus :: !(Maybe Text) -- ^ "CpusetCpus" - CPUs in which to allow execution (e.g., &#x60;0-3&#x60;, &#x60;0,1&#x60;). 
  , resourcesCpusetMems :: !(Maybe Text) -- ^ "CpusetMems" - Memory nodes (MEMs) in which to allow execution (0-3, 0,1). Only effective on NUMA systems. 
  , resourcesDevices :: !(Maybe [DeviceMapping]) -- ^ "Devices" - A list of devices to add to the container.
  , resourcesDeviceCgroupRules :: !(Maybe [Text]) -- ^ "DeviceCgroupRules" - a list of cgroup rules to apply to the container
  , resourcesDeviceRequests :: !(Maybe [DeviceRequest]) -- ^ "DeviceRequests" - A list of requests for devices to be sent to device drivers. 
  , resourcesKernelMemory :: !(Maybe Integer) -- ^ "KernelMemory" - Kernel memory limit in bytes.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Deprecated**: This field is deprecated as the kernel 5.4 deprecated &gt; &#x60;kmem.limit_in_bytes&#x60;. 
  , resourcesKernelMemoryTcp :: !(Maybe Integer) -- ^ "KernelMemoryTCP" - Hard limit for kernel TCP buffer memory (in bytes).
  , resourcesMemoryReservation :: !(Maybe Integer) -- ^ "MemoryReservation" - Memory soft limit in bytes.
  , resourcesMemorySwap :: !(Maybe Integer) -- ^ "MemorySwap" - Total memory limit (memory + swap). Set as &#x60;-1&#x60; to enable unlimited swap. 
  , resourcesMemorySwappiness :: !(Maybe Integer) -- ^ "MemorySwappiness" - Tune a container&#39;s memory swappiness behavior. Accepts an integer between 0 and 100. 
  , resourcesNanoCpus :: !(Maybe Integer) -- ^ "NanoCpus" - CPU quota in units of 10&lt;sup&gt;-9&lt;/sup&gt; CPUs.
  , resourcesOomKillDisable :: !(Maybe Bool) -- ^ "OomKillDisable" - Disable OOM Killer for the container.
  , resourcesInit :: !(Maybe Bool) -- ^ "Init" - Run an init inside the container that forwards signals and reaps processes. This field is omitted if empty, and the default (as configured on the daemon) is used. 
  , resourcesPidsLimit :: !(Maybe Integer) -- ^ "PidsLimit" - Tune a container&#39;s PIDs limit. Set &#x60;0&#x60; or &#x60;-1&#x60; for unlimited, or &#x60;null&#x60; to not change. 
  , resourcesUlimits :: !(Maybe [ResourcesUlimits]) -- ^ "Ulimits" - A list of resource limits to set in the container. For example:  &#x60;&#x60;&#x60; {\&quot;Name\&quot;: \&quot;nofile\&quot;, \&quot;Soft\&quot;: 1024, \&quot;Hard\&quot;: 2048} &#x60;&#x60;&#x60; 
  , resourcesCpuCount :: !(Maybe Integer) -- ^ "CpuCount" - The number of usable CPUs (Windows only).  On Windows Server containers, the processor resource controls are mutually exclusive. The order of precedence is &#x60;CPUCount&#x60; first, then &#x60;CPUShares&#x60;, and &#x60;CPUPercent&#x60; last. 
  , resourcesCpuPercent :: !(Maybe Integer) -- ^ "CpuPercent" - The usable percentage of the available CPUs (Windows only).  On Windows Server containers, the processor resource controls are mutually exclusive. The order of precedence is &#x60;CPUCount&#x60; first, then &#x60;CPUShares&#x60;, and &#x60;CPUPercent&#x60; last. 
  , resourcesIoMaximumIOps :: !(Maybe Integer) -- ^ "IOMaximumIOps" - Maximum IOps for the container system drive (Windows only)
  , resourcesIoMaximumBandwidth :: !(Maybe Integer) -- ^ "IOMaximumBandwidth" - Maximum IO in bytes per second for the container system drive (Windows only). 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Resources
instance A.FromJSON Resources where
  parseJSON = A.withObject "Resources" $ \o ->
    Resources
      <$> (o .:? "CpuShares")
      <*> (o .:? "Memory")
      <*> (o .:? "CgroupParent")
      <*> (o .:? "BlkioWeight")
      <*> (o .:? "BlkioWeightDevice")
      <*> (o .:? "BlkioDeviceReadBps")
      <*> (o .:? "BlkioDeviceWriteBps")
      <*> (o .:? "BlkioDeviceReadIOps")
      <*> (o .:? "BlkioDeviceWriteIOps")
      <*> (o .:? "CpuPeriod")
      <*> (o .:? "CpuQuota")
      <*> (o .:? "CpuRealtimePeriod")
      <*> (o .:? "CpuRealtimeRuntime")
      <*> (o .:? "CpusetCpus")
      <*> (o .:? "CpusetMems")
      <*> (o .:? "Devices")
      <*> (o .:? "DeviceCgroupRules")
      <*> (o .:? "DeviceRequests")
      <*> (o .:? "KernelMemory")
      <*> (o .:? "KernelMemoryTCP")
      <*> (o .:? "MemoryReservation")
      <*> (o .:? "MemorySwap")
      <*> (o .:? "MemorySwappiness")
      <*> (o .:? "NanoCpus")
      <*> (o .:? "OomKillDisable")
      <*> (o .:? "Init")
      <*> (o .:? "PidsLimit")
      <*> (o .:? "Ulimits")
      <*> (o .:? "CpuCount")
      <*> (o .:? "CpuPercent")
      <*> (o .:? "IOMaximumIOps")
      <*> (o .:? "IOMaximumBandwidth")

-- | ToJSON Resources
instance A.ToJSON Resources where
  toJSON Resources {..} =
   _omitNulls
      [ "CpuShares" .= resourcesCpuShares
      , "Memory" .= resourcesMemory
      , "CgroupParent" .= resourcesCgroupParent
      , "BlkioWeight" .= resourcesBlkioWeight
      , "BlkioWeightDevice" .= resourcesBlkioWeightDevice
      , "BlkioDeviceReadBps" .= resourcesBlkioDeviceReadBps
      , "BlkioDeviceWriteBps" .= resourcesBlkioDeviceWriteBps
      , "BlkioDeviceReadIOps" .= resourcesBlkioDeviceReadIOps
      , "BlkioDeviceWriteIOps" .= resourcesBlkioDeviceWriteIOps
      , "CpuPeriod" .= resourcesCpuPeriod
      , "CpuQuota" .= resourcesCpuQuota
      , "CpuRealtimePeriod" .= resourcesCpuRealtimePeriod
      , "CpuRealtimeRuntime" .= resourcesCpuRealtimeRuntime
      , "CpusetCpus" .= resourcesCpusetCpus
      , "CpusetMems" .= resourcesCpusetMems
      , "Devices" .= resourcesDevices
      , "DeviceCgroupRules" .= resourcesDeviceCgroupRules
      , "DeviceRequests" .= resourcesDeviceRequests
      , "KernelMemory" .= resourcesKernelMemory
      , "KernelMemoryTCP" .= resourcesKernelMemoryTcp
      , "MemoryReservation" .= resourcesMemoryReservation
      , "MemorySwap" .= resourcesMemorySwap
      , "MemorySwappiness" .= resourcesMemorySwappiness
      , "NanoCpus" .= resourcesNanoCpus
      , "OomKillDisable" .= resourcesOomKillDisable
      , "Init" .= resourcesInit
      , "PidsLimit" .= resourcesPidsLimit
      , "Ulimits" .= resourcesUlimits
      , "CpuCount" .= resourcesCpuCount
      , "CpuPercent" .= resourcesCpuPercent
      , "IOMaximumIOps" .= resourcesIoMaximumIOps
      , "IOMaximumBandwidth" .= resourcesIoMaximumBandwidth
      ]


-- | Construct a value of type 'Resources' (by applying it's required fields, if any)
mkResources
  :: Resources
mkResources =
  Resources
  { resourcesCpuShares = Nothing
  , resourcesMemory = Nothing
  , resourcesCgroupParent = Nothing
  , resourcesBlkioWeight = Nothing
  , resourcesBlkioWeightDevice = Nothing
  , resourcesBlkioDeviceReadBps = Nothing
  , resourcesBlkioDeviceWriteBps = Nothing
  , resourcesBlkioDeviceReadIOps = Nothing
  , resourcesBlkioDeviceWriteIOps = Nothing
  , resourcesCpuPeriod = Nothing
  , resourcesCpuQuota = Nothing
  , resourcesCpuRealtimePeriod = Nothing
  , resourcesCpuRealtimeRuntime = Nothing
  , resourcesCpusetCpus = Nothing
  , resourcesCpusetMems = Nothing
  , resourcesDevices = Nothing
  , resourcesDeviceCgroupRules = Nothing
  , resourcesDeviceRequests = Nothing
  , resourcesKernelMemory = Nothing
  , resourcesKernelMemoryTcp = Nothing
  , resourcesMemoryReservation = Nothing
  , resourcesMemorySwap = Nothing
  , resourcesMemorySwappiness = Nothing
  , resourcesNanoCpus = Nothing
  , resourcesOomKillDisable = Nothing
  , resourcesInit = Nothing
  , resourcesPidsLimit = Nothing
  , resourcesUlimits = Nothing
  , resourcesCpuCount = Nothing
  , resourcesCpuPercent = Nothing
  , resourcesIoMaximumIOps = Nothing
  , resourcesIoMaximumBandwidth = Nothing
  }

-- ** ResourcesBlkioWeightDevice
-- | ResourcesBlkioWeightDevice
data ResourcesBlkioWeightDevice = ResourcesBlkioWeightDevice
  { resourcesBlkioWeightDevicePath :: !(Maybe Text) -- ^ "Path"
  , resourcesBlkioWeightDeviceWeight :: !(Maybe Int) -- ^ "Weight"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResourcesBlkioWeightDevice
instance A.FromJSON ResourcesBlkioWeightDevice where
  parseJSON = A.withObject "ResourcesBlkioWeightDevice" $ \o ->
    ResourcesBlkioWeightDevice
      <$> (o .:? "Path")
      <*> (o .:? "Weight")

-- | ToJSON ResourcesBlkioWeightDevice
instance A.ToJSON ResourcesBlkioWeightDevice where
  toJSON ResourcesBlkioWeightDevice {..} =
   _omitNulls
      [ "Path" .= resourcesBlkioWeightDevicePath
      , "Weight" .= resourcesBlkioWeightDeviceWeight
      ]


-- | Construct a value of type 'ResourcesBlkioWeightDevice' (by applying it's required fields, if any)
mkResourcesBlkioWeightDevice
  :: ResourcesBlkioWeightDevice
mkResourcesBlkioWeightDevice =
  ResourcesBlkioWeightDevice
  { resourcesBlkioWeightDevicePath = Nothing
  , resourcesBlkioWeightDeviceWeight = Nothing
  }

-- ** ResourcesUlimits
-- | ResourcesUlimits
data ResourcesUlimits = ResourcesUlimits
  { resourcesUlimitsName :: !(Maybe Text) -- ^ "Name" - Name of ulimit
  , resourcesUlimitsSoft :: !(Maybe Int) -- ^ "Soft" - Soft limit
  , resourcesUlimitsHard :: !(Maybe Int) -- ^ "Hard" - Hard limit
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResourcesUlimits
instance A.FromJSON ResourcesUlimits where
  parseJSON = A.withObject "ResourcesUlimits" $ \o ->
    ResourcesUlimits
      <$> (o .:? "Name")
      <*> (o .:? "Soft")
      <*> (o .:? "Hard")

-- | ToJSON ResourcesUlimits
instance A.ToJSON ResourcesUlimits where
  toJSON ResourcesUlimits {..} =
   _omitNulls
      [ "Name" .= resourcesUlimitsName
      , "Soft" .= resourcesUlimitsSoft
      , "Hard" .= resourcesUlimitsHard
      ]


-- | Construct a value of type 'ResourcesUlimits' (by applying it's required fields, if any)
mkResourcesUlimits
  :: ResourcesUlimits
mkResourcesUlimits =
  ResourcesUlimits
  { resourcesUlimitsName = Nothing
  , resourcesUlimitsSoft = Nothing
  , resourcesUlimitsHard = Nothing
  }

-- ** RestartPolicy
-- | RestartPolicy
-- The behavior to apply when the container exits. The default is not to restart.  An ever increasing delay (double the previous delay, starting at 100ms) is added before each restart to prevent flooding the server. 
data RestartPolicy = RestartPolicy
  { restartPolicyName :: !(Maybe E'Name) -- ^ "Name" - - Empty string means not to restart - &#x60;no&#x60; Do not automatically restart - &#x60;always&#x60; Always restart - &#x60;unless-stopped&#x60; Restart always except when the user has manually stopped the container - &#x60;on-failure&#x60; Restart only when the container exit code is non-zero 
  , restartPolicyMaximumRetryCount :: !(Maybe Int) -- ^ "MaximumRetryCount" - If &#x60;on-failure&#x60; is used, the number of times to retry before giving up. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RestartPolicy
instance A.FromJSON RestartPolicy where
  parseJSON = A.withObject "RestartPolicy" $ \o ->
    RestartPolicy
      <$> (o .:? "Name")
      <*> (o .:? "MaximumRetryCount")

-- | ToJSON RestartPolicy
instance A.ToJSON RestartPolicy where
  toJSON RestartPolicy {..} =
   _omitNulls
      [ "Name" .= restartPolicyName
      , "MaximumRetryCount" .= restartPolicyMaximumRetryCount
      ]


-- | Construct a value of type 'RestartPolicy' (by applying it's required fields, if any)
mkRestartPolicy
  :: RestartPolicy
mkRestartPolicy =
  RestartPolicy
  { restartPolicyName = Nothing
  , restartPolicyMaximumRetryCount = Nothing
  }

-- ** Runtime
-- | Runtime
-- Runtime describes an [OCI compliant](https://github.com/opencontainers/runtime-spec) runtime.  The runtime is invoked by the daemon via the `containerd` daemon. OCI runtimes act as an interface to the Linux kernel namespaces, cgroups, and SELinux. 
data Runtime = Runtime
  { runtimePath :: !(Maybe Text) -- ^ "path" - Name and, optional, path, of the OCI executable binary.  If the path is omitted, the daemon searches the host&#39;s &#x60;$PATH&#x60; for the binary and uses the first result. 
  , runtimeRuntimeArgs :: !(Maybe [Text]) -- ^ "runtimeArgs" - List of command-line arguments to pass to the runtime when invoked. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Runtime
instance A.FromJSON Runtime where
  parseJSON = A.withObject "Runtime" $ \o ->
    Runtime
      <$> (o .:? "path")
      <*> (o .:? "runtimeArgs")

-- | ToJSON Runtime
instance A.ToJSON Runtime where
  toJSON Runtime {..} =
   _omitNulls
      [ "path" .= runtimePath
      , "runtimeArgs" .= runtimeRuntimeArgs
      ]


-- | Construct a value of type 'Runtime' (by applying it's required fields, if any)
mkRuntime
  :: Runtime
mkRuntime =
  Runtime
  { runtimePath = Nothing
  , runtimeRuntimeArgs = Nothing
  }

-- ** Secret
-- | Secret
data Secret = Secret
  { secretId :: !(Maybe Text) -- ^ "ID"
  , secretVersion :: !(Maybe ObjectVersion) -- ^ "Version"
  , secretCreatedAt :: !(Maybe Text) -- ^ "CreatedAt"
  , secretUpdatedAt :: !(Maybe Text) -- ^ "UpdatedAt"
  , secretSpec :: !(Maybe SecretSpec) -- ^ "Spec"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Secret
instance A.FromJSON Secret where
  parseJSON = A.withObject "Secret" $ \o ->
    Secret
      <$> (o .:? "ID")
      <*> (o .:? "Version")
      <*> (o .:? "CreatedAt")
      <*> (o .:? "UpdatedAt")
      <*> (o .:? "Spec")

-- | ToJSON Secret
instance A.ToJSON Secret where
  toJSON Secret {..} =
   _omitNulls
      [ "ID" .= secretId
      , "Version" .= secretVersion
      , "CreatedAt" .= secretCreatedAt
      , "UpdatedAt" .= secretUpdatedAt
      , "Spec" .= secretSpec
      ]


-- | Construct a value of type 'Secret' (by applying it's required fields, if any)
mkSecret
  :: Secret
mkSecret =
  Secret
  { secretId = Nothing
  , secretVersion = Nothing
  , secretCreatedAt = Nothing
  , secretUpdatedAt = Nothing
  , secretSpec = Nothing
  }

-- ** SecretSpec
-- | SecretSpec
data SecretSpec = SecretSpec
  { secretSpecName :: !(Maybe Text) -- ^ "Name" - User-defined name of the secret.
  , secretSpecLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , secretSpecData :: !(Maybe Text) -- ^ "Data" - Base64-url-safe-encoded ([RFC 4648](https://tools.ietf.org/html/rfc4648#section-5)) data to store as secret.  This field is only used to _create_ a secret, and is not returned by other endpoints. 
  , secretSpecDriver :: !(Maybe Driver) -- ^ "Driver"
  , secretSpecTemplating :: !(Maybe Driver) -- ^ "Templating"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SecretSpec
instance A.FromJSON SecretSpec where
  parseJSON = A.withObject "SecretSpec" $ \o ->
    SecretSpec
      <$> (o .:? "Name")
      <*> (o .:? "Labels")
      <*> (o .:? "Data")
      <*> (o .:? "Driver")
      <*> (o .:? "Templating")

-- | ToJSON SecretSpec
instance A.ToJSON SecretSpec where
  toJSON SecretSpec {..} =
   _omitNulls
      [ "Name" .= secretSpecName
      , "Labels" .= secretSpecLabels
      , "Data" .= secretSpecData
      , "Driver" .= secretSpecDriver
      , "Templating" .= secretSpecTemplating
      ]


-- | Construct a value of type 'SecretSpec' (by applying it's required fields, if any)
mkSecretSpec
  :: SecretSpec
mkSecretSpec =
  SecretSpec
  { secretSpecName = Nothing
  , secretSpecLabels = Nothing
  , secretSpecData = Nothing
  , secretSpecDriver = Nothing
  , secretSpecTemplating = Nothing
  }

-- ** Service
-- | Service
data Service = Service
  { serviceId :: !(Maybe Text) -- ^ "ID"
  , serviceVersion :: !(Maybe ObjectVersion) -- ^ "Version"
  , serviceCreatedAt :: !(Maybe Text) -- ^ "CreatedAt"
  , serviceUpdatedAt :: !(Maybe Text) -- ^ "UpdatedAt"
  , serviceSpec :: !(Maybe ServiceSpec) -- ^ "Spec"
  , serviceEndpoint :: !(Maybe ServiceEndpoint) -- ^ "Endpoint"
  , serviceUpdateStatus :: !(Maybe ServiceUpdateStatus) -- ^ "UpdateStatus"
  , serviceServiceStatus :: !(Maybe ServiceServiceStatus) -- ^ "ServiceStatus"
  , serviceJobStatus :: !(Maybe ServiceJobStatus) -- ^ "JobStatus"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Service
instance A.FromJSON Service where
  parseJSON = A.withObject "Service" $ \o ->
    Service
      <$> (o .:? "ID")
      <*> (o .:? "Version")
      <*> (o .:? "CreatedAt")
      <*> (o .:? "UpdatedAt")
      <*> (o .:? "Spec")
      <*> (o .:? "Endpoint")
      <*> (o .:? "UpdateStatus")
      <*> (o .:? "ServiceStatus")
      <*> (o .:? "JobStatus")

-- | ToJSON Service
instance A.ToJSON Service where
  toJSON Service {..} =
   _omitNulls
      [ "ID" .= serviceId
      , "Version" .= serviceVersion
      , "CreatedAt" .= serviceCreatedAt
      , "UpdatedAt" .= serviceUpdatedAt
      , "Spec" .= serviceSpec
      , "Endpoint" .= serviceEndpoint
      , "UpdateStatus" .= serviceUpdateStatus
      , "ServiceStatus" .= serviceServiceStatus
      , "JobStatus" .= serviceJobStatus
      ]


-- | Construct a value of type 'Service' (by applying it's required fields, if any)
mkService
  :: Service
mkService =
  Service
  { serviceId = Nothing
  , serviceVersion = Nothing
  , serviceCreatedAt = Nothing
  , serviceUpdatedAt = Nothing
  , serviceSpec = Nothing
  , serviceEndpoint = Nothing
  , serviceUpdateStatus = Nothing
  , serviceServiceStatus = Nothing
  , serviceJobStatus = Nothing
  }

-- ** ServiceCreateResponse
-- | ServiceCreateResponse
-- ServiceCreateResponse
-- 
data ServiceCreateResponse = ServiceCreateResponse
  { serviceCreateResponseId :: !(Maybe Text) -- ^ "ID" - The ID of the created service.
  , serviceCreateResponseWarning :: !(Maybe Text) -- ^ "Warning" - Optional warning message
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceCreateResponse
instance A.FromJSON ServiceCreateResponse where
  parseJSON = A.withObject "ServiceCreateResponse" $ \o ->
    ServiceCreateResponse
      <$> (o .:? "ID")
      <*> (o .:? "Warning")

-- | ToJSON ServiceCreateResponse
instance A.ToJSON ServiceCreateResponse where
  toJSON ServiceCreateResponse {..} =
   _omitNulls
      [ "ID" .= serviceCreateResponseId
      , "Warning" .= serviceCreateResponseWarning
      ]


-- | Construct a value of type 'ServiceCreateResponse' (by applying it's required fields, if any)
mkServiceCreateResponse
  :: ServiceCreateResponse
mkServiceCreateResponse =
  ServiceCreateResponse
  { serviceCreateResponseId = Nothing
  , serviceCreateResponseWarning = Nothing
  }

-- ** ServiceEndpoint
-- | ServiceEndpoint
data ServiceEndpoint = ServiceEndpoint
  { serviceEndpointSpec :: !(Maybe EndpointSpec) -- ^ "Spec"
  , serviceEndpointPorts :: !(Maybe [EndpointPortConfig]) -- ^ "Ports"
  , serviceEndpointVirtualIps :: !(Maybe [ServiceEndpointVirtualIPs]) -- ^ "VirtualIPs"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceEndpoint
instance A.FromJSON ServiceEndpoint where
  parseJSON = A.withObject "ServiceEndpoint" $ \o ->
    ServiceEndpoint
      <$> (o .:? "Spec")
      <*> (o .:? "Ports")
      <*> (o .:? "VirtualIPs")

-- | ToJSON ServiceEndpoint
instance A.ToJSON ServiceEndpoint where
  toJSON ServiceEndpoint {..} =
   _omitNulls
      [ "Spec" .= serviceEndpointSpec
      , "Ports" .= serviceEndpointPorts
      , "VirtualIPs" .= serviceEndpointVirtualIps
      ]


-- | Construct a value of type 'ServiceEndpoint' (by applying it's required fields, if any)
mkServiceEndpoint
  :: ServiceEndpoint
mkServiceEndpoint =
  ServiceEndpoint
  { serviceEndpointSpec = Nothing
  , serviceEndpointPorts = Nothing
  , serviceEndpointVirtualIps = Nothing
  }

-- ** ServiceEndpointVirtualIPs
-- | ServiceEndpointVirtualIPs
data ServiceEndpointVirtualIPs = ServiceEndpointVirtualIPs
  { serviceEndpointVirtualIPsNetworkId :: !(Maybe Text) -- ^ "NetworkID"
  , serviceEndpointVirtualIPsAddr :: !(Maybe Text) -- ^ "Addr"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceEndpointVirtualIPs
instance A.FromJSON ServiceEndpointVirtualIPs where
  parseJSON = A.withObject "ServiceEndpointVirtualIPs" $ \o ->
    ServiceEndpointVirtualIPs
      <$> (o .:? "NetworkID")
      <*> (o .:? "Addr")

-- | ToJSON ServiceEndpointVirtualIPs
instance A.ToJSON ServiceEndpointVirtualIPs where
  toJSON ServiceEndpointVirtualIPs {..} =
   _omitNulls
      [ "NetworkID" .= serviceEndpointVirtualIPsNetworkId
      , "Addr" .= serviceEndpointVirtualIPsAddr
      ]


-- | Construct a value of type 'ServiceEndpointVirtualIPs' (by applying it's required fields, if any)
mkServiceEndpointVirtualIPs
  :: ServiceEndpointVirtualIPs
mkServiceEndpointVirtualIPs =
  ServiceEndpointVirtualIPs
  { serviceEndpointVirtualIPsNetworkId = Nothing
  , serviceEndpointVirtualIPsAddr = Nothing
  }

-- ** ServiceJobStatus
-- | ServiceJobStatus
-- The status of the service when it is in one of ReplicatedJob or GlobalJob modes. Absent on Replicated and Global mode services. The JobIteration is an ObjectVersion, but unlike the Service's version, does not need to be sent with an update request. 
data ServiceJobStatus = ServiceJobStatus
  { serviceJobStatusJobIteration :: !(Maybe ObjectVersion) -- ^ "JobIteration"
  , serviceJobStatusLastExecution :: !(Maybe Text) -- ^ "LastExecution" - The last time, as observed by the server, that this job was started. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceJobStatus
instance A.FromJSON ServiceJobStatus where
  parseJSON = A.withObject "ServiceJobStatus" $ \o ->
    ServiceJobStatus
      <$> (o .:? "JobIteration")
      <*> (o .:? "LastExecution")

-- | ToJSON ServiceJobStatus
instance A.ToJSON ServiceJobStatus where
  toJSON ServiceJobStatus {..} =
   _omitNulls
      [ "JobIteration" .= serviceJobStatusJobIteration
      , "LastExecution" .= serviceJobStatusLastExecution
      ]


-- | Construct a value of type 'ServiceJobStatus' (by applying it's required fields, if any)
mkServiceJobStatus
  :: ServiceJobStatus
mkServiceJobStatus =
  ServiceJobStatus
  { serviceJobStatusJobIteration = Nothing
  , serviceJobStatusLastExecution = Nothing
  }

-- ** ServiceServiceStatus
-- | ServiceServiceStatus
-- The status of the service's tasks. Provided only when requested as part of a ServiceList operation. 
data ServiceServiceStatus = ServiceServiceStatus
  { serviceServiceStatusRunningTasks :: !(Maybe Int) -- ^ "RunningTasks" - The number of tasks for the service currently in the Running state. 
  , serviceServiceStatusDesiredTasks :: !(Maybe Int) -- ^ "DesiredTasks" - The number of tasks for the service desired to be running. For replicated services, this is the replica count from the service spec. For global services, this is computed by taking count of all tasks for the service with a Desired State other than Shutdown. 
  , serviceServiceStatusCompletedTasks :: !(Maybe Int) -- ^ "CompletedTasks" - The number of tasks for a job that are in the Completed state. This field must be cross-referenced with the service type, as the value of 0 may mean the service is not in a job mode, or it may mean the job-mode service has no tasks yet Completed. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceServiceStatus
instance A.FromJSON ServiceServiceStatus where
  parseJSON = A.withObject "ServiceServiceStatus" $ \o ->
    ServiceServiceStatus
      <$> (o .:? "RunningTasks")
      <*> (o .:? "DesiredTasks")
      <*> (o .:? "CompletedTasks")

-- | ToJSON ServiceServiceStatus
instance A.ToJSON ServiceServiceStatus where
  toJSON ServiceServiceStatus {..} =
   _omitNulls
      [ "RunningTasks" .= serviceServiceStatusRunningTasks
      , "DesiredTasks" .= serviceServiceStatusDesiredTasks
      , "CompletedTasks" .= serviceServiceStatusCompletedTasks
      ]


-- | Construct a value of type 'ServiceServiceStatus' (by applying it's required fields, if any)
mkServiceServiceStatus
  :: ServiceServiceStatus
mkServiceServiceStatus =
  ServiceServiceStatus
  { serviceServiceStatusRunningTasks = Nothing
  , serviceServiceStatusDesiredTasks = Nothing
  , serviceServiceStatusCompletedTasks = Nothing
  }

-- ** ServiceSpec
-- | ServiceSpec
-- User modifiable configuration for a service.
data ServiceSpec = ServiceSpec
  { serviceSpecName :: !(Maybe Text) -- ^ "Name" - Name of the service.
  , serviceSpecLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , serviceSpecTaskTemplate :: !(Maybe TaskSpec) -- ^ "TaskTemplate"
  , serviceSpecMode :: !(Maybe ServiceSpecMode) -- ^ "Mode"
  , serviceSpecUpdateConfig :: !(Maybe ServiceSpecUpdateConfig) -- ^ "UpdateConfig"
  , serviceSpecRollbackConfig :: !(Maybe ServiceSpecRollbackConfig) -- ^ "RollbackConfig"
  , serviceSpecNetworks :: !(Maybe [NetworkAttachmentConfig]) -- ^ "Networks" - Specifies which networks the service should attach to.
  , serviceSpecEndpointSpec :: !(Maybe EndpointSpec) -- ^ "EndpointSpec"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceSpec
instance A.FromJSON ServiceSpec where
  parseJSON = A.withObject "ServiceSpec" $ \o ->
    ServiceSpec
      <$> (o .:? "Name")
      <*> (o .:? "Labels")
      <*> (o .:? "TaskTemplate")
      <*> (o .:? "Mode")
      <*> (o .:? "UpdateConfig")
      <*> (o .:? "RollbackConfig")
      <*> (o .:? "Networks")
      <*> (o .:? "EndpointSpec")

-- | ToJSON ServiceSpec
instance A.ToJSON ServiceSpec where
  toJSON ServiceSpec {..} =
   _omitNulls
      [ "Name" .= serviceSpecName
      , "Labels" .= serviceSpecLabels
      , "TaskTemplate" .= serviceSpecTaskTemplate
      , "Mode" .= serviceSpecMode
      , "UpdateConfig" .= serviceSpecUpdateConfig
      , "RollbackConfig" .= serviceSpecRollbackConfig
      , "Networks" .= serviceSpecNetworks
      , "EndpointSpec" .= serviceSpecEndpointSpec
      ]


-- | Construct a value of type 'ServiceSpec' (by applying it's required fields, if any)
mkServiceSpec
  :: ServiceSpec
mkServiceSpec =
  ServiceSpec
  { serviceSpecName = Nothing
  , serviceSpecLabels = Nothing
  , serviceSpecTaskTemplate = Nothing
  , serviceSpecMode = Nothing
  , serviceSpecUpdateConfig = Nothing
  , serviceSpecRollbackConfig = Nothing
  , serviceSpecNetworks = Nothing
  , serviceSpecEndpointSpec = Nothing
  }

-- ** ServiceSpecMode
-- | ServiceSpecMode
-- Scheduling mode for the service.
data ServiceSpecMode = ServiceSpecMode
  { serviceSpecModeReplicated :: !(Maybe ServiceSpecModeReplicated) -- ^ "Replicated"
  , serviceSpecModeGlobal :: !(Maybe A.Value) -- ^ "Global"
  , serviceSpecModeReplicatedJob :: !(Maybe ServiceSpecModeReplicatedJob) -- ^ "ReplicatedJob"
  , serviceSpecModeGlobalJob :: !(Maybe A.Value) -- ^ "GlobalJob" - The mode used for services which run a task to the completed state on each valid node. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceSpecMode
instance A.FromJSON ServiceSpecMode where
  parseJSON = A.withObject "ServiceSpecMode" $ \o ->
    ServiceSpecMode
      <$> (o .:? "Replicated")
      <*> (o .:? "Global")
      <*> (o .:? "ReplicatedJob")
      <*> (o .:? "GlobalJob")

-- | ToJSON ServiceSpecMode
instance A.ToJSON ServiceSpecMode where
  toJSON ServiceSpecMode {..} =
   _omitNulls
      [ "Replicated" .= serviceSpecModeReplicated
      , "Global" .= serviceSpecModeGlobal
      , "ReplicatedJob" .= serviceSpecModeReplicatedJob
      , "GlobalJob" .= serviceSpecModeGlobalJob
      ]


-- | Construct a value of type 'ServiceSpecMode' (by applying it's required fields, if any)
mkServiceSpecMode
  :: ServiceSpecMode
mkServiceSpecMode =
  ServiceSpecMode
  { serviceSpecModeReplicated = Nothing
  , serviceSpecModeGlobal = Nothing
  , serviceSpecModeReplicatedJob = Nothing
  , serviceSpecModeGlobalJob = Nothing
  }

-- ** ServiceSpecModeReplicated
-- | ServiceSpecModeReplicated
data ServiceSpecModeReplicated = ServiceSpecModeReplicated
  { serviceSpecModeReplicatedReplicas :: !(Maybe Integer) -- ^ "Replicas"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceSpecModeReplicated
instance A.FromJSON ServiceSpecModeReplicated where
  parseJSON = A.withObject "ServiceSpecModeReplicated" $ \o ->
    ServiceSpecModeReplicated
      <$> (o .:? "Replicas")

-- | ToJSON ServiceSpecModeReplicated
instance A.ToJSON ServiceSpecModeReplicated where
  toJSON ServiceSpecModeReplicated {..} =
   _omitNulls
      [ "Replicas" .= serviceSpecModeReplicatedReplicas
      ]


-- | Construct a value of type 'ServiceSpecModeReplicated' (by applying it's required fields, if any)
mkServiceSpecModeReplicated
  :: ServiceSpecModeReplicated
mkServiceSpecModeReplicated =
  ServiceSpecModeReplicated
  { serviceSpecModeReplicatedReplicas = Nothing
  }

-- ** ServiceSpecModeReplicatedJob
-- | ServiceSpecModeReplicatedJob
-- The mode used for services with a finite number of tasks that run to a completed state. 
data ServiceSpecModeReplicatedJob = ServiceSpecModeReplicatedJob
  { serviceSpecModeReplicatedJobMaxConcurrent :: !(Maybe Integer) -- ^ "MaxConcurrent" - The maximum number of replicas to run simultaneously. 
  , serviceSpecModeReplicatedJobTotalCompletions :: !(Maybe Integer) -- ^ "TotalCompletions" - The total number of replicas desired to reach the Completed state. If unset, will default to the value of &#x60;MaxConcurrent&#x60; 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceSpecModeReplicatedJob
instance A.FromJSON ServiceSpecModeReplicatedJob where
  parseJSON = A.withObject "ServiceSpecModeReplicatedJob" $ \o ->
    ServiceSpecModeReplicatedJob
      <$> (o .:? "MaxConcurrent")
      <*> (o .:? "TotalCompletions")

-- | ToJSON ServiceSpecModeReplicatedJob
instance A.ToJSON ServiceSpecModeReplicatedJob where
  toJSON ServiceSpecModeReplicatedJob {..} =
   _omitNulls
      [ "MaxConcurrent" .= serviceSpecModeReplicatedJobMaxConcurrent
      , "TotalCompletions" .= serviceSpecModeReplicatedJobTotalCompletions
      ]


-- | Construct a value of type 'ServiceSpecModeReplicatedJob' (by applying it's required fields, if any)
mkServiceSpecModeReplicatedJob
  :: ServiceSpecModeReplicatedJob
mkServiceSpecModeReplicatedJob =
  ServiceSpecModeReplicatedJob
  { serviceSpecModeReplicatedJobMaxConcurrent = Nothing
  , serviceSpecModeReplicatedJobTotalCompletions = Nothing
  }

-- ** ServiceSpecRollbackConfig
-- | ServiceSpecRollbackConfig
-- Specification for the rollback strategy of the service.
data ServiceSpecRollbackConfig = ServiceSpecRollbackConfig
  { serviceSpecRollbackConfigParallelism :: !(Maybe Integer) -- ^ "Parallelism" - Maximum number of tasks to be rolled back in one iteration (0 means unlimited parallelism). 
  , serviceSpecRollbackConfigDelay :: !(Maybe Integer) -- ^ "Delay" - Amount of time between rollback iterations, in nanoseconds. 
  , serviceSpecRollbackConfigFailureAction :: !(Maybe E'FailureAction2) -- ^ "FailureAction" - Action to take if an rolled back task fails to run, or stops running during the rollback. 
  , serviceSpecRollbackConfigMonitor :: !(Maybe Integer) -- ^ "Monitor" - Amount of time to monitor each rolled back task for failures, in nanoseconds. 
  , serviceSpecRollbackConfigMaxFailureRatio :: !(Maybe Double) -- ^ "MaxFailureRatio" - The fraction of tasks that may fail during a rollback before the failure action is invoked, specified as a floating point number between 0 and 1. 
  , serviceSpecRollbackConfigOrder :: !(Maybe E'Order) -- ^ "Order" - The order of operations when rolling back a task. Either the old task is shut down before the new task is started, or the new task is started before the old task is shut down. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceSpecRollbackConfig
instance A.FromJSON ServiceSpecRollbackConfig where
  parseJSON = A.withObject "ServiceSpecRollbackConfig" $ \o ->
    ServiceSpecRollbackConfig
      <$> (o .:? "Parallelism")
      <*> (o .:? "Delay")
      <*> (o .:? "FailureAction")
      <*> (o .:? "Monitor")
      <*> (o .:? "MaxFailureRatio")
      <*> (o .:? "Order")

-- | ToJSON ServiceSpecRollbackConfig
instance A.ToJSON ServiceSpecRollbackConfig where
  toJSON ServiceSpecRollbackConfig {..} =
   _omitNulls
      [ "Parallelism" .= serviceSpecRollbackConfigParallelism
      , "Delay" .= serviceSpecRollbackConfigDelay
      , "FailureAction" .= serviceSpecRollbackConfigFailureAction
      , "Monitor" .= serviceSpecRollbackConfigMonitor
      , "MaxFailureRatio" .= serviceSpecRollbackConfigMaxFailureRatio
      , "Order" .= serviceSpecRollbackConfigOrder
      ]


-- | Construct a value of type 'ServiceSpecRollbackConfig' (by applying it's required fields, if any)
mkServiceSpecRollbackConfig
  :: ServiceSpecRollbackConfig
mkServiceSpecRollbackConfig =
  ServiceSpecRollbackConfig
  { serviceSpecRollbackConfigParallelism = Nothing
  , serviceSpecRollbackConfigDelay = Nothing
  , serviceSpecRollbackConfigFailureAction = Nothing
  , serviceSpecRollbackConfigMonitor = Nothing
  , serviceSpecRollbackConfigMaxFailureRatio = Nothing
  , serviceSpecRollbackConfigOrder = Nothing
  }

-- ** ServiceSpecUpdateConfig
-- | ServiceSpecUpdateConfig
-- Specification for the update strategy of the service.
data ServiceSpecUpdateConfig = ServiceSpecUpdateConfig
  { serviceSpecUpdateConfigParallelism :: !(Maybe Integer) -- ^ "Parallelism" - Maximum number of tasks to be updated in one iteration (0 means unlimited parallelism). 
  , serviceSpecUpdateConfigDelay :: !(Maybe Integer) -- ^ "Delay" - Amount of time between updates, in nanoseconds.
  , serviceSpecUpdateConfigFailureAction :: !(Maybe E'FailureAction) -- ^ "FailureAction" - Action to take if an updated task fails to run, or stops running during the update. 
  , serviceSpecUpdateConfigMonitor :: !(Maybe Integer) -- ^ "Monitor" - Amount of time to monitor each updated task for failures, in nanoseconds. 
  , serviceSpecUpdateConfigMaxFailureRatio :: !(Maybe Double) -- ^ "MaxFailureRatio" - The fraction of tasks that may fail during an update before the failure action is invoked, specified as a floating point number between 0 and 1. 
  , serviceSpecUpdateConfigOrder :: !(Maybe E'Order) -- ^ "Order" - The order of operations when rolling out an updated task. Either the old task is shut down before the new task is started, or the new task is started before the old task is shut down. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceSpecUpdateConfig
instance A.FromJSON ServiceSpecUpdateConfig where
  parseJSON = A.withObject "ServiceSpecUpdateConfig" $ \o ->
    ServiceSpecUpdateConfig
      <$> (o .:? "Parallelism")
      <*> (o .:? "Delay")
      <*> (o .:? "FailureAction")
      <*> (o .:? "Monitor")
      <*> (o .:? "MaxFailureRatio")
      <*> (o .:? "Order")

-- | ToJSON ServiceSpecUpdateConfig
instance A.ToJSON ServiceSpecUpdateConfig where
  toJSON ServiceSpecUpdateConfig {..} =
   _omitNulls
      [ "Parallelism" .= serviceSpecUpdateConfigParallelism
      , "Delay" .= serviceSpecUpdateConfigDelay
      , "FailureAction" .= serviceSpecUpdateConfigFailureAction
      , "Monitor" .= serviceSpecUpdateConfigMonitor
      , "MaxFailureRatio" .= serviceSpecUpdateConfigMaxFailureRatio
      , "Order" .= serviceSpecUpdateConfigOrder
      ]


-- | Construct a value of type 'ServiceSpecUpdateConfig' (by applying it's required fields, if any)
mkServiceSpecUpdateConfig
  :: ServiceSpecUpdateConfig
mkServiceSpecUpdateConfig =
  ServiceSpecUpdateConfig
  { serviceSpecUpdateConfigParallelism = Nothing
  , serviceSpecUpdateConfigDelay = Nothing
  , serviceSpecUpdateConfigFailureAction = Nothing
  , serviceSpecUpdateConfigMonitor = Nothing
  , serviceSpecUpdateConfigMaxFailureRatio = Nothing
  , serviceSpecUpdateConfigOrder = Nothing
  }

-- ** ServiceUpdateResponse
-- | ServiceUpdateResponse
data ServiceUpdateResponse = ServiceUpdateResponse
  { serviceUpdateResponseWarnings :: !(Maybe [Text]) -- ^ "Warnings" - Optional warning messages
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceUpdateResponse
instance A.FromJSON ServiceUpdateResponse where
  parseJSON = A.withObject "ServiceUpdateResponse" $ \o ->
    ServiceUpdateResponse
      <$> (o .:? "Warnings")

-- | ToJSON ServiceUpdateResponse
instance A.ToJSON ServiceUpdateResponse where
  toJSON ServiceUpdateResponse {..} =
   _omitNulls
      [ "Warnings" .= serviceUpdateResponseWarnings
      ]


-- | Construct a value of type 'ServiceUpdateResponse' (by applying it's required fields, if any)
mkServiceUpdateResponse
  :: ServiceUpdateResponse
mkServiceUpdateResponse =
  ServiceUpdateResponse
  { serviceUpdateResponseWarnings = Nothing
  }

-- ** ServiceUpdateStatus
-- | ServiceUpdateStatus
-- The status of a service update.
data ServiceUpdateStatus = ServiceUpdateStatus
  { serviceUpdateStatusState :: !(Maybe E'State) -- ^ "State"
  , serviceUpdateStatusStartedAt :: !(Maybe Text) -- ^ "StartedAt"
  , serviceUpdateStatusCompletedAt :: !(Maybe Text) -- ^ "CompletedAt"
  , serviceUpdateStatusMessage :: !(Maybe Text) -- ^ "Message"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ServiceUpdateStatus
instance A.FromJSON ServiceUpdateStatus where
  parseJSON = A.withObject "ServiceUpdateStatus" $ \o ->
    ServiceUpdateStatus
      <$> (o .:? "State")
      <*> (o .:? "StartedAt")
      <*> (o .:? "CompletedAt")
      <*> (o .:? "Message")

-- | ToJSON ServiceUpdateStatus
instance A.ToJSON ServiceUpdateStatus where
  toJSON ServiceUpdateStatus {..} =
   _omitNulls
      [ "State" .= serviceUpdateStatusState
      , "StartedAt" .= serviceUpdateStatusStartedAt
      , "CompletedAt" .= serviceUpdateStatusCompletedAt
      , "Message" .= serviceUpdateStatusMessage
      ]


-- | Construct a value of type 'ServiceUpdateStatus' (by applying it's required fields, if any)
mkServiceUpdateStatus
  :: ServiceUpdateStatus
mkServiceUpdateStatus =
  ServiceUpdateStatus
  { serviceUpdateStatusState = Nothing
  , serviceUpdateStatusStartedAt = Nothing
  , serviceUpdateStatusCompletedAt = Nothing
  , serviceUpdateStatusMessage = Nothing
  }

-- ** Swarm
-- | Swarm
data Swarm = Swarm
  { swarmId :: !(Maybe Text) -- ^ "ID" - The ID of the swarm.
  , swarmVersion :: !(Maybe ObjectVersion) -- ^ "Version"
  , swarmCreatedAt :: !(Maybe Text) -- ^ "CreatedAt" - Date and time at which the swarm was initialised in [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds. 
  , swarmUpdatedAt :: !(Maybe Text) -- ^ "UpdatedAt" - Date and time at which the swarm was last updated in [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds. 
  , swarmSpec :: !(Maybe SwarmSpec) -- ^ "Spec"
  , swarmTlsInfo :: !(Maybe TLSInfo) -- ^ "TLSInfo"
  , swarmRootRotationInProgress :: !(Maybe Bool) -- ^ "RootRotationInProgress" - Whether there is currently a root CA rotation in progress for the swarm 
  , swarmDataPathPort :: !(Maybe Int) -- ^ "DataPathPort" - DataPathPort specifies the data path port number for data traffic. Acceptable port range is 1024 to 49151. If no port is set or is set to 0, the default port (4789) is used. 
  , swarmDefaultAddrPool :: !(Maybe [Text]) -- ^ "DefaultAddrPool" - Default Address Pool specifies default subnet pools for global scope networks. 
  , swarmSubnetSize :: !(Maybe Int) -- ^ "SubnetSize" - SubnetSize specifies the subnet size of the networks created from the default subnet pool. 
  , swarmJoinTokens :: !(Maybe JoinTokens) -- ^ "JoinTokens"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Swarm
instance A.FromJSON Swarm where
  parseJSON = A.withObject "Swarm" $ \o ->
    Swarm
      <$> (o .:? "ID")
      <*> (o .:? "Version")
      <*> (o .:? "CreatedAt")
      <*> (o .:? "UpdatedAt")
      <*> (o .:? "Spec")
      <*> (o .:? "TLSInfo")
      <*> (o .:? "RootRotationInProgress")
      <*> (o .:? "DataPathPort")
      <*> (o .:? "DefaultAddrPool")
      <*> (o .:? "SubnetSize")
      <*> (o .:? "JoinTokens")

-- | ToJSON Swarm
instance A.ToJSON Swarm where
  toJSON Swarm {..} =
   _omitNulls
      [ "ID" .= swarmId
      , "Version" .= swarmVersion
      , "CreatedAt" .= swarmCreatedAt
      , "UpdatedAt" .= swarmUpdatedAt
      , "Spec" .= swarmSpec
      , "TLSInfo" .= swarmTlsInfo
      , "RootRotationInProgress" .= swarmRootRotationInProgress
      , "DataPathPort" .= swarmDataPathPort
      , "DefaultAddrPool" .= swarmDefaultAddrPool
      , "SubnetSize" .= swarmSubnetSize
      , "JoinTokens" .= swarmJoinTokens
      ]


-- | Construct a value of type 'Swarm' (by applying it's required fields, if any)
mkSwarm
  :: Swarm
mkSwarm =
  Swarm
  { swarmId = Nothing
  , swarmVersion = Nothing
  , swarmCreatedAt = Nothing
  , swarmUpdatedAt = Nothing
  , swarmSpec = Nothing
  , swarmTlsInfo = Nothing
  , swarmRootRotationInProgress = Nothing
  , swarmDataPathPort = Nothing
  , swarmDefaultAddrPool = Nothing
  , swarmSubnetSize = Nothing
  , swarmJoinTokens = Nothing
  }

-- ** SwarmAllOf
-- | SwarmAllOf
data SwarmAllOf = SwarmAllOf
  { swarmAllOfJoinTokens :: !(Maybe JoinTokens) -- ^ "JoinTokens"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmAllOf
instance A.FromJSON SwarmAllOf where
  parseJSON = A.withObject "SwarmAllOf" $ \o ->
    SwarmAllOf
      <$> (o .:? "JoinTokens")

-- | ToJSON SwarmAllOf
instance A.ToJSON SwarmAllOf where
  toJSON SwarmAllOf {..} =
   _omitNulls
      [ "JoinTokens" .= swarmAllOfJoinTokens
      ]


-- | Construct a value of type 'SwarmAllOf' (by applying it's required fields, if any)
mkSwarmAllOf
  :: SwarmAllOf
mkSwarmAllOf =
  SwarmAllOf
  { swarmAllOfJoinTokens = Nothing
  }

-- ** SwarmInfo
-- | SwarmInfo
-- Represents generic information about swarm. 
data SwarmInfo = SwarmInfo
  { swarmInfoNodeId :: !(Maybe Text) -- ^ "NodeID" - Unique identifier of for this node in the swarm.
  , swarmInfoNodeAddr :: !(Maybe Text) -- ^ "NodeAddr" - IP address at which this node can be reached by other nodes in the swarm. 
  , swarmInfoLocalNodeState :: !(Maybe LocalNodeState) -- ^ "LocalNodeState"
  , swarmInfoControlAvailable :: !(Maybe Bool) -- ^ "ControlAvailable"
  , swarmInfoError :: !(Maybe Text) -- ^ "Error"
  , swarmInfoRemoteManagers :: !(Maybe [PeerNode]) -- ^ "RemoteManagers" - List of ID&#39;s and addresses of other managers in the swarm. 
  , swarmInfoNodes :: !(Maybe Int) -- ^ "Nodes" - Total number of nodes in the swarm.
  , swarmInfoManagers :: !(Maybe Int) -- ^ "Managers" - Total number of managers in the swarm.
  , swarmInfoCluster :: !(Maybe ClusterInfo) -- ^ "Cluster"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmInfo
instance A.FromJSON SwarmInfo where
  parseJSON = A.withObject "SwarmInfo" $ \o ->
    SwarmInfo
      <$> (o .:? "NodeID")
      <*> (o .:? "NodeAddr")
      <*> (o .:? "LocalNodeState")
      <*> (o .:? "ControlAvailable")
      <*> (o .:? "Error")
      <*> (o .:? "RemoteManagers")
      <*> (o .:? "Nodes")
      <*> (o .:? "Managers")
      <*> (o .:? "Cluster")

-- | ToJSON SwarmInfo
instance A.ToJSON SwarmInfo where
  toJSON SwarmInfo {..} =
   _omitNulls
      [ "NodeID" .= swarmInfoNodeId
      , "NodeAddr" .= swarmInfoNodeAddr
      , "LocalNodeState" .= swarmInfoLocalNodeState
      , "ControlAvailable" .= swarmInfoControlAvailable
      , "Error" .= swarmInfoError
      , "RemoteManagers" .= swarmInfoRemoteManagers
      , "Nodes" .= swarmInfoNodes
      , "Managers" .= swarmInfoManagers
      , "Cluster" .= swarmInfoCluster
      ]


-- | Construct a value of type 'SwarmInfo' (by applying it's required fields, if any)
mkSwarmInfo
  :: SwarmInfo
mkSwarmInfo =
  SwarmInfo
  { swarmInfoNodeId = Nothing
  , swarmInfoNodeAddr = Nothing
  , swarmInfoLocalNodeState = Nothing
  , swarmInfoControlAvailable = Nothing
  , swarmInfoError = Nothing
  , swarmInfoRemoteManagers = Nothing
  , swarmInfoNodes = Nothing
  , swarmInfoManagers = Nothing
  , swarmInfoCluster = Nothing
  }

-- ** SwarmInitRequest
-- | SwarmInitRequest
-- SwarmInitRequest
-- 
data SwarmInitRequest = SwarmInitRequest
  { swarmInitRequestListenAddr :: !(Maybe Text) -- ^ "ListenAddr" - Listen address used for inter-manager communication, as well as determining the networking interface used for the VXLAN Tunnel Endpoint (VTEP). This can either be an address/port combination in the form &#x60;192.168.1.1:4567&#x60;, or an interface followed by a port number, like &#x60;eth0:4567&#x60;. If the port number is omitted, the default swarm listening port is used. 
  , swarmInitRequestAdvertiseAddr :: !(Maybe Text) -- ^ "AdvertiseAddr" - Externally reachable address advertised to other nodes. This can either be an address/port combination in the form &#x60;192.168.1.1:4567&#x60;, or an interface followed by a port number, like &#x60;eth0:4567&#x60;. If the port number is omitted, the port number from the listen address is used. If &#x60;AdvertiseAddr&#x60; is not specified, it will be automatically detected when possible. 
  , swarmInitRequestDataPathAddr :: !(Maybe Text) -- ^ "DataPathAddr" - Address or interface to use for data path traffic (format: &#x60;&lt;ip|interface&gt;&#x60;), for example,  &#x60;192.168.1.1&#x60;, or an interface, like &#x60;eth0&#x60;. If &#x60;DataPathAddr&#x60; is unspecified, the same address as &#x60;AdvertiseAddr&#x60; is used.  The &#x60;DataPathAddr&#x60; specifies the address that global scope network drivers will publish towards other  nodes in order to reach the containers running on this node. Using this parameter it is possible to separate the container data traffic from the management traffic of the cluster. 
  , swarmInitRequestDataPathPort :: !(Maybe Int) -- ^ "DataPathPort" - DataPathPort specifies the data path port number for data traffic. Acceptable port range is 1024 to 49151. if no port is set or is set to 0, default port 4789 will be used. 
  , swarmInitRequestDefaultAddrPool :: !(Maybe [Text]) -- ^ "DefaultAddrPool" - Default Address Pool specifies default subnet pools for global scope networks. 
  , swarmInitRequestForceNewCluster :: !(Maybe Bool) -- ^ "ForceNewCluster" - Force creation of a new swarm.
  , swarmInitRequestSubnetSize :: !(Maybe Int) -- ^ "SubnetSize" - SubnetSize specifies the subnet size of the networks created from the default subnet pool. 
  , swarmInitRequestSpec :: !(Maybe SwarmSpec) -- ^ "Spec"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmInitRequest
instance A.FromJSON SwarmInitRequest where
  parseJSON = A.withObject "SwarmInitRequest" $ \o ->
    SwarmInitRequest
      <$> (o .:? "ListenAddr")
      <*> (o .:? "AdvertiseAddr")
      <*> (o .:? "DataPathAddr")
      <*> (o .:? "DataPathPort")
      <*> (o .:? "DefaultAddrPool")
      <*> (o .:? "ForceNewCluster")
      <*> (o .:? "SubnetSize")
      <*> (o .:? "Spec")

-- | ToJSON SwarmInitRequest
instance A.ToJSON SwarmInitRequest where
  toJSON SwarmInitRequest {..} =
   _omitNulls
      [ "ListenAddr" .= swarmInitRequestListenAddr
      , "AdvertiseAddr" .= swarmInitRequestAdvertiseAddr
      , "DataPathAddr" .= swarmInitRequestDataPathAddr
      , "DataPathPort" .= swarmInitRequestDataPathPort
      , "DefaultAddrPool" .= swarmInitRequestDefaultAddrPool
      , "ForceNewCluster" .= swarmInitRequestForceNewCluster
      , "SubnetSize" .= swarmInitRequestSubnetSize
      , "Spec" .= swarmInitRequestSpec
      ]


-- | Construct a value of type 'SwarmInitRequest' (by applying it's required fields, if any)
mkSwarmInitRequest
  :: SwarmInitRequest
mkSwarmInitRequest =
  SwarmInitRequest
  { swarmInitRequestListenAddr = Nothing
  , swarmInitRequestAdvertiseAddr = Nothing
  , swarmInitRequestDataPathAddr = Nothing
  , swarmInitRequestDataPathPort = Nothing
  , swarmInitRequestDefaultAddrPool = Nothing
  , swarmInitRequestForceNewCluster = Nothing
  , swarmInitRequestSubnetSize = Nothing
  , swarmInitRequestSpec = Nothing
  }

-- ** SwarmJoinRequest
-- | SwarmJoinRequest
-- SwarmJoinRequest
-- 
data SwarmJoinRequest = SwarmJoinRequest
  { swarmJoinRequestListenAddr :: !(Maybe Text) -- ^ "ListenAddr" - Listen address used for inter-manager communication if the node gets promoted to manager, as well as determining the networking interface used for the VXLAN Tunnel Endpoint (VTEP). 
  , swarmJoinRequestAdvertiseAddr :: !(Maybe Text) -- ^ "AdvertiseAddr" - Externally reachable address advertised to other nodes. This can either be an address/port combination in the form &#x60;192.168.1.1:4567&#x60;, or an interface followed by a port number, like &#x60;eth0:4567&#x60;. If the port number is omitted, the port number from the listen address is used. If &#x60;AdvertiseAddr&#x60; is not specified, it will be automatically detected when possible. 
  , swarmJoinRequestDataPathAddr :: !(Maybe Text) -- ^ "DataPathAddr" - Address or interface to use for data path traffic (format: &#x60;&lt;ip|interface&gt;&#x60;), for example,  &#x60;192.168.1.1&#x60;, or an interface, like &#x60;eth0&#x60;. If &#x60;DataPathAddr&#x60; is unspecified, the same addres as &#x60;AdvertiseAddr&#x60; is used.  The &#x60;DataPathAddr&#x60; specifies the address that global scope network drivers will publish towards other nodes in order to reach the containers running on this node. Using this parameter it is possible to separate the container data traffic from the management traffic of the cluster. 
  , swarmJoinRequestRemoteAddrs :: !(Maybe [Text]) -- ^ "RemoteAddrs" - Addresses of manager nodes already participating in the swarm. 
  , swarmJoinRequestJoinToken :: !(Maybe Text) -- ^ "JoinToken" - Secret token for joining this swarm.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmJoinRequest
instance A.FromJSON SwarmJoinRequest where
  parseJSON = A.withObject "SwarmJoinRequest" $ \o ->
    SwarmJoinRequest
      <$> (o .:? "ListenAddr")
      <*> (o .:? "AdvertiseAddr")
      <*> (o .:? "DataPathAddr")
      <*> (o .:? "RemoteAddrs")
      <*> (o .:? "JoinToken")

-- | ToJSON SwarmJoinRequest
instance A.ToJSON SwarmJoinRequest where
  toJSON SwarmJoinRequest {..} =
   _omitNulls
      [ "ListenAddr" .= swarmJoinRequestListenAddr
      , "AdvertiseAddr" .= swarmJoinRequestAdvertiseAddr
      , "DataPathAddr" .= swarmJoinRequestDataPathAddr
      , "RemoteAddrs" .= swarmJoinRequestRemoteAddrs
      , "JoinToken" .= swarmJoinRequestJoinToken
      ]


-- | Construct a value of type 'SwarmJoinRequest' (by applying it's required fields, if any)
mkSwarmJoinRequest
  :: SwarmJoinRequest
mkSwarmJoinRequest =
  SwarmJoinRequest
  { swarmJoinRequestListenAddr = Nothing
  , swarmJoinRequestAdvertiseAddr = Nothing
  , swarmJoinRequestDataPathAddr = Nothing
  , swarmJoinRequestRemoteAddrs = Nothing
  , swarmJoinRequestJoinToken = Nothing
  }

-- ** SwarmSpec
-- | SwarmSpec
-- User modifiable swarm configuration.
data SwarmSpec = SwarmSpec
  { swarmSpecName :: !(Maybe Text) -- ^ "Name" - Name of the swarm.
  , swarmSpecLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , swarmSpecOrchestration :: !(Maybe SwarmSpecOrchestration) -- ^ "Orchestration"
  , swarmSpecRaft :: !(Maybe SwarmSpecRaft) -- ^ "Raft"
  , swarmSpecDispatcher :: !(Maybe SwarmSpecDispatcher) -- ^ "Dispatcher"
  , swarmSpecCaConfig :: !(Maybe SwarmSpecCAConfig) -- ^ "CAConfig"
  , swarmSpecEncryptionConfig :: !(Maybe SwarmSpecEncryptionConfig) -- ^ "EncryptionConfig"
  , swarmSpecTaskDefaults :: !(Maybe SwarmSpecTaskDefaults) -- ^ "TaskDefaults"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpec
instance A.FromJSON SwarmSpec where
  parseJSON = A.withObject "SwarmSpec" $ \o ->
    SwarmSpec
      <$> (o .:? "Name")
      <*> (o .:? "Labels")
      <*> (o .:? "Orchestration")
      <*> (o .:? "Raft")
      <*> (o .:? "Dispatcher")
      <*> (o .:? "CAConfig")
      <*> (o .:? "EncryptionConfig")
      <*> (o .:? "TaskDefaults")

-- | ToJSON SwarmSpec
instance A.ToJSON SwarmSpec where
  toJSON SwarmSpec {..} =
   _omitNulls
      [ "Name" .= swarmSpecName
      , "Labels" .= swarmSpecLabels
      , "Orchestration" .= swarmSpecOrchestration
      , "Raft" .= swarmSpecRaft
      , "Dispatcher" .= swarmSpecDispatcher
      , "CAConfig" .= swarmSpecCaConfig
      , "EncryptionConfig" .= swarmSpecEncryptionConfig
      , "TaskDefaults" .= swarmSpecTaskDefaults
      ]


-- | Construct a value of type 'SwarmSpec' (by applying it's required fields, if any)
mkSwarmSpec
  :: SwarmSpec
mkSwarmSpec =
  SwarmSpec
  { swarmSpecName = Nothing
  , swarmSpecLabels = Nothing
  , swarmSpecOrchestration = Nothing
  , swarmSpecRaft = Nothing
  , swarmSpecDispatcher = Nothing
  , swarmSpecCaConfig = Nothing
  , swarmSpecEncryptionConfig = Nothing
  , swarmSpecTaskDefaults = Nothing
  }

-- ** SwarmSpecCAConfig
-- | SwarmSpecCAConfig
-- CA configuration.
data SwarmSpecCAConfig = SwarmSpecCAConfig
  { swarmSpecCAConfigNodeCertExpiry :: !(Maybe Integer) -- ^ "NodeCertExpiry" - The duration node certificates are issued for.
  , swarmSpecCAConfigExternalCas :: !(Maybe [SwarmSpecCAConfigExternalCAs]) -- ^ "ExternalCAs" - Configuration for forwarding signing requests to an external certificate authority. 
  , swarmSpecCAConfigSigningCaCert :: !(Maybe Text) -- ^ "SigningCACert" - The desired signing CA certificate for all swarm node TLS leaf certificates, in PEM format. 
  , swarmSpecCAConfigSigningCaKey :: !(Maybe Text) -- ^ "SigningCAKey" - The desired signing CA key for all swarm node TLS leaf certificates, in PEM format. 
  , swarmSpecCAConfigForceRotate :: !(Maybe Int) -- ^ "ForceRotate" - An integer whose purpose is to force swarm to generate a new signing CA certificate and key, if none have been specified in &#x60;SigningCACert&#x60; and &#x60;SigningCAKey&#x60; 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpecCAConfig
instance A.FromJSON SwarmSpecCAConfig where
  parseJSON = A.withObject "SwarmSpecCAConfig" $ \o ->
    SwarmSpecCAConfig
      <$> (o .:? "NodeCertExpiry")
      <*> (o .:? "ExternalCAs")
      <*> (o .:? "SigningCACert")
      <*> (o .:? "SigningCAKey")
      <*> (o .:? "ForceRotate")

-- | ToJSON SwarmSpecCAConfig
instance A.ToJSON SwarmSpecCAConfig where
  toJSON SwarmSpecCAConfig {..} =
   _omitNulls
      [ "NodeCertExpiry" .= swarmSpecCAConfigNodeCertExpiry
      , "ExternalCAs" .= swarmSpecCAConfigExternalCas
      , "SigningCACert" .= swarmSpecCAConfigSigningCaCert
      , "SigningCAKey" .= swarmSpecCAConfigSigningCaKey
      , "ForceRotate" .= swarmSpecCAConfigForceRotate
      ]


-- | Construct a value of type 'SwarmSpecCAConfig' (by applying it's required fields, if any)
mkSwarmSpecCAConfig
  :: SwarmSpecCAConfig
mkSwarmSpecCAConfig =
  SwarmSpecCAConfig
  { swarmSpecCAConfigNodeCertExpiry = Nothing
  , swarmSpecCAConfigExternalCas = Nothing
  , swarmSpecCAConfigSigningCaCert = Nothing
  , swarmSpecCAConfigSigningCaKey = Nothing
  , swarmSpecCAConfigForceRotate = Nothing
  }

-- ** SwarmSpecCAConfigExternalCAs
-- | SwarmSpecCAConfigExternalCAs
data SwarmSpecCAConfigExternalCAs = SwarmSpecCAConfigExternalCAs
  { swarmSpecCAConfigExternalCAsProtocol :: !(Maybe E'Protocol) -- ^ "Protocol" - Protocol for communication with the external CA (currently only &#x60;cfssl&#x60; is supported). 
  , swarmSpecCAConfigExternalCAsUrl :: !(Maybe Text) -- ^ "URL" - URL where certificate signing requests should be sent. 
  , swarmSpecCAConfigExternalCAsOptions :: !(Maybe (Map.Map String Text)) -- ^ "Options" - An object with key/value pairs that are interpreted as protocol-specific options for the external CA driver. 
  , swarmSpecCAConfigExternalCAsCaCert :: !(Maybe Text) -- ^ "CACert" - The root CA certificate (in PEM format) this external CA uses to issue TLS certificates (assumed to be to the current swarm root CA certificate if not provided). 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpecCAConfigExternalCAs
instance A.FromJSON SwarmSpecCAConfigExternalCAs where
  parseJSON = A.withObject "SwarmSpecCAConfigExternalCAs" $ \o ->
    SwarmSpecCAConfigExternalCAs
      <$> (o .:? "Protocol")
      <*> (o .:? "URL")
      <*> (o .:? "Options")
      <*> (o .:? "CACert")

-- | ToJSON SwarmSpecCAConfigExternalCAs
instance A.ToJSON SwarmSpecCAConfigExternalCAs where
  toJSON SwarmSpecCAConfigExternalCAs {..} =
   _omitNulls
      [ "Protocol" .= swarmSpecCAConfigExternalCAsProtocol
      , "URL" .= swarmSpecCAConfigExternalCAsUrl
      , "Options" .= swarmSpecCAConfigExternalCAsOptions
      , "CACert" .= swarmSpecCAConfigExternalCAsCaCert
      ]


-- | Construct a value of type 'SwarmSpecCAConfigExternalCAs' (by applying it's required fields, if any)
mkSwarmSpecCAConfigExternalCAs
  :: SwarmSpecCAConfigExternalCAs
mkSwarmSpecCAConfigExternalCAs =
  SwarmSpecCAConfigExternalCAs
  { swarmSpecCAConfigExternalCAsProtocol = Nothing
  , swarmSpecCAConfigExternalCAsUrl = Nothing
  , swarmSpecCAConfigExternalCAsOptions = Nothing
  , swarmSpecCAConfigExternalCAsCaCert = Nothing
  }

-- ** SwarmSpecDispatcher
-- | SwarmSpecDispatcher
-- Dispatcher configuration.
data SwarmSpecDispatcher = SwarmSpecDispatcher
  { swarmSpecDispatcherHeartbeatPeriod :: !(Maybe Integer) -- ^ "HeartbeatPeriod" - The delay for an agent to send a heartbeat to the dispatcher. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpecDispatcher
instance A.FromJSON SwarmSpecDispatcher where
  parseJSON = A.withObject "SwarmSpecDispatcher" $ \o ->
    SwarmSpecDispatcher
      <$> (o .:? "HeartbeatPeriod")

-- | ToJSON SwarmSpecDispatcher
instance A.ToJSON SwarmSpecDispatcher where
  toJSON SwarmSpecDispatcher {..} =
   _omitNulls
      [ "HeartbeatPeriod" .= swarmSpecDispatcherHeartbeatPeriod
      ]


-- | Construct a value of type 'SwarmSpecDispatcher' (by applying it's required fields, if any)
mkSwarmSpecDispatcher
  :: SwarmSpecDispatcher
mkSwarmSpecDispatcher =
  SwarmSpecDispatcher
  { swarmSpecDispatcherHeartbeatPeriod = Nothing
  }

-- ** SwarmSpecEncryptionConfig
-- | SwarmSpecEncryptionConfig
-- Parameters related to encryption-at-rest.
data SwarmSpecEncryptionConfig = SwarmSpecEncryptionConfig
  { swarmSpecEncryptionConfigAutoLockManagers :: !(Maybe Bool) -- ^ "AutoLockManagers" - If set, generate a key and use it to lock data stored on the managers. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpecEncryptionConfig
instance A.FromJSON SwarmSpecEncryptionConfig where
  parseJSON = A.withObject "SwarmSpecEncryptionConfig" $ \o ->
    SwarmSpecEncryptionConfig
      <$> (o .:? "AutoLockManagers")

-- | ToJSON SwarmSpecEncryptionConfig
instance A.ToJSON SwarmSpecEncryptionConfig where
  toJSON SwarmSpecEncryptionConfig {..} =
   _omitNulls
      [ "AutoLockManagers" .= swarmSpecEncryptionConfigAutoLockManagers
      ]


-- | Construct a value of type 'SwarmSpecEncryptionConfig' (by applying it's required fields, if any)
mkSwarmSpecEncryptionConfig
  :: SwarmSpecEncryptionConfig
mkSwarmSpecEncryptionConfig =
  SwarmSpecEncryptionConfig
  { swarmSpecEncryptionConfigAutoLockManagers = Nothing
  }

-- ** SwarmSpecOrchestration
-- | SwarmSpecOrchestration
-- Orchestration configuration.
data SwarmSpecOrchestration = SwarmSpecOrchestration
  { swarmSpecOrchestrationTaskHistoryRetentionLimit :: !(Maybe Integer) -- ^ "TaskHistoryRetentionLimit" - The number of historic tasks to keep per instance or node. If negative, never remove completed or failed tasks. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpecOrchestration
instance A.FromJSON SwarmSpecOrchestration where
  parseJSON = A.withObject "SwarmSpecOrchestration" $ \o ->
    SwarmSpecOrchestration
      <$> (o .:? "TaskHistoryRetentionLimit")

-- | ToJSON SwarmSpecOrchestration
instance A.ToJSON SwarmSpecOrchestration where
  toJSON SwarmSpecOrchestration {..} =
   _omitNulls
      [ "TaskHistoryRetentionLimit" .= swarmSpecOrchestrationTaskHistoryRetentionLimit
      ]


-- | Construct a value of type 'SwarmSpecOrchestration' (by applying it's required fields, if any)
mkSwarmSpecOrchestration
  :: SwarmSpecOrchestration
mkSwarmSpecOrchestration =
  SwarmSpecOrchestration
  { swarmSpecOrchestrationTaskHistoryRetentionLimit = Nothing
  }

-- ** SwarmSpecRaft
-- | SwarmSpecRaft
-- Raft configuration.
data SwarmSpecRaft = SwarmSpecRaft
  { swarmSpecRaftSnapshotInterval :: !(Maybe Int) -- ^ "SnapshotInterval" - The number of log entries between snapshots.
  , swarmSpecRaftKeepOldSnapshots :: !(Maybe Int) -- ^ "KeepOldSnapshots" - The number of snapshots to keep beyond the current snapshot. 
  , swarmSpecRaftLogEntriesForSlowFollowers :: !(Maybe Int) -- ^ "LogEntriesForSlowFollowers" - The number of log entries to keep around to sync up slow followers after a snapshot is created. 
  , swarmSpecRaftElectionTick :: !(Maybe Int) -- ^ "ElectionTick" - The number of ticks that a follower will wait for a message from the leader before becoming a candidate and starting an election. &#x60;ElectionTick&#x60; must be greater than &#x60;HeartbeatTick&#x60;.  A tick currently defaults to one second, so these translate directly to seconds currently, but this is NOT guaranteed. 
  , swarmSpecRaftHeartbeatTick :: !(Maybe Int) -- ^ "HeartbeatTick" - The number of ticks between heartbeats. Every HeartbeatTick ticks, the leader will send a heartbeat to the followers.  A tick currently defaults to one second, so these translate directly to seconds currently, but this is NOT guaranteed. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpecRaft
instance A.FromJSON SwarmSpecRaft where
  parseJSON = A.withObject "SwarmSpecRaft" $ \o ->
    SwarmSpecRaft
      <$> (o .:? "SnapshotInterval")
      <*> (o .:? "KeepOldSnapshots")
      <*> (o .:? "LogEntriesForSlowFollowers")
      <*> (o .:? "ElectionTick")
      <*> (o .:? "HeartbeatTick")

-- | ToJSON SwarmSpecRaft
instance A.ToJSON SwarmSpecRaft where
  toJSON SwarmSpecRaft {..} =
   _omitNulls
      [ "SnapshotInterval" .= swarmSpecRaftSnapshotInterval
      , "KeepOldSnapshots" .= swarmSpecRaftKeepOldSnapshots
      , "LogEntriesForSlowFollowers" .= swarmSpecRaftLogEntriesForSlowFollowers
      , "ElectionTick" .= swarmSpecRaftElectionTick
      , "HeartbeatTick" .= swarmSpecRaftHeartbeatTick
      ]


-- | Construct a value of type 'SwarmSpecRaft' (by applying it's required fields, if any)
mkSwarmSpecRaft
  :: SwarmSpecRaft
mkSwarmSpecRaft =
  SwarmSpecRaft
  { swarmSpecRaftSnapshotInterval = Nothing
  , swarmSpecRaftKeepOldSnapshots = Nothing
  , swarmSpecRaftLogEntriesForSlowFollowers = Nothing
  , swarmSpecRaftElectionTick = Nothing
  , swarmSpecRaftHeartbeatTick = Nothing
  }

-- ** SwarmSpecTaskDefaults
-- | SwarmSpecTaskDefaults
-- Defaults for creating tasks in this cluster.
data SwarmSpecTaskDefaults = SwarmSpecTaskDefaults
  { swarmSpecTaskDefaultsLogDriver :: !(Maybe SwarmSpecTaskDefaultsLogDriver) -- ^ "LogDriver"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpecTaskDefaults
instance A.FromJSON SwarmSpecTaskDefaults where
  parseJSON = A.withObject "SwarmSpecTaskDefaults" $ \o ->
    SwarmSpecTaskDefaults
      <$> (o .:? "LogDriver")

-- | ToJSON SwarmSpecTaskDefaults
instance A.ToJSON SwarmSpecTaskDefaults where
  toJSON SwarmSpecTaskDefaults {..} =
   _omitNulls
      [ "LogDriver" .= swarmSpecTaskDefaultsLogDriver
      ]


-- | Construct a value of type 'SwarmSpecTaskDefaults' (by applying it's required fields, if any)
mkSwarmSpecTaskDefaults
  :: SwarmSpecTaskDefaults
mkSwarmSpecTaskDefaults =
  SwarmSpecTaskDefaults
  { swarmSpecTaskDefaultsLogDriver = Nothing
  }

-- ** SwarmSpecTaskDefaultsLogDriver
-- | SwarmSpecTaskDefaultsLogDriver
-- The log driver to use for tasks created in the orchestrator if unspecified by a service.  Updating this value only affects new tasks. Existing tasks continue to use their previously configured log driver until recreated. 
data SwarmSpecTaskDefaultsLogDriver = SwarmSpecTaskDefaultsLogDriver
  { swarmSpecTaskDefaultsLogDriverName :: !(Maybe Text) -- ^ "Name" - The log driver to use as a default for new tasks. 
  , swarmSpecTaskDefaultsLogDriverOptions :: !(Maybe (Map.Map String Text)) -- ^ "Options" - Driver-specific options for the selectd log driver, specified as key/value pairs. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmSpecTaskDefaultsLogDriver
instance A.FromJSON SwarmSpecTaskDefaultsLogDriver where
  parseJSON = A.withObject "SwarmSpecTaskDefaultsLogDriver" $ \o ->
    SwarmSpecTaskDefaultsLogDriver
      <$> (o .:? "Name")
      <*> (o .:? "Options")

-- | ToJSON SwarmSpecTaskDefaultsLogDriver
instance A.ToJSON SwarmSpecTaskDefaultsLogDriver where
  toJSON SwarmSpecTaskDefaultsLogDriver {..} =
   _omitNulls
      [ "Name" .= swarmSpecTaskDefaultsLogDriverName
      , "Options" .= swarmSpecTaskDefaultsLogDriverOptions
      ]


-- | Construct a value of type 'SwarmSpecTaskDefaultsLogDriver' (by applying it's required fields, if any)
mkSwarmSpecTaskDefaultsLogDriver
  :: SwarmSpecTaskDefaultsLogDriver
mkSwarmSpecTaskDefaultsLogDriver =
  SwarmSpecTaskDefaultsLogDriver
  { swarmSpecTaskDefaultsLogDriverName = Nothing
  , swarmSpecTaskDefaultsLogDriverOptions = Nothing
  }

-- ** SwarmUnlockRequest
-- | SwarmUnlockRequest
-- SwarmUnlockRequest
-- 
data SwarmUnlockRequest = SwarmUnlockRequest
  { swarmUnlockRequestUnlockKey :: !(Maybe Text) -- ^ "UnlockKey" - The swarm&#39;s unlock key.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SwarmUnlockRequest
instance A.FromJSON SwarmUnlockRequest where
  parseJSON = A.withObject "SwarmUnlockRequest" $ \o ->
    SwarmUnlockRequest
      <$> (o .:? "UnlockKey")

-- | ToJSON SwarmUnlockRequest
instance A.ToJSON SwarmUnlockRequest where
  toJSON SwarmUnlockRequest {..} =
   _omitNulls
      [ "UnlockKey" .= swarmUnlockRequestUnlockKey
      ]


-- | Construct a value of type 'SwarmUnlockRequest' (by applying it's required fields, if any)
mkSwarmUnlockRequest
  :: SwarmUnlockRequest
mkSwarmUnlockRequest =
  SwarmUnlockRequest
  { swarmUnlockRequestUnlockKey = Nothing
  }

-- ** SystemAuthResponse
-- | SystemAuthResponse
-- SystemAuthResponse
-- 
data SystemAuthResponse = SystemAuthResponse
  { systemAuthResponseStatus :: !(Text) -- ^ /Required/ "Status" - The status of the authentication
  , systemAuthResponseIdentityToken :: !(Maybe Text) -- ^ "IdentityToken" - An opaque token used to authenticate a user after a successful login
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SystemAuthResponse
instance A.FromJSON SystemAuthResponse where
  parseJSON = A.withObject "SystemAuthResponse" $ \o ->
    SystemAuthResponse
      <$> (o .:  "Status")
      <*> (o .:? "IdentityToken")

-- | ToJSON SystemAuthResponse
instance A.ToJSON SystemAuthResponse where
  toJSON SystemAuthResponse {..} =
   _omitNulls
      [ "Status" .= systemAuthResponseStatus
      , "IdentityToken" .= systemAuthResponseIdentityToken
      ]


-- | Construct a value of type 'SystemAuthResponse' (by applying it's required fields, if any)
mkSystemAuthResponse
  :: Text -- ^ 'systemAuthResponseStatus': The status of the authentication
  -> SystemAuthResponse
mkSystemAuthResponse systemAuthResponseStatus =
  SystemAuthResponse
  { systemAuthResponseStatus
  , systemAuthResponseIdentityToken = Nothing
  }

-- ** SystemDataUsageResponse
-- | SystemDataUsageResponse
-- SystemDataUsageResponse
-- 
data SystemDataUsageResponse = SystemDataUsageResponse
  { systemDataUsageResponseLayersSize :: !(Maybe Integer) -- ^ "LayersSize"
  , systemDataUsageResponseImages :: !(Maybe [ImageSummary]) -- ^ "Images"
  , systemDataUsageResponseContainers :: !(Maybe [ContainerSummary]) -- ^ "Containers"
  , systemDataUsageResponseVolumes :: !(Maybe [Volume]) -- ^ "Volumes"
  , systemDataUsageResponseBuildCache :: !(Maybe [BuildCache]) -- ^ "BuildCache"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SystemDataUsageResponse
instance A.FromJSON SystemDataUsageResponse where
  parseJSON = A.withObject "SystemDataUsageResponse" $ \o ->
    SystemDataUsageResponse
      <$> (o .:? "LayersSize")
      <*> (o .:? "Images")
      <*> (o .:? "Containers")
      <*> (o .:? "Volumes")
      <*> (o .:? "BuildCache")

-- | ToJSON SystemDataUsageResponse
instance A.ToJSON SystemDataUsageResponse where
  toJSON SystemDataUsageResponse {..} =
   _omitNulls
      [ "LayersSize" .= systemDataUsageResponseLayersSize
      , "Images" .= systemDataUsageResponseImages
      , "Containers" .= systemDataUsageResponseContainers
      , "Volumes" .= systemDataUsageResponseVolumes
      , "BuildCache" .= systemDataUsageResponseBuildCache
      ]


-- | Construct a value of type 'SystemDataUsageResponse' (by applying it's required fields, if any)
mkSystemDataUsageResponse
  :: SystemDataUsageResponse
mkSystemDataUsageResponse =
  SystemDataUsageResponse
  { systemDataUsageResponseLayersSize = Nothing
  , systemDataUsageResponseImages = Nothing
  , systemDataUsageResponseContainers = Nothing
  , systemDataUsageResponseVolumes = Nothing
  , systemDataUsageResponseBuildCache = Nothing
  }

-- ** SystemInfo
-- | SystemInfo
data SystemInfo = SystemInfo
  { systemInfoId :: !(Maybe Text) -- ^ "ID" - Unique identifier of the daemon.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Note**: The format of the ID itself is not part of the API, and &gt; should not be considered stable. 
  , systemInfoContainers :: !(Maybe Int) -- ^ "Containers" - Total number of containers on the host.
  , systemInfoContainersRunning :: !(Maybe Int) -- ^ "ContainersRunning" - Number of containers with status &#x60;\&quot;running\&quot;&#x60;. 
  , systemInfoContainersPaused :: !(Maybe Int) -- ^ "ContainersPaused" - Number of containers with status &#x60;\&quot;paused\&quot;&#x60;. 
  , systemInfoContainersStopped :: !(Maybe Int) -- ^ "ContainersStopped" - Number of containers with status &#x60;\&quot;stopped\&quot;&#x60;. 
  , systemInfoImages :: !(Maybe Int) -- ^ "Images" - Total number of images on the host.  Both _tagged_ and _untagged_ (dangling) images are counted. 
  , systemInfoDriver :: !(Maybe Text) -- ^ "Driver" - Name of the storage driver in use.
  , systemInfoDriverStatus :: !(Maybe [[Text]]) -- ^ "DriverStatus" - Information specific to the storage driver, provided as \&quot;label\&quot; / \&quot;value\&quot; pairs.  This information is provided by the storage driver, and formatted in a way consistent with the output of &#x60;docker info&#x60; on the command line.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Note**: The information returned in this field, including the &gt; formatting of values and labels, should not be considered stable, &gt; and may change without notice. 
  , systemInfoDockerRootDir :: !(Maybe Text) -- ^ "DockerRootDir" - Root directory of persistent Docker state.  Defaults to &#x60;/var/lib/docker&#x60; on Linux, and &#x60;C:\\ProgramData\\docker&#x60; on Windows. 
  , systemInfoPlugins :: !(Maybe PluginsInfo) -- ^ "Plugins"
  , systemInfoMemoryLimit :: !(Maybe Bool) -- ^ "MemoryLimit" - Indicates if the host has memory limit support enabled.
  , systemInfoSwapLimit :: !(Maybe Bool) -- ^ "SwapLimit" - Indicates if the host has memory swap limit support enabled.
  , systemInfoKernelMemory :: !(Maybe Bool) -- ^ "KernelMemory" - Indicates if the host has kernel memory limit support enabled.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Deprecated**: This field is deprecated as the kernel 5.4 deprecated &gt; &#x60;kmem.limit_in_bytes&#x60;. 
  , systemInfoKernelMemoryTcp :: !(Maybe Bool) -- ^ "KernelMemoryTCP" - Indicates if the host has kernel memory TCP limit support enabled.  Kernel memory TCP limits are not supported when using cgroups v2, which does not support the corresponding &#x60;memory.kmem.tcp.limit_in_bytes&#x60; cgroup. 
  , systemInfoCpuCfsPeriod :: !(Maybe Bool) -- ^ "CpuCfsPeriod" - Indicates if CPU CFS(Completely Fair Scheduler) period is supported by the host. 
  , systemInfoCpuCfsQuota :: !(Maybe Bool) -- ^ "CpuCfsQuota" - Indicates if CPU CFS(Completely Fair Scheduler) quota is supported by the host. 
  , systemInfoCpuShares :: !(Maybe Bool) -- ^ "CPUShares" - Indicates if CPU Shares limiting is supported by the host. 
  , systemInfoCpuSet :: !(Maybe Bool) -- ^ "CPUSet" - Indicates if CPUsets (cpuset.cpus, cpuset.mems) are supported by the host.  See [cpuset(7)](https://www.kernel.org/doc/Documentation/cgroup-v1/cpusets.txt) 
  , systemInfoPidsLimit :: !(Maybe Bool) -- ^ "PidsLimit" - Indicates if the host kernel has PID limit support enabled.
  , systemInfoOomKillDisable :: !(Maybe Bool) -- ^ "OomKillDisable" - Indicates if OOM killer disable is supported on the host.
  , systemInfoIpv4Forwarding :: !(Maybe Bool) -- ^ "IPv4Forwarding" - Indicates IPv4 forwarding is enabled.
  , systemInfoBridgeNfIptables :: !(Maybe Bool) -- ^ "BridgeNfIptables" - Indicates if &#x60;bridge-nf-call-iptables&#x60; is available on the host.
  , systemInfoBridgeNfIp6tables :: !(Maybe Bool) -- ^ "BridgeNfIp6tables" - Indicates if &#x60;bridge-nf-call-ip6tables&#x60; is available on the host.
  , systemInfoDebug :: !(Maybe Bool) -- ^ "Debug" - Indicates if the daemon is running in debug-mode / with debug-level logging enabled. 
  , systemInfoNfd :: !(Maybe Int) -- ^ "NFd" - The total number of file Descriptors in use by the daemon process.  This information is only returned if debug-mode is enabled. 
  , systemInfoNGoroutines :: !(Maybe Int) -- ^ "NGoroutines" - The  number of goroutines that currently exist.  This information is only returned if debug-mode is enabled. 
  , systemInfoSystemTime :: !(Maybe Text) -- ^ "SystemTime" - Current system-time in [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds. 
  , systemInfoLoggingDriver :: !(Maybe Text) -- ^ "LoggingDriver" - The logging driver to use as a default for new containers. 
  , systemInfoCgroupDriver :: !(Maybe E'CgroupDriver) -- ^ "CgroupDriver" - The driver to use for managing cgroups. 
  , systemInfoCgroupVersion :: !(Maybe E'CgroupVersion) -- ^ "CgroupVersion" - The version of the cgroup. 
  , systemInfoNEventsListener :: !(Maybe Int) -- ^ "NEventsListener" - Number of event listeners subscribed.
  , systemInfoKernelVersion :: !(Maybe Text) -- ^ "KernelVersion" - Kernel version of the host.  On Linux, this information obtained from &#x60;uname&#x60;. On Windows this information is queried from the &lt;kbd&gt;HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\&lt;/kbd&gt; registry value, for example _\&quot;10.0 14393 (14393.1198.amd64fre.rs1_release_sec.170427-1353)\&quot;_. 
  , systemInfoOperatingSystem :: !(Maybe Text) -- ^ "OperatingSystem" - Name of the host&#39;s operating system, for example: \&quot;Ubuntu 16.04.2 LTS\&quot; or \&quot;Windows Server 2016 Datacenter\&quot; 
  , systemInfoOsVersion :: !(Maybe Text) -- ^ "OSVersion" - Version of the host&#39;s operating system  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Note**: The information returned in this field, including its &gt; very existence, and the formatting of values, should not be considered &gt; stable, and may change without notice. 
  , systemInfoOsType :: !(Maybe Text) -- ^ "OSType" - Generic type of the operating system of the host, as returned by the Go runtime (&#x60;GOOS&#x60;).  Currently returned values are \&quot;linux\&quot; and \&quot;windows\&quot;. A full list of possible values can be found in the [Go documentation](https://golang.org/doc/install/source#environment). 
  , systemInfoArchitecture :: !(Maybe Text) -- ^ "Architecture" - Hardware architecture of the host, as returned by the Go runtime (&#x60;GOARCH&#x60;).  A full list of possible values can be found in the [Go documentation](https://golang.org/doc/install/source#environment). 
  , systemInfoNcpu :: !(Maybe Int) -- ^ "NCPU" - The number of logical CPUs usable by the daemon.  The number of available CPUs is checked by querying the operating system when the daemon starts. Changes to operating system CPU allocation after the daemon is started are not reflected. 
  , systemInfoMemTotal :: !(Maybe Integer) -- ^ "MemTotal" - Total amount of physical memory available on the host, in bytes. 
  , systemInfoIndexServerAddress :: !(Maybe Text) -- ^ "IndexServerAddress" - Address / URL of the index server that is used for image search, and as a default for user authentication for Docker Hub and Docker Cloud. 
  , systemInfoRegistryConfig :: !(Maybe RegistryServiceConfig) -- ^ "RegistryConfig"
  , systemInfoGenericResources :: !(Maybe [A.Value]) -- ^ "GenericResources" - User-defined resources can be either Integer resources (e.g, &#x60;SSD&#x3D;3&#x60;) or String resources (e.g, &#x60;GPU&#x3D;UUID1&#x60;). 
  , systemInfoHttpProxy :: !(Maybe Text) -- ^ "HttpProxy" - HTTP-proxy configured for the daemon. This value is obtained from the [&#x60;HTTP_PROXY&#x60;](https://www.gnu.org/software/wget/manual/html_node/Proxies.html) environment variable. Credentials ([user info component](https://tools.ietf.org/html/rfc3986#section-3.2.1)) in the proxy URL are masked in the API response.  Containers do not automatically inherit this configuration. 
  , systemInfoHttpsProxy :: !(Maybe Text) -- ^ "HttpsProxy" - HTTPS-proxy configured for the daemon. This value is obtained from the [&#x60;HTTPS_PROXY&#x60;](https://www.gnu.org/software/wget/manual/html_node/Proxies.html) environment variable. Credentials ([user info component](https://tools.ietf.org/html/rfc3986#section-3.2.1)) in the proxy URL are masked in the API response.  Containers do not automatically inherit this configuration. 
  , systemInfoNoProxy :: !(Maybe Text) -- ^ "NoProxy" - Comma-separated list of domain extensions for which no proxy should be used. This value is obtained from the [&#x60;NO_PROXY&#x60;](https://www.gnu.org/software/wget/manual/html_node/Proxies.html) environment variable.  Containers do not automatically inherit this configuration. 
  , systemInfoName :: !(Maybe Text) -- ^ "Name" - Hostname of the host.
  , systemInfoLabels :: !(Maybe [Text]) -- ^ "Labels" - User-defined labels (key/value metadata) as set on the daemon.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Note**: When part of a Swarm, nodes can both have _daemon_ labels, &gt; set through the daemon configuration, and _node_ labels, set from a &gt; manager node in the Swarm. Node labels are not included in this &gt; field. Node labels can be retrieved using the &#x60;/nodes/(id)&#x60; endpoint &gt; on a manager node in the Swarm. 
  , systemInfoExperimentalBuild :: !(Maybe Bool) -- ^ "ExperimentalBuild" - Indicates if experimental features are enabled on the daemon. 
  , systemInfoServerVersion :: !(Maybe Text) -- ^ "ServerVersion" - Version string of the daemon.  &gt; **Note**: the [standalone Swarm API](/swarm/swarm-api/) &gt; returns the Swarm version instead of the daemon  version, for example &gt; &#x60;swarm/1.2.8&#x60;. 
  , systemInfoClusterStore :: !(Maybe Text) -- ^ "ClusterStore" - URL of the distributed storage backend.   The storage backend is used for multihost networking (to store network and endpoint information) and by the node discovery mechanism.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Deprecated**: This field is only propagated when using standalone Swarm &gt; mode, and overlay networking using an external k/v store. Overlay &gt; networks with Swarm mode enabled use the built-in raft store, and &gt; this field will be empty. 
  , systemInfoClusterAdvertise :: !(Maybe Text) -- ^ "ClusterAdvertise" - The network endpoint that the Engine advertises for the purpose of node discovery. ClusterAdvertise is a &#x60;host:port&#x60; combination on which the daemon is reachable by other hosts.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Deprecated**: This field is only propagated when using standalone Swarm &gt; mode, and overlay networking using an external k/v store. Overlay &gt; networks with Swarm mode enabled use the built-in raft store, and &gt; this field will be empty. 
  , systemInfoRuntimes :: !(Maybe (Map.Map String Runtime)) -- ^ "Runtimes" - List of [OCI compliant](https://github.com/opencontainers/runtime-spec) runtimes configured on the daemon. Keys hold the \&quot;name\&quot; used to reference the runtime.  The Docker daemon relies on an OCI compliant runtime (invoked via the &#x60;containerd&#x60; daemon) as its interface to the Linux kernel namespaces, cgroups, and SELinux.  The default runtime is &#x60;runc&#x60;, and automatically configured. Additional runtimes can be configured by the user and will be listed here. 
  , systemInfoDefaultRuntime :: !(Maybe Text) -- ^ "DefaultRuntime" - Name of the default OCI runtime that is used when starting containers.  The default can be overridden per-container at create time. 
  , systemInfoSwarm :: !(Maybe SwarmInfo) -- ^ "Swarm"
  , systemInfoLiveRestoreEnabled :: !(Maybe Bool) -- ^ "LiveRestoreEnabled" - Indicates if live restore is enabled.  If enabled, containers are kept running when the daemon is shutdown or upon daemon start if running containers are detected. 
  , systemInfoIsolation :: !(Maybe E'Isolation2) -- ^ "Isolation" - Represents the isolation technology to use as a default for containers. The supported values are platform-specific.  If no isolation value is specified on daemon start, on Windows client, the default is &#x60;hyperv&#x60;, and on Windows server, the default is &#x60;process&#x60;.  This option is currently not used on other platforms. 
  , systemInfoInitBinary :: !(Maybe Text) -- ^ "InitBinary" - Name and, optional, path of the &#x60;docker-init&#x60; binary.  If the path is omitted, the daemon searches the host&#39;s &#x60;$PATH&#x60; for the binary and uses the first result. 
  , systemInfoContainerdCommit :: !(Maybe Commit) -- ^ "ContainerdCommit"
  , systemInfoRuncCommit :: !(Maybe Commit) -- ^ "RuncCommit"
  , systemInfoInitCommit :: !(Maybe Commit) -- ^ "InitCommit"
  , systemInfoSecurityOptions :: !(Maybe [Text]) -- ^ "SecurityOptions" - List of security features that are enabled on the daemon, such as apparmor, seccomp, SELinux, user-namespaces (userns), and rootless.  Additional configuration options for each security feature may be present, and are included as a comma-separated list of key/value pairs. 
  , systemInfoProductLicense :: !(Maybe Text) -- ^ "ProductLicense" - Reports a summary of the product license on the daemon.  If a commercial license has been applied to the daemon, information such as number of nodes, and expiration are included. 
  , systemInfoDefaultAddressPools :: !(Maybe [SystemInfoDefaultAddressPools]) -- ^ "DefaultAddressPools" - List of custom default address pools for local networks, which can be specified in the daemon.json file or dockerd option.  Example: a Base \&quot;10.10.0.0/16\&quot; with Size 24 will define the set of 256 10.10.[0-255].0/24 address pools. 
  , systemInfoWarnings :: !(Maybe [Text]) -- ^ "Warnings" - List of warnings / informational messages about missing features, or issues related to the daemon configuration.  These messages can be printed by the client as information to the user. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SystemInfo
instance A.FromJSON SystemInfo where
  parseJSON = A.withObject "SystemInfo" $ \o ->
    SystemInfo
      <$> (o .:? "ID")
      <*> (o .:? "Containers")
      <*> (o .:? "ContainersRunning")
      <*> (o .:? "ContainersPaused")
      <*> (o .:? "ContainersStopped")
      <*> (o .:? "Images")
      <*> (o .:? "Driver")
      <*> (o .:? "DriverStatus")
      <*> (o .:? "DockerRootDir")
      <*> (o .:? "Plugins")
      <*> (o .:? "MemoryLimit")
      <*> (o .:? "SwapLimit")
      <*> (o .:? "KernelMemory")
      <*> (o .:? "KernelMemoryTCP")
      <*> (o .:? "CpuCfsPeriod")
      <*> (o .:? "CpuCfsQuota")
      <*> (o .:? "CPUShares")
      <*> (o .:? "CPUSet")
      <*> (o .:? "PidsLimit")
      <*> (o .:? "OomKillDisable")
      <*> (o .:? "IPv4Forwarding")
      <*> (o .:? "BridgeNfIptables")
      <*> (o .:? "BridgeNfIp6tables")
      <*> (o .:? "Debug")
      <*> (o .:? "NFd")
      <*> (o .:? "NGoroutines")
      <*> (o .:? "SystemTime")
      <*> (o .:? "LoggingDriver")
      <*> (o .:? "CgroupDriver")
      <*> (o .:? "CgroupVersion")
      <*> (o .:? "NEventsListener")
      <*> (o .:? "KernelVersion")
      <*> (o .:? "OperatingSystem")
      <*> (o .:? "OSVersion")
      <*> (o .:? "OSType")
      <*> (o .:? "Architecture")
      <*> (o .:? "NCPU")
      <*> (o .:? "MemTotal")
      <*> (o .:? "IndexServerAddress")
      <*> (o .:? "RegistryConfig")
      <*> (o .:? "GenericResources")
      <*> (o .:? "HttpProxy")
      <*> (o .:? "HttpsProxy")
      <*> (o .:? "NoProxy")
      <*> (o .:? "Name")
      <*> (o .:? "Labels")
      <*> (o .:? "ExperimentalBuild")
      <*> (o .:? "ServerVersion")
      <*> (o .:? "ClusterStore")
      <*> (o .:? "ClusterAdvertise")
      <*> (o .:? "Runtimes")
      <*> (o .:? "DefaultRuntime")
      <*> (o .:? "Swarm")
      <*> (o .:? "LiveRestoreEnabled")
      <*> (o .:? "Isolation")
      <*> (o .:? "InitBinary")
      <*> (o .:? "ContainerdCommit")
      <*> (o .:? "RuncCommit")
      <*> (o .:? "InitCommit")
      <*> (o .:? "SecurityOptions")
      <*> (o .:? "ProductLicense")
      <*> (o .:? "DefaultAddressPools")
      <*> (o .:? "Warnings")

-- | ToJSON SystemInfo
instance A.ToJSON SystemInfo where
  toJSON SystemInfo {..} =
   _omitNulls
      [ "ID" .= systemInfoId
      , "Containers" .= systemInfoContainers
      , "ContainersRunning" .= systemInfoContainersRunning
      , "ContainersPaused" .= systemInfoContainersPaused
      , "ContainersStopped" .= systemInfoContainersStopped
      , "Images" .= systemInfoImages
      , "Driver" .= systemInfoDriver
      , "DriverStatus" .= systemInfoDriverStatus
      , "DockerRootDir" .= systemInfoDockerRootDir
      , "Plugins" .= systemInfoPlugins
      , "MemoryLimit" .= systemInfoMemoryLimit
      , "SwapLimit" .= systemInfoSwapLimit
      , "KernelMemory" .= systemInfoKernelMemory
      , "KernelMemoryTCP" .= systemInfoKernelMemoryTcp
      , "CpuCfsPeriod" .= systemInfoCpuCfsPeriod
      , "CpuCfsQuota" .= systemInfoCpuCfsQuota
      , "CPUShares" .= systemInfoCpuShares
      , "CPUSet" .= systemInfoCpuSet
      , "PidsLimit" .= systemInfoPidsLimit
      , "OomKillDisable" .= systemInfoOomKillDisable
      , "IPv4Forwarding" .= systemInfoIpv4Forwarding
      , "BridgeNfIptables" .= systemInfoBridgeNfIptables
      , "BridgeNfIp6tables" .= systemInfoBridgeNfIp6tables
      , "Debug" .= systemInfoDebug
      , "NFd" .= systemInfoNfd
      , "NGoroutines" .= systemInfoNGoroutines
      , "SystemTime" .= systemInfoSystemTime
      , "LoggingDriver" .= systemInfoLoggingDriver
      , "CgroupDriver" .= systemInfoCgroupDriver
      , "CgroupVersion" .= systemInfoCgroupVersion
      , "NEventsListener" .= systemInfoNEventsListener
      , "KernelVersion" .= systemInfoKernelVersion
      , "OperatingSystem" .= systemInfoOperatingSystem
      , "OSVersion" .= systemInfoOsVersion
      , "OSType" .= systemInfoOsType
      , "Architecture" .= systemInfoArchitecture
      , "NCPU" .= systemInfoNcpu
      , "MemTotal" .= systemInfoMemTotal
      , "IndexServerAddress" .= systemInfoIndexServerAddress
      , "RegistryConfig" .= systemInfoRegistryConfig
      , "GenericResources" .= systemInfoGenericResources
      , "HttpProxy" .= systemInfoHttpProxy
      , "HttpsProxy" .= systemInfoHttpsProxy
      , "NoProxy" .= systemInfoNoProxy
      , "Name" .= systemInfoName
      , "Labels" .= systemInfoLabels
      , "ExperimentalBuild" .= systemInfoExperimentalBuild
      , "ServerVersion" .= systemInfoServerVersion
      , "ClusterStore" .= systemInfoClusterStore
      , "ClusterAdvertise" .= systemInfoClusterAdvertise
      , "Runtimes" .= systemInfoRuntimes
      , "DefaultRuntime" .= systemInfoDefaultRuntime
      , "Swarm" .= systemInfoSwarm
      , "LiveRestoreEnabled" .= systemInfoLiveRestoreEnabled
      , "Isolation" .= systemInfoIsolation
      , "InitBinary" .= systemInfoInitBinary
      , "ContainerdCommit" .= systemInfoContainerdCommit
      , "RuncCommit" .= systemInfoRuncCommit
      , "InitCommit" .= systemInfoInitCommit
      , "SecurityOptions" .= systemInfoSecurityOptions
      , "ProductLicense" .= systemInfoProductLicense
      , "DefaultAddressPools" .= systemInfoDefaultAddressPools
      , "Warnings" .= systemInfoWarnings
      ]


-- | Construct a value of type 'SystemInfo' (by applying it's required fields, if any)
mkSystemInfo
  :: SystemInfo
mkSystemInfo =
  SystemInfo
  { systemInfoId = Nothing
  , systemInfoContainers = Nothing
  , systemInfoContainersRunning = Nothing
  , systemInfoContainersPaused = Nothing
  , systemInfoContainersStopped = Nothing
  , systemInfoImages = Nothing
  , systemInfoDriver = Nothing
  , systemInfoDriverStatus = Nothing
  , systemInfoDockerRootDir = Nothing
  , systemInfoPlugins = Nothing
  , systemInfoMemoryLimit = Nothing
  , systemInfoSwapLimit = Nothing
  , systemInfoKernelMemory = Nothing
  , systemInfoKernelMemoryTcp = Nothing
  , systemInfoCpuCfsPeriod = Nothing
  , systemInfoCpuCfsQuota = Nothing
  , systemInfoCpuShares = Nothing
  , systemInfoCpuSet = Nothing
  , systemInfoPidsLimit = Nothing
  , systemInfoOomKillDisable = Nothing
  , systemInfoIpv4Forwarding = Nothing
  , systemInfoBridgeNfIptables = Nothing
  , systemInfoBridgeNfIp6tables = Nothing
  , systemInfoDebug = Nothing
  , systemInfoNfd = Nothing
  , systemInfoNGoroutines = Nothing
  , systemInfoSystemTime = Nothing
  , systemInfoLoggingDriver = Nothing
  , systemInfoCgroupDriver = Nothing
  , systemInfoCgroupVersion = Nothing
  , systemInfoNEventsListener = Nothing
  , systemInfoKernelVersion = Nothing
  , systemInfoOperatingSystem = Nothing
  , systemInfoOsVersion = Nothing
  , systemInfoOsType = Nothing
  , systemInfoArchitecture = Nothing
  , systemInfoNcpu = Nothing
  , systemInfoMemTotal = Nothing
  , systemInfoIndexServerAddress = Nothing
  , systemInfoRegistryConfig = Nothing
  , systemInfoGenericResources = Nothing
  , systemInfoHttpProxy = Nothing
  , systemInfoHttpsProxy = Nothing
  , systemInfoNoProxy = Nothing
  , systemInfoName = Nothing
  , systemInfoLabels = Nothing
  , systemInfoExperimentalBuild = Nothing
  , systemInfoServerVersion = Nothing
  , systemInfoClusterStore = Nothing
  , systemInfoClusterAdvertise = Nothing
  , systemInfoRuntimes = Nothing
  , systemInfoDefaultRuntime = Nothing
  , systemInfoSwarm = Nothing
  , systemInfoLiveRestoreEnabled = Nothing
  , systemInfoIsolation = Nothing
  , systemInfoInitBinary = Nothing
  , systemInfoContainerdCommit = Nothing
  , systemInfoRuncCommit = Nothing
  , systemInfoInitCommit = Nothing
  , systemInfoSecurityOptions = Nothing
  , systemInfoProductLicense = Nothing
  , systemInfoDefaultAddressPools = Nothing
  , systemInfoWarnings = Nothing
  }

-- ** SystemInfoDefaultAddressPools
-- | SystemInfoDefaultAddressPools
data SystemInfoDefaultAddressPools = SystemInfoDefaultAddressPools
  { systemInfoDefaultAddressPoolsBase :: !(Maybe Text) -- ^ "Base" - The network address in CIDR format
  , systemInfoDefaultAddressPoolsSize :: !(Maybe Int) -- ^ "Size" - The network pool size
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SystemInfoDefaultAddressPools
instance A.FromJSON SystemInfoDefaultAddressPools where
  parseJSON = A.withObject "SystemInfoDefaultAddressPools" $ \o ->
    SystemInfoDefaultAddressPools
      <$> (o .:? "Base")
      <*> (o .:? "Size")

-- | ToJSON SystemInfoDefaultAddressPools
instance A.ToJSON SystemInfoDefaultAddressPools where
  toJSON SystemInfoDefaultAddressPools {..} =
   _omitNulls
      [ "Base" .= systemInfoDefaultAddressPoolsBase
      , "Size" .= systemInfoDefaultAddressPoolsSize
      ]


-- | Construct a value of type 'SystemInfoDefaultAddressPools' (by applying it's required fields, if any)
mkSystemInfoDefaultAddressPools
  :: SystemInfoDefaultAddressPools
mkSystemInfoDefaultAddressPools =
  SystemInfoDefaultAddressPools
  { systemInfoDefaultAddressPoolsBase = Nothing
  , systemInfoDefaultAddressPoolsSize = Nothing
  }

-- ** SystemVersion
-- | SystemVersion
-- Response of Engine API: GET \"/version\" 
data SystemVersion = SystemVersion
  { systemVersionPlatform :: !(Maybe SystemVersionPlatform) -- ^ "Platform"
  , systemVersionComponents :: !(Maybe [SystemVersionComponents]) -- ^ "Components" - Information about system components 
  , systemVersionVersion :: !(Maybe Text) -- ^ "Version" - The version of the daemon
  , systemVersionApiVersion :: !(Maybe Text) -- ^ "ApiVersion" - The default (and highest) API version that is supported by the daemon 
  , systemVersionMinApiVersion :: !(Maybe Text) -- ^ "MinAPIVersion" - The minimum API version that is supported by the daemon 
  , systemVersionGitCommit :: !(Maybe Text) -- ^ "GitCommit" - The Git commit of the source code that was used to build the daemon 
  , systemVersionGoVersion :: !(Maybe Text) -- ^ "GoVersion" - The version Go used to compile the daemon, and the version of the Go runtime in use. 
  , systemVersionOs :: !(Maybe Text) -- ^ "Os" - The operating system that the daemon is running on (\&quot;linux\&quot; or \&quot;windows\&quot;) 
  , systemVersionArch :: !(Maybe Text) -- ^ "Arch" - The architecture that the daemon is running on 
  , systemVersionKernelVersion :: !(Maybe Text) -- ^ "KernelVersion" - The kernel version (&#x60;uname -r&#x60;) that the daemon is running on.  This field is omitted when empty. 
  , systemVersionExperimental :: !(Maybe Bool) -- ^ "Experimental" - Indicates if the daemon is started with experimental features enabled.  This field is omitted when empty / false. 
  , systemVersionBuildTime :: !(Maybe Text) -- ^ "BuildTime" - The date and time that the daemon was compiled. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SystemVersion
instance A.FromJSON SystemVersion where
  parseJSON = A.withObject "SystemVersion" $ \o ->
    SystemVersion
      <$> (o .:? "Platform")
      <*> (o .:? "Components")
      <*> (o .:? "Version")
      <*> (o .:? "ApiVersion")
      <*> (o .:? "MinAPIVersion")
      <*> (o .:? "GitCommit")
      <*> (o .:? "GoVersion")
      <*> (o .:? "Os")
      <*> (o .:? "Arch")
      <*> (o .:? "KernelVersion")
      <*> (o .:? "Experimental")
      <*> (o .:? "BuildTime")

-- | ToJSON SystemVersion
instance A.ToJSON SystemVersion where
  toJSON SystemVersion {..} =
   _omitNulls
      [ "Platform" .= systemVersionPlatform
      , "Components" .= systemVersionComponents
      , "Version" .= systemVersionVersion
      , "ApiVersion" .= systemVersionApiVersion
      , "MinAPIVersion" .= systemVersionMinApiVersion
      , "GitCommit" .= systemVersionGitCommit
      , "GoVersion" .= systemVersionGoVersion
      , "Os" .= systemVersionOs
      , "Arch" .= systemVersionArch
      , "KernelVersion" .= systemVersionKernelVersion
      , "Experimental" .= systemVersionExperimental
      , "BuildTime" .= systemVersionBuildTime
      ]


-- | Construct a value of type 'SystemVersion' (by applying it's required fields, if any)
mkSystemVersion
  :: SystemVersion
mkSystemVersion =
  SystemVersion
  { systemVersionPlatform = Nothing
  , systemVersionComponents = Nothing
  , systemVersionVersion = Nothing
  , systemVersionApiVersion = Nothing
  , systemVersionMinApiVersion = Nothing
  , systemVersionGitCommit = Nothing
  , systemVersionGoVersion = Nothing
  , systemVersionOs = Nothing
  , systemVersionArch = Nothing
  , systemVersionKernelVersion = Nothing
  , systemVersionExperimental = Nothing
  , systemVersionBuildTime = Nothing
  }

-- ** SystemVersionComponents
-- | SystemVersionComponents
data SystemVersionComponents = SystemVersionComponents
  { systemVersionComponentsName :: !(Text) -- ^ /Required/ "Name" - Name of the component 
  , systemVersionComponentsVersion :: !(Text) -- ^ /Required/ "Version" - Version of the component 
  , systemVersionComponentsDetails :: !(Maybe A.Value) -- ^ "Details" - Key/value pairs of strings with additional information about the component. These values are intended for informational purposes only, and their content is not defined, and not part of the API specification.  These messages can be printed by the client as information to the user. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SystemVersionComponents
instance A.FromJSON SystemVersionComponents where
  parseJSON = A.withObject "SystemVersionComponents" $ \o ->
    SystemVersionComponents
      <$> (o .:  "Name")
      <*> (o .:  "Version")
      <*> (o .:? "Details")

-- | ToJSON SystemVersionComponents
instance A.ToJSON SystemVersionComponents where
  toJSON SystemVersionComponents {..} =
   _omitNulls
      [ "Name" .= systemVersionComponentsName
      , "Version" .= systemVersionComponentsVersion
      , "Details" .= systemVersionComponentsDetails
      ]


-- | Construct a value of type 'SystemVersionComponents' (by applying it's required fields, if any)
mkSystemVersionComponents
  :: Text -- ^ 'systemVersionComponentsName': Name of the component 
  -> Text -- ^ 'systemVersionComponentsVersion': Version of the component 
  -> SystemVersionComponents
mkSystemVersionComponents systemVersionComponentsName systemVersionComponentsVersion =
  SystemVersionComponents
  { systemVersionComponentsName
  , systemVersionComponentsVersion
  , systemVersionComponentsDetails = Nothing
  }

-- ** SystemVersionPlatform
-- | SystemVersionPlatform
data SystemVersionPlatform = SystemVersionPlatform
  { systemVersionPlatformName :: !(Text) -- ^ /Required/ "Name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SystemVersionPlatform
instance A.FromJSON SystemVersionPlatform where
  parseJSON = A.withObject "SystemVersionPlatform" $ \o ->
    SystemVersionPlatform
      <$> (o .:  "Name")

-- | ToJSON SystemVersionPlatform
instance A.ToJSON SystemVersionPlatform where
  toJSON SystemVersionPlatform {..} =
   _omitNulls
      [ "Name" .= systemVersionPlatformName
      ]


-- | Construct a value of type 'SystemVersionPlatform' (by applying it's required fields, if any)
mkSystemVersionPlatform
  :: Text -- ^ 'systemVersionPlatformName' 
  -> SystemVersionPlatform
mkSystemVersionPlatform systemVersionPlatformName =
  SystemVersionPlatform
  { systemVersionPlatformName
  }

-- ** TLSInfo
-- | TLSInfo
-- Information about the issuer of leaf TLS certificates and the trusted root CA certificate. 
data TLSInfo = TLSInfo
  { tLSInfoTrustRoot :: !(Maybe Text) -- ^ "TrustRoot" - The root CA certificate(s) that are used to validate leaf TLS certificates. 
  , tLSInfoCertIssuerSubject :: !(Maybe Text) -- ^ "CertIssuerSubject" - The base64-url-safe-encoded raw subject bytes of the issuer.
  , tLSInfoCertIssuerPublicKey :: !(Maybe Text) -- ^ "CertIssuerPublicKey" - The base64-url-safe-encoded raw public key bytes of the issuer. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TLSInfo
instance A.FromJSON TLSInfo where
  parseJSON = A.withObject "TLSInfo" $ \o ->
    TLSInfo
      <$> (o .:? "TrustRoot")
      <*> (o .:? "CertIssuerSubject")
      <*> (o .:? "CertIssuerPublicKey")

-- | ToJSON TLSInfo
instance A.ToJSON TLSInfo where
  toJSON TLSInfo {..} =
   _omitNulls
      [ "TrustRoot" .= tLSInfoTrustRoot
      , "CertIssuerSubject" .= tLSInfoCertIssuerSubject
      , "CertIssuerPublicKey" .= tLSInfoCertIssuerPublicKey
      ]


-- | Construct a value of type 'TLSInfo' (by applying it's required fields, if any)
mkTLSInfo
  :: TLSInfo
mkTLSInfo =
  TLSInfo
  { tLSInfoTrustRoot = Nothing
  , tLSInfoCertIssuerSubject = Nothing
  , tLSInfoCertIssuerPublicKey = Nothing
  }

-- ** Task
-- | Task
data Task = Task
  { taskId :: !(Maybe Text) -- ^ "ID" - The ID of the task.
  , taskVersion :: !(Maybe ObjectVersion) -- ^ "Version"
  , taskCreatedAt :: !(Maybe Text) -- ^ "CreatedAt"
  , taskUpdatedAt :: !(Maybe Text) -- ^ "UpdatedAt"
  , taskName :: !(Maybe Text) -- ^ "Name" - Name of the task.
  , taskLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  , taskSpec :: !(Maybe TaskSpec) -- ^ "Spec"
  , taskServiceId :: !(Maybe Text) -- ^ "ServiceID" - The ID of the service this task is part of.
  , taskSlot :: !(Maybe Int) -- ^ "Slot"
  , taskNodeId :: !(Maybe Text) -- ^ "NodeID" - The ID of the node that this task is on.
  , taskAssignedGenericResources :: !(Maybe [A.Value]) -- ^ "AssignedGenericResources" - User-defined resources can be either Integer resources (e.g, &#x60;SSD&#x3D;3&#x60;) or String resources (e.g, &#x60;GPU&#x3D;UUID1&#x60;). 
  , taskStatus :: !(Maybe TaskStatus) -- ^ "Status"
  , taskDesiredState :: !(Maybe TaskState) -- ^ "DesiredState"
  , taskJobIteration :: !(Maybe ObjectVersion) -- ^ "JobIteration"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Task
instance A.FromJSON Task where
  parseJSON = A.withObject "Task" $ \o ->
    Task
      <$> (o .:? "ID")
      <*> (o .:? "Version")
      <*> (o .:? "CreatedAt")
      <*> (o .:? "UpdatedAt")
      <*> (o .:? "Name")
      <*> (o .:? "Labels")
      <*> (o .:? "Spec")
      <*> (o .:? "ServiceID")
      <*> (o .:? "Slot")
      <*> (o .:? "NodeID")
      <*> (o .:? "AssignedGenericResources")
      <*> (o .:? "Status")
      <*> (o .:? "DesiredState")
      <*> (o .:? "JobIteration")

-- | ToJSON Task
instance A.ToJSON Task where
  toJSON Task {..} =
   _omitNulls
      [ "ID" .= taskId
      , "Version" .= taskVersion
      , "CreatedAt" .= taskCreatedAt
      , "UpdatedAt" .= taskUpdatedAt
      , "Name" .= taskName
      , "Labels" .= taskLabels
      , "Spec" .= taskSpec
      , "ServiceID" .= taskServiceId
      , "Slot" .= taskSlot
      , "NodeID" .= taskNodeId
      , "AssignedGenericResources" .= taskAssignedGenericResources
      , "Status" .= taskStatus
      , "DesiredState" .= taskDesiredState
      , "JobIteration" .= taskJobIteration
      ]


-- | Construct a value of type 'Task' (by applying it's required fields, if any)
mkTask
  :: Task
mkTask =
  Task
  { taskId = Nothing
  , taskVersion = Nothing
  , taskCreatedAt = Nothing
  , taskUpdatedAt = Nothing
  , taskName = Nothing
  , taskLabels = Nothing
  , taskSpec = Nothing
  , taskServiceId = Nothing
  , taskSlot = Nothing
  , taskNodeId = Nothing
  , taskAssignedGenericResources = Nothing
  , taskStatus = Nothing
  , taskDesiredState = Nothing
  , taskJobIteration = Nothing
  }

-- ** TaskSpec
-- | TaskSpec
-- User modifiable task configuration.
data TaskSpec = TaskSpec
  { taskSpecPluginSpec :: !(Maybe TaskSpecPluginSpec) -- ^ "PluginSpec"
  , taskSpecContainerSpec :: !(Maybe TaskSpecContainerSpec) -- ^ "ContainerSpec"
  , taskSpecNetworkAttachmentSpec :: !(Maybe TaskSpecNetworkAttachmentSpec) -- ^ "NetworkAttachmentSpec"
  , taskSpecResources :: !(Maybe TaskSpecResources) -- ^ "Resources"
  , taskSpecRestartPolicy :: !(Maybe TaskSpecRestartPolicy) -- ^ "RestartPolicy"
  , taskSpecPlacement :: !(Maybe TaskSpecPlacement) -- ^ "Placement"
  , taskSpecForceUpdate :: !(Maybe Int) -- ^ "ForceUpdate" - A counter that triggers an update even if no relevant parameters have been changed. 
  , taskSpecRuntime :: !(Maybe Text) -- ^ "Runtime" - Runtime is the type of runtime specified for the task executor. 
  , taskSpecNetworks :: !(Maybe [NetworkAttachmentConfig]) -- ^ "Networks" - Specifies which networks the service should attach to.
  , taskSpecLogDriver :: !(Maybe TaskSpecLogDriver) -- ^ "LogDriver"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpec
instance A.FromJSON TaskSpec where
  parseJSON = A.withObject "TaskSpec" $ \o ->
    TaskSpec
      <$> (o .:? "PluginSpec")
      <*> (o .:? "ContainerSpec")
      <*> (o .:? "NetworkAttachmentSpec")
      <*> (o .:? "Resources")
      <*> (o .:? "RestartPolicy")
      <*> (o .:? "Placement")
      <*> (o .:? "ForceUpdate")
      <*> (o .:? "Runtime")
      <*> (o .:? "Networks")
      <*> (o .:? "LogDriver")

-- | ToJSON TaskSpec
instance A.ToJSON TaskSpec where
  toJSON TaskSpec {..} =
   _omitNulls
      [ "PluginSpec" .= taskSpecPluginSpec
      , "ContainerSpec" .= taskSpecContainerSpec
      , "NetworkAttachmentSpec" .= taskSpecNetworkAttachmentSpec
      , "Resources" .= taskSpecResources
      , "RestartPolicy" .= taskSpecRestartPolicy
      , "Placement" .= taskSpecPlacement
      , "ForceUpdate" .= taskSpecForceUpdate
      , "Runtime" .= taskSpecRuntime
      , "Networks" .= taskSpecNetworks
      , "LogDriver" .= taskSpecLogDriver
      ]


-- | Construct a value of type 'TaskSpec' (by applying it's required fields, if any)
mkTaskSpec
  :: TaskSpec
mkTaskSpec =
  TaskSpec
  { taskSpecPluginSpec = Nothing
  , taskSpecContainerSpec = Nothing
  , taskSpecNetworkAttachmentSpec = Nothing
  , taskSpecResources = Nothing
  , taskSpecRestartPolicy = Nothing
  , taskSpecPlacement = Nothing
  , taskSpecForceUpdate = Nothing
  , taskSpecRuntime = Nothing
  , taskSpecNetworks = Nothing
  , taskSpecLogDriver = Nothing
  }

-- ** TaskSpecContainerSpec
-- | TaskSpecContainerSpec
-- Container spec for the service.  <p><br /></p>  > **Note**: ContainerSpec, NetworkAttachmentSpec, and PluginSpec are > mutually exclusive. PluginSpec is only used when the Runtime field > is set to `plugin`. NetworkAttachmentSpec is used when the Runtime > field is set to `attachment`. 
data TaskSpecContainerSpec = TaskSpecContainerSpec
  { taskSpecContainerSpecImage :: !(Maybe Text) -- ^ "Image" - The image name to use for the container
  , taskSpecContainerSpecLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value data.
  , taskSpecContainerSpecCommand :: !(Maybe [Text]) -- ^ "Command" - The command to be run in the image.
  , taskSpecContainerSpecArgs :: !(Maybe [Text]) -- ^ "Args" - Arguments to the command.
  , taskSpecContainerSpecHostname :: !(Maybe Text) -- ^ "Hostname" - The hostname to use for the container, as a valid [RFC 1123](https://tools.ietf.org/html/rfc1123) hostname. 
  , taskSpecContainerSpecEnv :: !(Maybe [Text]) -- ^ "Env" - A list of environment variables in the form &#x60;VAR&#x3D;value&#x60;. 
  , taskSpecContainerSpecDir :: !(Maybe Text) -- ^ "Dir" - The working directory for commands to run in.
  , taskSpecContainerSpecUser :: !(Maybe Text) -- ^ "User" - The user inside the container.
  , taskSpecContainerSpecGroups :: !(Maybe [Text]) -- ^ "Groups" - A list of additional groups that the container process will run as. 
  , taskSpecContainerSpecPrivileges :: !(Maybe TaskSpecContainerSpecPrivileges) -- ^ "Privileges"
  , taskSpecContainerSpecTty :: !(Maybe Bool) -- ^ "TTY" - Whether a pseudo-TTY should be allocated.
  , taskSpecContainerSpecOpenStdin :: !(Maybe Bool) -- ^ "OpenStdin" - Open &#x60;stdin&#x60;
  , taskSpecContainerSpecReadOnly :: !(Maybe Bool) -- ^ "ReadOnly" - Mount the container&#39;s root filesystem as read only.
  , taskSpecContainerSpecMounts :: !(Maybe [Mount]) -- ^ "Mounts" - Specification for mounts to be added to containers created as part of the service. 
  , taskSpecContainerSpecStopSignal :: !(Maybe Text) -- ^ "StopSignal" - Signal to stop the container.
  , taskSpecContainerSpecStopGracePeriod :: !(Maybe Integer) -- ^ "StopGracePeriod" - Amount of time to wait for the container to terminate before forcefully killing it. 
  , taskSpecContainerSpecHealthCheck :: !(Maybe HealthConfig) -- ^ "HealthCheck"
  , taskSpecContainerSpecHosts :: !(Maybe [Text]) -- ^ "Hosts" - A list of hostname/IP mappings to add to the container&#39;s &#x60;hosts&#x60; file. The format of extra hosts is specified in the [hosts(5)](http://man7.org/linux/man-pages/man5/hosts.5.html) man page:      IP_address canonical_hostname [aliases...] 
  , taskSpecContainerSpecDnsConfig :: !(Maybe TaskSpecContainerSpecDNSConfig) -- ^ "DNSConfig"
  , taskSpecContainerSpecSecrets :: !(Maybe [TaskSpecContainerSpecSecrets]) -- ^ "Secrets" - Secrets contains references to zero or more secrets that will be exposed to the service. 
  , taskSpecContainerSpecConfigs :: !(Maybe [TaskSpecContainerSpecConfigs]) -- ^ "Configs" - Configs contains references to zero or more configs that will be exposed to the service. 
  , taskSpecContainerSpecIsolation :: !(Maybe E'Isolation) -- ^ "Isolation" - Isolation technology of the containers running the service. (Windows only) 
  , taskSpecContainerSpecInit :: !(Maybe Bool) -- ^ "Init" - Run an init inside the container that forwards signals and reaps processes. This field is omitted if empty, and the default (as configured on the daemon) is used. 
  , taskSpecContainerSpecSysctls :: !(Maybe (Map.Map String Text)) -- ^ "Sysctls" - Set kernel namedspaced parameters (sysctls) in the container. The Sysctls option on services accepts the same sysctls as the are supported on containers. Note that while the same sysctls are supported, no guarantees or checks are made about their suitability for a clustered environment, and it&#39;s up to the user to determine whether a given sysctl will work properly in a Service. 
  , taskSpecContainerSpecCapabilityAdd :: !(Maybe [Text]) -- ^ "CapabilityAdd" - A list of kernel capabilities to add to the default set for the container. 
  , taskSpecContainerSpecCapabilityDrop :: !(Maybe [Text]) -- ^ "CapabilityDrop" - A list of kernel capabilities to drop from the default set for the container. 
  , taskSpecContainerSpecUlimits :: !(Maybe [ResourcesUlimits]) -- ^ "Ulimits" - A list of resource limits to set in the container. For example: &#x60;{\&quot;Name\&quot;: \&quot;nofile\&quot;, \&quot;Soft\&quot;: 1024, \&quot;Hard\&quot;: 2048}&#x60;\&quot; 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecContainerSpec
instance A.FromJSON TaskSpecContainerSpec where
  parseJSON = A.withObject "TaskSpecContainerSpec" $ \o ->
    TaskSpecContainerSpec
      <$> (o .:? "Image")
      <*> (o .:? "Labels")
      <*> (o .:? "Command")
      <*> (o .:? "Args")
      <*> (o .:? "Hostname")
      <*> (o .:? "Env")
      <*> (o .:? "Dir")
      <*> (o .:? "User")
      <*> (o .:? "Groups")
      <*> (o .:? "Privileges")
      <*> (o .:? "TTY")
      <*> (o .:? "OpenStdin")
      <*> (o .:? "ReadOnly")
      <*> (o .:? "Mounts")
      <*> (o .:? "StopSignal")
      <*> (o .:? "StopGracePeriod")
      <*> (o .:? "HealthCheck")
      <*> (o .:? "Hosts")
      <*> (o .:? "DNSConfig")
      <*> (o .:? "Secrets")
      <*> (o .:? "Configs")
      <*> (o .:? "Isolation")
      <*> (o .:? "Init")
      <*> (o .:? "Sysctls")
      <*> (o .:? "CapabilityAdd")
      <*> (o .:? "CapabilityDrop")
      <*> (o .:? "Ulimits")

-- | ToJSON TaskSpecContainerSpec
instance A.ToJSON TaskSpecContainerSpec where
  toJSON TaskSpecContainerSpec {..} =
   _omitNulls
      [ "Image" .= taskSpecContainerSpecImage
      , "Labels" .= taskSpecContainerSpecLabels
      , "Command" .= taskSpecContainerSpecCommand
      , "Args" .= taskSpecContainerSpecArgs
      , "Hostname" .= taskSpecContainerSpecHostname
      , "Env" .= taskSpecContainerSpecEnv
      , "Dir" .= taskSpecContainerSpecDir
      , "User" .= taskSpecContainerSpecUser
      , "Groups" .= taskSpecContainerSpecGroups
      , "Privileges" .= taskSpecContainerSpecPrivileges
      , "TTY" .= taskSpecContainerSpecTty
      , "OpenStdin" .= taskSpecContainerSpecOpenStdin
      , "ReadOnly" .= taskSpecContainerSpecReadOnly
      , "Mounts" .= taskSpecContainerSpecMounts
      , "StopSignal" .= taskSpecContainerSpecStopSignal
      , "StopGracePeriod" .= taskSpecContainerSpecStopGracePeriod
      , "HealthCheck" .= taskSpecContainerSpecHealthCheck
      , "Hosts" .= taskSpecContainerSpecHosts
      , "DNSConfig" .= taskSpecContainerSpecDnsConfig
      , "Secrets" .= taskSpecContainerSpecSecrets
      , "Configs" .= taskSpecContainerSpecConfigs
      , "Isolation" .= taskSpecContainerSpecIsolation
      , "Init" .= taskSpecContainerSpecInit
      , "Sysctls" .= taskSpecContainerSpecSysctls
      , "CapabilityAdd" .= taskSpecContainerSpecCapabilityAdd
      , "CapabilityDrop" .= taskSpecContainerSpecCapabilityDrop
      , "Ulimits" .= taskSpecContainerSpecUlimits
      ]


-- | Construct a value of type 'TaskSpecContainerSpec' (by applying it's required fields, if any)
mkTaskSpecContainerSpec
  :: TaskSpecContainerSpec
mkTaskSpecContainerSpec =
  TaskSpecContainerSpec
  { taskSpecContainerSpecImage = Nothing
  , taskSpecContainerSpecLabels = Nothing
  , taskSpecContainerSpecCommand = Nothing
  , taskSpecContainerSpecArgs = Nothing
  , taskSpecContainerSpecHostname = Nothing
  , taskSpecContainerSpecEnv = Nothing
  , taskSpecContainerSpecDir = Nothing
  , taskSpecContainerSpecUser = Nothing
  , taskSpecContainerSpecGroups = Nothing
  , taskSpecContainerSpecPrivileges = Nothing
  , taskSpecContainerSpecTty = Nothing
  , taskSpecContainerSpecOpenStdin = Nothing
  , taskSpecContainerSpecReadOnly = Nothing
  , taskSpecContainerSpecMounts = Nothing
  , taskSpecContainerSpecStopSignal = Nothing
  , taskSpecContainerSpecStopGracePeriod = Nothing
  , taskSpecContainerSpecHealthCheck = Nothing
  , taskSpecContainerSpecHosts = Nothing
  , taskSpecContainerSpecDnsConfig = Nothing
  , taskSpecContainerSpecSecrets = Nothing
  , taskSpecContainerSpecConfigs = Nothing
  , taskSpecContainerSpecIsolation = Nothing
  , taskSpecContainerSpecInit = Nothing
  , taskSpecContainerSpecSysctls = Nothing
  , taskSpecContainerSpecCapabilityAdd = Nothing
  , taskSpecContainerSpecCapabilityDrop = Nothing
  , taskSpecContainerSpecUlimits = Nothing
  }

-- ** TaskSpecContainerSpecConfigs
-- | TaskSpecContainerSpecConfigs
data TaskSpecContainerSpecConfigs = TaskSpecContainerSpecConfigs
  { taskSpecContainerSpecConfigsFile :: !(Maybe TaskSpecContainerSpecFile1) -- ^ "File"
  , taskSpecContainerSpecConfigsRuntime :: !(Maybe A.Value) -- ^ "Runtime" - Runtime represents a target that is not mounted into the container but is used by the task  &lt;p&gt;&lt;br /&gt;&lt;p&gt;  &gt; **Note**: &#x60;Configs.File&#x60; and &#x60;Configs.Runtime&#x60; are mutually &gt; exclusive 
  , taskSpecContainerSpecConfigsConfigId :: !(Maybe Text) -- ^ "ConfigID" - ConfigID represents the ID of the specific config that we&#39;re referencing. 
  , taskSpecContainerSpecConfigsConfigName :: !(Maybe Text) -- ^ "ConfigName" - ConfigName is the name of the config that this references, but this is just provided for lookup/display purposes. The config in the reference will be identified by its ID. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecContainerSpecConfigs
instance A.FromJSON TaskSpecContainerSpecConfigs where
  parseJSON = A.withObject "TaskSpecContainerSpecConfigs" $ \o ->
    TaskSpecContainerSpecConfigs
      <$> (o .:? "File")
      <*> (o .:? "Runtime")
      <*> (o .:? "ConfigID")
      <*> (o .:? "ConfigName")

-- | ToJSON TaskSpecContainerSpecConfigs
instance A.ToJSON TaskSpecContainerSpecConfigs where
  toJSON TaskSpecContainerSpecConfigs {..} =
   _omitNulls
      [ "File" .= taskSpecContainerSpecConfigsFile
      , "Runtime" .= taskSpecContainerSpecConfigsRuntime
      , "ConfigID" .= taskSpecContainerSpecConfigsConfigId
      , "ConfigName" .= taskSpecContainerSpecConfigsConfigName
      ]


-- | Construct a value of type 'TaskSpecContainerSpecConfigs' (by applying it's required fields, if any)
mkTaskSpecContainerSpecConfigs
  :: TaskSpecContainerSpecConfigs
mkTaskSpecContainerSpecConfigs =
  TaskSpecContainerSpecConfigs
  { taskSpecContainerSpecConfigsFile = Nothing
  , taskSpecContainerSpecConfigsRuntime = Nothing
  , taskSpecContainerSpecConfigsConfigId = Nothing
  , taskSpecContainerSpecConfigsConfigName = Nothing
  }

-- ** TaskSpecContainerSpecDNSConfig
-- | TaskSpecContainerSpecDNSConfig
-- Specification for DNS related configurations in resolver configuration file (`resolv.conf`). 
data TaskSpecContainerSpecDNSConfig = TaskSpecContainerSpecDNSConfig
  { taskSpecContainerSpecDNSConfigNameservers :: !(Maybe [Text]) -- ^ "Nameservers" - The IP addresses of the name servers.
  , taskSpecContainerSpecDNSConfigSearch :: !(Maybe [Text]) -- ^ "Search" - A search list for host-name lookup.
  , taskSpecContainerSpecDNSConfigOptions :: !(Maybe [Text]) -- ^ "Options" - A list of internal resolver variables to be modified (e.g., &#x60;debug&#x60;, &#x60;ndots:3&#x60;, etc.). 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecContainerSpecDNSConfig
instance A.FromJSON TaskSpecContainerSpecDNSConfig where
  parseJSON = A.withObject "TaskSpecContainerSpecDNSConfig" $ \o ->
    TaskSpecContainerSpecDNSConfig
      <$> (o .:? "Nameservers")
      <*> (o .:? "Search")
      <*> (o .:? "Options")

-- | ToJSON TaskSpecContainerSpecDNSConfig
instance A.ToJSON TaskSpecContainerSpecDNSConfig where
  toJSON TaskSpecContainerSpecDNSConfig {..} =
   _omitNulls
      [ "Nameservers" .= taskSpecContainerSpecDNSConfigNameservers
      , "Search" .= taskSpecContainerSpecDNSConfigSearch
      , "Options" .= taskSpecContainerSpecDNSConfigOptions
      ]


-- | Construct a value of type 'TaskSpecContainerSpecDNSConfig' (by applying it's required fields, if any)
mkTaskSpecContainerSpecDNSConfig
  :: TaskSpecContainerSpecDNSConfig
mkTaskSpecContainerSpecDNSConfig =
  TaskSpecContainerSpecDNSConfig
  { taskSpecContainerSpecDNSConfigNameservers = Nothing
  , taskSpecContainerSpecDNSConfigSearch = Nothing
  , taskSpecContainerSpecDNSConfigOptions = Nothing
  }

-- ** TaskSpecContainerSpecFile
-- | TaskSpecContainerSpecFile
-- File represents a specific target that is backed by a file. 
data TaskSpecContainerSpecFile = TaskSpecContainerSpecFile
  { taskSpecContainerSpecFileName :: !(Maybe Text) -- ^ "Name" - Name represents the final filename in the filesystem. 
  , taskSpecContainerSpecFileUid :: !(Maybe Text) -- ^ "UID" - UID represents the file UID.
  , taskSpecContainerSpecFileGid :: !(Maybe Text) -- ^ "GID" - GID represents the file GID.
  , taskSpecContainerSpecFileMode :: !(Maybe Int) -- ^ "Mode" - Mode represents the FileMode of the file.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecContainerSpecFile
instance A.FromJSON TaskSpecContainerSpecFile where
  parseJSON = A.withObject "TaskSpecContainerSpecFile" $ \o ->
    TaskSpecContainerSpecFile
      <$> (o .:? "Name")
      <*> (o .:? "UID")
      <*> (o .:? "GID")
      <*> (o .:? "Mode")

-- | ToJSON TaskSpecContainerSpecFile
instance A.ToJSON TaskSpecContainerSpecFile where
  toJSON TaskSpecContainerSpecFile {..} =
   _omitNulls
      [ "Name" .= taskSpecContainerSpecFileName
      , "UID" .= taskSpecContainerSpecFileUid
      , "GID" .= taskSpecContainerSpecFileGid
      , "Mode" .= taskSpecContainerSpecFileMode
      ]


-- | Construct a value of type 'TaskSpecContainerSpecFile' (by applying it's required fields, if any)
mkTaskSpecContainerSpecFile
  :: TaskSpecContainerSpecFile
mkTaskSpecContainerSpecFile =
  TaskSpecContainerSpecFile
  { taskSpecContainerSpecFileName = Nothing
  , taskSpecContainerSpecFileUid = Nothing
  , taskSpecContainerSpecFileGid = Nothing
  , taskSpecContainerSpecFileMode = Nothing
  }

-- ** TaskSpecContainerSpecFile1
-- | TaskSpecContainerSpecFile1
-- File represents a specific target that is backed by a file.  <p><br /><p>  > **Note**: `Configs.File` and `Configs.Runtime` are mutually exclusive 
data TaskSpecContainerSpecFile1 = TaskSpecContainerSpecFile1
  { taskSpecContainerSpecFile1Name :: !(Maybe Text) -- ^ "Name" - Name represents the final filename in the filesystem. 
  , taskSpecContainerSpecFile1Uid :: !(Maybe Text) -- ^ "UID" - UID represents the file UID.
  , taskSpecContainerSpecFile1Gid :: !(Maybe Text) -- ^ "GID" - GID represents the file GID.
  , taskSpecContainerSpecFile1Mode :: !(Maybe Int) -- ^ "Mode" - Mode represents the FileMode of the file.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecContainerSpecFile1
instance A.FromJSON TaskSpecContainerSpecFile1 where
  parseJSON = A.withObject "TaskSpecContainerSpecFile1" $ \o ->
    TaskSpecContainerSpecFile1
      <$> (o .:? "Name")
      <*> (o .:? "UID")
      <*> (o .:? "GID")
      <*> (o .:? "Mode")

-- | ToJSON TaskSpecContainerSpecFile1
instance A.ToJSON TaskSpecContainerSpecFile1 where
  toJSON TaskSpecContainerSpecFile1 {..} =
   _omitNulls
      [ "Name" .= taskSpecContainerSpecFile1Name
      , "UID" .= taskSpecContainerSpecFile1Uid
      , "GID" .= taskSpecContainerSpecFile1Gid
      , "Mode" .= taskSpecContainerSpecFile1Mode
      ]


-- | Construct a value of type 'TaskSpecContainerSpecFile1' (by applying it's required fields, if any)
mkTaskSpecContainerSpecFile1
  :: TaskSpecContainerSpecFile1
mkTaskSpecContainerSpecFile1 =
  TaskSpecContainerSpecFile1
  { taskSpecContainerSpecFile1Name = Nothing
  , taskSpecContainerSpecFile1Uid = Nothing
  , taskSpecContainerSpecFile1Gid = Nothing
  , taskSpecContainerSpecFile1Mode = Nothing
  }

-- ** TaskSpecContainerSpecPrivileges
-- | TaskSpecContainerSpecPrivileges
-- Security options for the container
data TaskSpecContainerSpecPrivileges = TaskSpecContainerSpecPrivileges
  { taskSpecContainerSpecPrivilegesCredentialSpec :: !(Maybe TaskSpecContainerSpecPrivilegesCredentialSpec) -- ^ "CredentialSpec"
  , taskSpecContainerSpecPrivilegesSeLinuxContext :: !(Maybe TaskSpecContainerSpecPrivilegesSELinuxContext) -- ^ "SELinuxContext"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecContainerSpecPrivileges
instance A.FromJSON TaskSpecContainerSpecPrivileges where
  parseJSON = A.withObject "TaskSpecContainerSpecPrivileges" $ \o ->
    TaskSpecContainerSpecPrivileges
      <$> (o .:? "CredentialSpec")
      <*> (o .:? "SELinuxContext")

-- | ToJSON TaskSpecContainerSpecPrivileges
instance A.ToJSON TaskSpecContainerSpecPrivileges where
  toJSON TaskSpecContainerSpecPrivileges {..} =
   _omitNulls
      [ "CredentialSpec" .= taskSpecContainerSpecPrivilegesCredentialSpec
      , "SELinuxContext" .= taskSpecContainerSpecPrivilegesSeLinuxContext
      ]


-- | Construct a value of type 'TaskSpecContainerSpecPrivileges' (by applying it's required fields, if any)
mkTaskSpecContainerSpecPrivileges
  :: TaskSpecContainerSpecPrivileges
mkTaskSpecContainerSpecPrivileges =
  TaskSpecContainerSpecPrivileges
  { taskSpecContainerSpecPrivilegesCredentialSpec = Nothing
  , taskSpecContainerSpecPrivilegesSeLinuxContext = Nothing
  }

-- ** TaskSpecContainerSpecPrivilegesCredentialSpec
-- | TaskSpecContainerSpecPrivilegesCredentialSpec
-- CredentialSpec for managed service account (Windows only)
data TaskSpecContainerSpecPrivilegesCredentialSpec = TaskSpecContainerSpecPrivilegesCredentialSpec
  { taskSpecContainerSpecPrivilegesCredentialSpecConfig :: !(Maybe Text) -- ^ "Config" - Load credential spec from a Swarm Config with the given ID. The specified config must also be present in the Configs field with the Runtime property set.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;   &gt; **Note**: &#x60;CredentialSpec.File&#x60;, &#x60;CredentialSpec.Registry&#x60;, &gt; and &#x60;CredentialSpec.Config&#x60; are mutually exclusive. 
  , taskSpecContainerSpecPrivilegesCredentialSpecFile :: !(Maybe Text) -- ^ "File" - Load credential spec from this file. The file is read by the daemon, and must be present in the &#x60;CredentialSpecs&#x60; subdirectory in the docker data directory, which defaults to &#x60;C:\\ProgramData\\Docker\\&#x60; on Windows.  For example, specifying &#x60;spec.json&#x60; loads &#x60;C:\\ProgramData\\Docker\\CredentialSpecs\\spec.json&#x60;.  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;  &gt; **Note**: &#x60;CredentialSpec.File&#x60;, &#x60;CredentialSpec.Registry&#x60;, &gt; and &#x60;CredentialSpec.Config&#x60; are mutually exclusive. 
  , taskSpecContainerSpecPrivilegesCredentialSpecRegistry :: !(Maybe Text) -- ^ "Registry" - Load credential spec from this value in the Windows registry. The specified registry value must be located in:  &#x60;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Virtualization\\Containers\\CredentialSpecs&#x60;  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;   &gt; **Note**: &#x60;CredentialSpec.File&#x60;, &#x60;CredentialSpec.Registry&#x60;, &gt; and &#x60;CredentialSpec.Config&#x60; are mutually exclusive. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecContainerSpecPrivilegesCredentialSpec
instance A.FromJSON TaskSpecContainerSpecPrivilegesCredentialSpec where
  parseJSON = A.withObject "TaskSpecContainerSpecPrivilegesCredentialSpec" $ \o ->
    TaskSpecContainerSpecPrivilegesCredentialSpec
      <$> (o .:? "Config")
      <*> (o .:? "File")
      <*> (o .:? "Registry")

-- | ToJSON TaskSpecContainerSpecPrivilegesCredentialSpec
instance A.ToJSON TaskSpecContainerSpecPrivilegesCredentialSpec where
  toJSON TaskSpecContainerSpecPrivilegesCredentialSpec {..} =
   _omitNulls
      [ "Config" .= taskSpecContainerSpecPrivilegesCredentialSpecConfig
      , "File" .= taskSpecContainerSpecPrivilegesCredentialSpecFile
      , "Registry" .= taskSpecContainerSpecPrivilegesCredentialSpecRegistry
      ]


-- | Construct a value of type 'TaskSpecContainerSpecPrivilegesCredentialSpec' (by applying it's required fields, if any)
mkTaskSpecContainerSpecPrivilegesCredentialSpec
  :: TaskSpecContainerSpecPrivilegesCredentialSpec
mkTaskSpecContainerSpecPrivilegesCredentialSpec =
  TaskSpecContainerSpecPrivilegesCredentialSpec
  { taskSpecContainerSpecPrivilegesCredentialSpecConfig = Nothing
  , taskSpecContainerSpecPrivilegesCredentialSpecFile = Nothing
  , taskSpecContainerSpecPrivilegesCredentialSpecRegistry = Nothing
  }

-- ** TaskSpecContainerSpecPrivilegesSELinuxContext
-- | TaskSpecContainerSpecPrivilegesSELinuxContext
-- SELinux labels of the container
data TaskSpecContainerSpecPrivilegesSELinuxContext = TaskSpecContainerSpecPrivilegesSELinuxContext
  { taskSpecContainerSpecPrivilegesSELinuxContextDisable :: !(Maybe Bool) -- ^ "Disable" - Disable SELinux
  , taskSpecContainerSpecPrivilegesSELinuxContextUser :: !(Maybe Text) -- ^ "User" - SELinux user label
  , taskSpecContainerSpecPrivilegesSELinuxContextRole :: !(Maybe Text) -- ^ "Role" - SELinux role label
  , taskSpecContainerSpecPrivilegesSELinuxContextType :: !(Maybe Text) -- ^ "Type" - SELinux type label
  , taskSpecContainerSpecPrivilegesSELinuxContextLevel :: !(Maybe Text) -- ^ "Level" - SELinux level label
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecContainerSpecPrivilegesSELinuxContext
instance A.FromJSON TaskSpecContainerSpecPrivilegesSELinuxContext where
  parseJSON = A.withObject "TaskSpecContainerSpecPrivilegesSELinuxContext" $ \o ->
    TaskSpecContainerSpecPrivilegesSELinuxContext
      <$> (o .:? "Disable")
      <*> (o .:? "User")
      <*> (o .:? "Role")
      <*> (o .:? "Type")
      <*> (o .:? "Level")

-- | ToJSON TaskSpecContainerSpecPrivilegesSELinuxContext
instance A.ToJSON TaskSpecContainerSpecPrivilegesSELinuxContext where
  toJSON TaskSpecContainerSpecPrivilegesSELinuxContext {..} =
   _omitNulls
      [ "Disable" .= taskSpecContainerSpecPrivilegesSELinuxContextDisable
      , "User" .= taskSpecContainerSpecPrivilegesSELinuxContextUser
      , "Role" .= taskSpecContainerSpecPrivilegesSELinuxContextRole
      , "Type" .= taskSpecContainerSpecPrivilegesSELinuxContextType
      , "Level" .= taskSpecContainerSpecPrivilegesSELinuxContextLevel
      ]


-- | Construct a value of type 'TaskSpecContainerSpecPrivilegesSELinuxContext' (by applying it's required fields, if any)
mkTaskSpecContainerSpecPrivilegesSELinuxContext
  :: TaskSpecContainerSpecPrivilegesSELinuxContext
mkTaskSpecContainerSpecPrivilegesSELinuxContext =
  TaskSpecContainerSpecPrivilegesSELinuxContext
  { taskSpecContainerSpecPrivilegesSELinuxContextDisable = Nothing
  , taskSpecContainerSpecPrivilegesSELinuxContextUser = Nothing
  , taskSpecContainerSpecPrivilegesSELinuxContextRole = Nothing
  , taskSpecContainerSpecPrivilegesSELinuxContextType = Nothing
  , taskSpecContainerSpecPrivilegesSELinuxContextLevel = Nothing
  }

-- ** TaskSpecContainerSpecSecrets
-- | TaskSpecContainerSpecSecrets
data TaskSpecContainerSpecSecrets = TaskSpecContainerSpecSecrets
  { taskSpecContainerSpecSecretsFile :: !(Maybe TaskSpecContainerSpecFile) -- ^ "File"
  , taskSpecContainerSpecSecretsSecretId :: !(Maybe Text) -- ^ "SecretID" - SecretID represents the ID of the specific secret that we&#39;re referencing. 
  , taskSpecContainerSpecSecretsSecretName :: !(Maybe Text) -- ^ "SecretName" - SecretName is the name of the secret that this references, but this is just provided for lookup/display purposes. The secret in the reference will be identified by its ID. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecContainerSpecSecrets
instance A.FromJSON TaskSpecContainerSpecSecrets where
  parseJSON = A.withObject "TaskSpecContainerSpecSecrets" $ \o ->
    TaskSpecContainerSpecSecrets
      <$> (o .:? "File")
      <*> (o .:? "SecretID")
      <*> (o .:? "SecretName")

-- | ToJSON TaskSpecContainerSpecSecrets
instance A.ToJSON TaskSpecContainerSpecSecrets where
  toJSON TaskSpecContainerSpecSecrets {..} =
   _omitNulls
      [ "File" .= taskSpecContainerSpecSecretsFile
      , "SecretID" .= taskSpecContainerSpecSecretsSecretId
      , "SecretName" .= taskSpecContainerSpecSecretsSecretName
      ]


-- | Construct a value of type 'TaskSpecContainerSpecSecrets' (by applying it's required fields, if any)
mkTaskSpecContainerSpecSecrets
  :: TaskSpecContainerSpecSecrets
mkTaskSpecContainerSpecSecrets =
  TaskSpecContainerSpecSecrets
  { taskSpecContainerSpecSecretsFile = Nothing
  , taskSpecContainerSpecSecretsSecretId = Nothing
  , taskSpecContainerSpecSecretsSecretName = Nothing
  }

-- ** TaskSpecLogDriver
-- | TaskSpecLogDriver
-- Specifies the log driver to use for tasks created from this spec. If not present, the default one for the swarm will be used, finally falling back to the engine default if not specified. 
data TaskSpecLogDriver = TaskSpecLogDriver
  { taskSpecLogDriverName :: !(Maybe Text) -- ^ "Name"
  , taskSpecLogDriverOptions :: !(Maybe (Map.Map String Text)) -- ^ "Options"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecLogDriver
instance A.FromJSON TaskSpecLogDriver where
  parseJSON = A.withObject "TaskSpecLogDriver" $ \o ->
    TaskSpecLogDriver
      <$> (o .:? "Name")
      <*> (o .:? "Options")

-- | ToJSON TaskSpecLogDriver
instance A.ToJSON TaskSpecLogDriver where
  toJSON TaskSpecLogDriver {..} =
   _omitNulls
      [ "Name" .= taskSpecLogDriverName
      , "Options" .= taskSpecLogDriverOptions
      ]


-- | Construct a value of type 'TaskSpecLogDriver' (by applying it's required fields, if any)
mkTaskSpecLogDriver
  :: TaskSpecLogDriver
mkTaskSpecLogDriver =
  TaskSpecLogDriver
  { taskSpecLogDriverName = Nothing
  , taskSpecLogDriverOptions = Nothing
  }

-- ** TaskSpecNetworkAttachmentSpec
-- | TaskSpecNetworkAttachmentSpec
-- Read-only spec type for non-swarm containers attached to swarm overlay networks.  <p><br /></p>  > **Note**: ContainerSpec, NetworkAttachmentSpec, and PluginSpec are > mutually exclusive. PluginSpec is only used when the Runtime field > is set to `plugin`. NetworkAttachmentSpec is used when the Runtime > field is set to `attachment`. 
data TaskSpecNetworkAttachmentSpec = TaskSpecNetworkAttachmentSpec
  { taskSpecNetworkAttachmentSpecContainerId :: !(Maybe Text) -- ^ "ContainerID" - ID of the container represented by this task
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecNetworkAttachmentSpec
instance A.FromJSON TaskSpecNetworkAttachmentSpec where
  parseJSON = A.withObject "TaskSpecNetworkAttachmentSpec" $ \o ->
    TaskSpecNetworkAttachmentSpec
      <$> (o .:? "ContainerID")

-- | ToJSON TaskSpecNetworkAttachmentSpec
instance A.ToJSON TaskSpecNetworkAttachmentSpec where
  toJSON TaskSpecNetworkAttachmentSpec {..} =
   _omitNulls
      [ "ContainerID" .= taskSpecNetworkAttachmentSpecContainerId
      ]


-- | Construct a value of type 'TaskSpecNetworkAttachmentSpec' (by applying it's required fields, if any)
mkTaskSpecNetworkAttachmentSpec
  :: TaskSpecNetworkAttachmentSpec
mkTaskSpecNetworkAttachmentSpec =
  TaskSpecNetworkAttachmentSpec
  { taskSpecNetworkAttachmentSpecContainerId = Nothing
  }

-- ** TaskSpecPlacement
-- | TaskSpecPlacement
data TaskSpecPlacement = TaskSpecPlacement
  { taskSpecPlacementConstraints :: !(Maybe [Text]) -- ^ "Constraints" - An array of constraint expressions to limit the set of nodes where a task can be scheduled. Constraint expressions can either use a _match_ (&#x60;&#x3D;&#x3D;&#x60;) or _exclude_ (&#x60;!&#x3D;&#x60;) rule. Multiple constraints find nodes that satisfy every expression (AND match). Constraints can match node or Docker Engine labels as follows:  node attribute       | matches                        | example ---------------------|--------------------------------|----------------------------------------------- &#x60;node.id&#x60;            | Node ID                        | &#x60;node.id&#x3D;&#x3D;2ivku8v2gvtg4&#x60; &#x60;node.hostname&#x60;      | Node hostname                  | &#x60;node.hostname!&#x3D;node-2&#x60; &#x60;node.role&#x60;          | Node role (&#x60;manager&#x60;/&#x60;worker&#x60;) | &#x60;node.role&#x3D;&#x3D;manager&#x60; &#x60;node.platform.os&#x60;   | Node operating system          | &#x60;node.platform.os&#x3D;&#x3D;windows&#x60; &#x60;node.platform.arch&#x60; | Node architecture              | &#x60;node.platform.arch&#x3D;&#x3D;x86_64&#x60; &#x60;node.labels&#x60;        | User-defined node labels       | &#x60;node.labels.security&#x3D;&#x3D;high&#x60; &#x60;engine.labels&#x60;      | Docker Engine&#39;s labels         | &#x60;engine.labels.operatingsystem&#x3D;&#x3D;ubuntu-14.04&#x60;  &#x60;engine.labels&#x60; apply to Docker Engine labels like operating system, drivers, etc. Swarm administrators add &#x60;node.labels&#x60; for operational purposes by using the [&#x60;node update endpoint&#x60;](#operation/NodeUpdate). 
  , taskSpecPlacementPreferences :: !(Maybe [TaskSpecPlacementPreferences]) -- ^ "Preferences" - Preferences provide a way to make the scheduler aware of factors such as topology. They are provided in order from highest to lowest precedence. 
  , taskSpecPlacementMaxReplicas :: !(Maybe Integer) -- ^ "MaxReplicas" - Maximum number of replicas for per node (default value is 0, which is unlimited) 
  , taskSpecPlacementPlatforms :: !(Maybe [Platform]) -- ^ "Platforms" - Platforms stores all the platforms that the service&#39;s image can run on. This field is used in the platform filter for scheduling. If empty, then the platform filter is off, meaning there are no scheduling restrictions. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecPlacement
instance A.FromJSON TaskSpecPlacement where
  parseJSON = A.withObject "TaskSpecPlacement" $ \o ->
    TaskSpecPlacement
      <$> (o .:? "Constraints")
      <*> (o .:? "Preferences")
      <*> (o .:? "MaxReplicas")
      <*> (o .:? "Platforms")

-- | ToJSON TaskSpecPlacement
instance A.ToJSON TaskSpecPlacement where
  toJSON TaskSpecPlacement {..} =
   _omitNulls
      [ "Constraints" .= taskSpecPlacementConstraints
      , "Preferences" .= taskSpecPlacementPreferences
      , "MaxReplicas" .= taskSpecPlacementMaxReplicas
      , "Platforms" .= taskSpecPlacementPlatforms
      ]


-- | Construct a value of type 'TaskSpecPlacement' (by applying it's required fields, if any)
mkTaskSpecPlacement
  :: TaskSpecPlacement
mkTaskSpecPlacement =
  TaskSpecPlacement
  { taskSpecPlacementConstraints = Nothing
  , taskSpecPlacementPreferences = Nothing
  , taskSpecPlacementMaxReplicas = Nothing
  , taskSpecPlacementPlatforms = Nothing
  }

-- ** TaskSpecPlacementPreferences
-- | TaskSpecPlacementPreferences
data TaskSpecPlacementPreferences = TaskSpecPlacementPreferences
  { taskSpecPlacementPreferencesSpread :: !(Maybe TaskSpecPlacementSpread) -- ^ "Spread"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecPlacementPreferences
instance A.FromJSON TaskSpecPlacementPreferences where
  parseJSON = A.withObject "TaskSpecPlacementPreferences" $ \o ->
    TaskSpecPlacementPreferences
      <$> (o .:? "Spread")

-- | ToJSON TaskSpecPlacementPreferences
instance A.ToJSON TaskSpecPlacementPreferences where
  toJSON TaskSpecPlacementPreferences {..} =
   _omitNulls
      [ "Spread" .= taskSpecPlacementPreferencesSpread
      ]


-- | Construct a value of type 'TaskSpecPlacementPreferences' (by applying it's required fields, if any)
mkTaskSpecPlacementPreferences
  :: TaskSpecPlacementPreferences
mkTaskSpecPlacementPreferences =
  TaskSpecPlacementPreferences
  { taskSpecPlacementPreferencesSpread = Nothing
  }

-- ** TaskSpecPlacementSpread
-- | TaskSpecPlacementSpread
data TaskSpecPlacementSpread = TaskSpecPlacementSpread
  { taskSpecPlacementSpreadSpreadDescriptor :: !(Maybe Text) -- ^ "SpreadDescriptor" - label descriptor, such as &#x60;engine.labels.az&#x60;. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecPlacementSpread
instance A.FromJSON TaskSpecPlacementSpread where
  parseJSON = A.withObject "TaskSpecPlacementSpread" $ \o ->
    TaskSpecPlacementSpread
      <$> (o .:? "SpreadDescriptor")

-- | ToJSON TaskSpecPlacementSpread
instance A.ToJSON TaskSpecPlacementSpread where
  toJSON TaskSpecPlacementSpread {..} =
   _omitNulls
      [ "SpreadDescriptor" .= taskSpecPlacementSpreadSpreadDescriptor
      ]


-- | Construct a value of type 'TaskSpecPlacementSpread' (by applying it's required fields, if any)
mkTaskSpecPlacementSpread
  :: TaskSpecPlacementSpread
mkTaskSpecPlacementSpread =
  TaskSpecPlacementSpread
  { taskSpecPlacementSpreadSpreadDescriptor = Nothing
  }

-- ** TaskSpecPluginSpec
-- | TaskSpecPluginSpec
-- Plugin spec for the service.  *(Experimental release only.)*  <p><br /></p>  > **Note**: ContainerSpec, NetworkAttachmentSpec, and PluginSpec are > mutually exclusive. PluginSpec is only used when the Runtime field > is set to `plugin`. NetworkAttachmentSpec is used when the Runtime > field is set to `attachment`. 
data TaskSpecPluginSpec = TaskSpecPluginSpec
  { taskSpecPluginSpecName :: !(Maybe Text) -- ^ "Name" - The name or &#39;alias&#39; to use for the plugin.
  , taskSpecPluginSpecRemote :: !(Maybe Text) -- ^ "Remote" - The plugin image reference to use.
  , taskSpecPluginSpecDisabled :: !(Maybe Bool) -- ^ "Disabled" - Disable the plugin once scheduled.
  , taskSpecPluginSpecPluginPrivilege :: !(Maybe [PluginPrivilege]) -- ^ "PluginPrivilege"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecPluginSpec
instance A.FromJSON TaskSpecPluginSpec where
  parseJSON = A.withObject "TaskSpecPluginSpec" $ \o ->
    TaskSpecPluginSpec
      <$> (o .:? "Name")
      <*> (o .:? "Remote")
      <*> (o .:? "Disabled")
      <*> (o .:? "PluginPrivilege")

-- | ToJSON TaskSpecPluginSpec
instance A.ToJSON TaskSpecPluginSpec where
  toJSON TaskSpecPluginSpec {..} =
   _omitNulls
      [ "Name" .= taskSpecPluginSpecName
      , "Remote" .= taskSpecPluginSpecRemote
      , "Disabled" .= taskSpecPluginSpecDisabled
      , "PluginPrivilege" .= taskSpecPluginSpecPluginPrivilege
      ]


-- | Construct a value of type 'TaskSpecPluginSpec' (by applying it's required fields, if any)
mkTaskSpecPluginSpec
  :: TaskSpecPluginSpec
mkTaskSpecPluginSpec =
  TaskSpecPluginSpec
  { taskSpecPluginSpecName = Nothing
  , taskSpecPluginSpecRemote = Nothing
  , taskSpecPluginSpecDisabled = Nothing
  , taskSpecPluginSpecPluginPrivilege = Nothing
  }

-- ** TaskSpecResources
-- | TaskSpecResources
-- Resource requirements which apply to each individual container created as part of the service. 
data TaskSpecResources = TaskSpecResources
  { taskSpecResourcesLimits :: !(Maybe Limit) -- ^ "Limits"
  , taskSpecResourcesReservation :: !(Maybe ResourceObject) -- ^ "Reservation"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecResources
instance A.FromJSON TaskSpecResources where
  parseJSON = A.withObject "TaskSpecResources" $ \o ->
    TaskSpecResources
      <$> (o .:? "Limits")
      <*> (o .:? "Reservation")

-- | ToJSON TaskSpecResources
instance A.ToJSON TaskSpecResources where
  toJSON TaskSpecResources {..} =
   _omitNulls
      [ "Limits" .= taskSpecResourcesLimits
      , "Reservation" .= taskSpecResourcesReservation
      ]


-- | Construct a value of type 'TaskSpecResources' (by applying it's required fields, if any)
mkTaskSpecResources
  :: TaskSpecResources
mkTaskSpecResources =
  TaskSpecResources
  { taskSpecResourcesLimits = Nothing
  , taskSpecResourcesReservation = Nothing
  }

-- ** TaskSpecRestartPolicy
-- | TaskSpecRestartPolicy
-- Specification for the restart policy which applies to containers created as part of this service. 
data TaskSpecRestartPolicy = TaskSpecRestartPolicy
  { taskSpecRestartPolicyCondition :: !(Maybe E'Condition) -- ^ "Condition" - Condition for restart.
  , taskSpecRestartPolicyDelay :: !(Maybe Integer) -- ^ "Delay" - Delay between restart attempts.
  , taskSpecRestartPolicyMaxAttempts :: !(Maybe Integer) -- ^ "MaxAttempts" - Maximum attempts to restart a given container before giving up (default value is 0, which is ignored). 
  , taskSpecRestartPolicyWindow :: !(Maybe Integer) -- ^ "Window" - Windows is the time window used to evaluate the restart policy (default value is 0, which is unbounded). 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskSpecRestartPolicy
instance A.FromJSON TaskSpecRestartPolicy where
  parseJSON = A.withObject "TaskSpecRestartPolicy" $ \o ->
    TaskSpecRestartPolicy
      <$> (o .:? "Condition")
      <*> (o .:? "Delay")
      <*> (o .:? "MaxAttempts")
      <*> (o .:? "Window")

-- | ToJSON TaskSpecRestartPolicy
instance A.ToJSON TaskSpecRestartPolicy where
  toJSON TaskSpecRestartPolicy {..} =
   _omitNulls
      [ "Condition" .= taskSpecRestartPolicyCondition
      , "Delay" .= taskSpecRestartPolicyDelay
      , "MaxAttempts" .= taskSpecRestartPolicyMaxAttempts
      , "Window" .= taskSpecRestartPolicyWindow
      ]


-- | Construct a value of type 'TaskSpecRestartPolicy' (by applying it's required fields, if any)
mkTaskSpecRestartPolicy
  :: TaskSpecRestartPolicy
mkTaskSpecRestartPolicy =
  TaskSpecRestartPolicy
  { taskSpecRestartPolicyCondition = Nothing
  , taskSpecRestartPolicyDelay = Nothing
  , taskSpecRestartPolicyMaxAttempts = Nothing
  , taskSpecRestartPolicyWindow = Nothing
  }

-- ** TaskStatus
-- | TaskStatus
data TaskStatus = TaskStatus
  { taskStatusTimestamp :: !(Maybe Text) -- ^ "Timestamp"
  , taskStatusState :: !(Maybe TaskState) -- ^ "State"
  , taskStatusMessage :: !(Maybe Text) -- ^ "Message"
  , taskStatusErr :: !(Maybe Text) -- ^ "Err"
  , taskStatusContainerStatus :: !(Maybe TaskStatusContainerStatus) -- ^ "ContainerStatus"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskStatus
instance A.FromJSON TaskStatus where
  parseJSON = A.withObject "TaskStatus" $ \o ->
    TaskStatus
      <$> (o .:? "Timestamp")
      <*> (o .:? "State")
      <*> (o .:? "Message")
      <*> (o .:? "Err")
      <*> (o .:? "ContainerStatus")

-- | ToJSON TaskStatus
instance A.ToJSON TaskStatus where
  toJSON TaskStatus {..} =
   _omitNulls
      [ "Timestamp" .= taskStatusTimestamp
      , "State" .= taskStatusState
      , "Message" .= taskStatusMessage
      , "Err" .= taskStatusErr
      , "ContainerStatus" .= taskStatusContainerStatus
      ]


-- | Construct a value of type 'TaskStatus' (by applying it's required fields, if any)
mkTaskStatus
  :: TaskStatus
mkTaskStatus =
  TaskStatus
  { taskStatusTimestamp = Nothing
  , taskStatusState = Nothing
  , taskStatusMessage = Nothing
  , taskStatusErr = Nothing
  , taskStatusContainerStatus = Nothing
  }

-- ** TaskStatusContainerStatus
-- | TaskStatusContainerStatus
data TaskStatusContainerStatus = TaskStatusContainerStatus
  { taskStatusContainerStatusContainerId :: !(Maybe Text) -- ^ "ContainerID"
  , taskStatusContainerStatusPid :: !(Maybe Int) -- ^ "PID"
  , taskStatusContainerStatusExitCode :: !(Maybe Int) -- ^ "ExitCode"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TaskStatusContainerStatus
instance A.FromJSON TaskStatusContainerStatus where
  parseJSON = A.withObject "TaskStatusContainerStatus" $ \o ->
    TaskStatusContainerStatus
      <$> (o .:? "ContainerID")
      <*> (o .:? "PID")
      <*> (o .:? "ExitCode")

-- | ToJSON TaskStatusContainerStatus
instance A.ToJSON TaskStatusContainerStatus where
  toJSON TaskStatusContainerStatus {..} =
   _omitNulls
      [ "ContainerID" .= taskStatusContainerStatusContainerId
      , "PID" .= taskStatusContainerStatusPid
      , "ExitCode" .= taskStatusContainerStatusExitCode
      ]


-- | Construct a value of type 'TaskStatusContainerStatus' (by applying it's required fields, if any)
mkTaskStatusContainerStatus
  :: TaskStatusContainerStatus
mkTaskStatusContainerStatus =
  TaskStatusContainerStatus
  { taskStatusContainerStatusContainerId = Nothing
  , taskStatusContainerStatusPid = Nothing
  , taskStatusContainerStatusExitCode = Nothing
  }

-- ** ThrottleDevice
-- | ThrottleDevice
data ThrottleDevice = ThrottleDevice
  { throttleDevicePath :: !(Maybe Text) -- ^ "Path" - Device path
  , throttleDeviceRate :: !(Maybe Integer) -- ^ "Rate" - Rate
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ThrottleDevice
instance A.FromJSON ThrottleDevice where
  parseJSON = A.withObject "ThrottleDevice" $ \o ->
    ThrottleDevice
      <$> (o .:? "Path")
      <*> (o .:? "Rate")

-- | ToJSON ThrottleDevice
instance A.ToJSON ThrottleDevice where
  toJSON ThrottleDevice {..} =
   _omitNulls
      [ "Path" .= throttleDevicePath
      , "Rate" .= throttleDeviceRate
      ]


-- | Construct a value of type 'ThrottleDevice' (by applying it's required fields, if any)
mkThrottleDevice
  :: ThrottleDevice
mkThrottleDevice =
  ThrottleDevice
  { throttleDevicePath = Nothing
  , throttleDeviceRate = Nothing
  }

-- ** UnlockKeyResponse
-- | UnlockKeyResponse
-- UnlockKeyResponse
-- 
data UnlockKeyResponse = UnlockKeyResponse
  { unlockKeyResponseUnlockKey :: !(Maybe Text) -- ^ "UnlockKey" - The swarm&#39;s unlock key.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UnlockKeyResponse
instance A.FromJSON UnlockKeyResponse where
  parseJSON = A.withObject "UnlockKeyResponse" $ \o ->
    UnlockKeyResponse
      <$> (o .:? "UnlockKey")

-- | ToJSON UnlockKeyResponse
instance A.ToJSON UnlockKeyResponse where
  toJSON UnlockKeyResponse {..} =
   _omitNulls
      [ "UnlockKey" .= unlockKeyResponseUnlockKey
      ]


-- | Construct a value of type 'UnlockKeyResponse' (by applying it's required fields, if any)
mkUnlockKeyResponse
  :: UnlockKeyResponse
mkUnlockKeyResponse =
  UnlockKeyResponse
  { unlockKeyResponseUnlockKey = Nothing
  }

-- ** Volume
-- | Volume
data Volume = Volume
  { volumeName :: !(Text) -- ^ /Required/ "Name" - Name of the volume.
  , volumeDriver :: !(Text) -- ^ /Required/ "Driver" - Name of the volume driver used by the volume.
  , volumeMountpoint :: !(Text) -- ^ /Required/ "Mountpoint" - Mount path of the volume on the host.
  , volumeCreatedAt :: !(Maybe Text) -- ^ "CreatedAt" - Date/Time the volume was created.
  , volumeStatus :: !(Maybe (Map.Map String A.Value)) -- ^ "Status" - Low-level details about the volume, provided by the volume driver. Details are returned as a map with key/value pairs: &#x60;{\&quot;key\&quot;:\&quot;value\&quot;,\&quot;key2\&quot;:\&quot;value2\&quot;}&#x60;.  The &#x60;Status&#x60; field is optional, and is omitted if the volume driver does not support this feature. 
  , volumeLabels :: !((Map.Map String Text)) -- ^ /Required/ "Labels" - User-defined key/value metadata.
  , volumeScope :: !(E'Scope) -- ^ /Required/ "Scope" - The level at which the volume exists. Either &#x60;global&#x60; for cluster-wide, or &#x60;local&#x60; for machine level. 
  , volumeOptions :: !((Map.Map String Text)) -- ^ /Required/ "Options" - The driver specific options used when creating the volume. 
  , volumeUsageData :: !(Maybe VolumeUsageData) -- ^ "UsageData"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Volume
instance A.FromJSON Volume where
  parseJSON = A.withObject "Volume" $ \o ->
    Volume
      <$> (o .:  "Name")
      <*> (o .:  "Driver")
      <*> (o .:  "Mountpoint")
      <*> (o .:? "CreatedAt")
      <*> (o .:? "Status")
      <*> (o .:  "Labels")
      <*> (o .:  "Scope")
      <*> (o .:  "Options")
      <*> (o .:? "UsageData")

-- | ToJSON Volume
instance A.ToJSON Volume where
  toJSON Volume {..} =
   _omitNulls
      [ "Name" .= volumeName
      , "Driver" .= volumeDriver
      , "Mountpoint" .= volumeMountpoint
      , "CreatedAt" .= volumeCreatedAt
      , "Status" .= volumeStatus
      , "Labels" .= volumeLabels
      , "Scope" .= volumeScope
      , "Options" .= volumeOptions
      , "UsageData" .= volumeUsageData
      ]


-- | Construct a value of type 'Volume' (by applying it's required fields, if any)
mkVolume
  :: Text -- ^ 'volumeName': Name of the volume.
  -> Text -- ^ 'volumeDriver': Name of the volume driver used by the volume.
  -> Text -- ^ 'volumeMountpoint': Mount path of the volume on the host.
  -> (Map.Map String Text) -- ^ 'volumeLabels': User-defined key/value metadata.
  -> E'Scope -- ^ 'volumeScope': The level at which the volume exists. Either `global` for cluster-wide, or `local` for machine level. 
  -> (Map.Map String Text) -- ^ 'volumeOptions': The driver specific options used when creating the volume. 
  -> Volume
mkVolume volumeName volumeDriver volumeMountpoint volumeLabels volumeScope volumeOptions =
  Volume
  { volumeName
  , volumeDriver
  , volumeMountpoint
  , volumeCreatedAt = Nothing
  , volumeStatus = Nothing
  , volumeLabels
  , volumeScope
  , volumeOptions
  , volumeUsageData = Nothing
  }

-- ** VolumeCreateOptions
-- | VolumeCreateOptions
-- VolumeConfig
-- 
-- Volume configuration
data VolumeCreateOptions = VolumeCreateOptions
  { volumeCreateOptionsName :: !(Maybe Text) -- ^ "Name" - The new volume&#39;s name. If not specified, Docker generates a name. 
  , volumeCreateOptionsDriver :: !(Maybe Text) -- ^ "Driver" - Name of the volume driver to use.
  , volumeCreateOptionsDriverOpts :: !(Maybe (Map.Map String Text)) -- ^ "DriverOpts" - A mapping of driver options and values. These options are passed directly to the driver and are driver specific. 
  , volumeCreateOptionsLabels :: !(Maybe (Map.Map String Text)) -- ^ "Labels" - User-defined key/value metadata.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VolumeCreateOptions
instance A.FromJSON VolumeCreateOptions where
  parseJSON = A.withObject "VolumeCreateOptions" $ \o ->
    VolumeCreateOptions
      <$> (o .:? "Name")
      <*> (o .:? "Driver")
      <*> (o .:? "DriverOpts")
      <*> (o .:? "Labels")

-- | ToJSON VolumeCreateOptions
instance A.ToJSON VolumeCreateOptions where
  toJSON VolumeCreateOptions {..} =
   _omitNulls
      [ "Name" .= volumeCreateOptionsName
      , "Driver" .= volumeCreateOptionsDriver
      , "DriverOpts" .= volumeCreateOptionsDriverOpts
      , "Labels" .= volumeCreateOptionsLabels
      ]


-- | Construct a value of type 'VolumeCreateOptions' (by applying it's required fields, if any)
mkVolumeCreateOptions
  :: VolumeCreateOptions
mkVolumeCreateOptions =
  VolumeCreateOptions
  { volumeCreateOptionsName = Nothing
  , volumeCreateOptionsDriver = Nothing
  , volumeCreateOptionsDriverOpts = Nothing
  , volumeCreateOptionsLabels = Nothing
  }

-- ** VolumeListResponse
-- | VolumeListResponse
-- VolumeListResponse
-- 
-- Volume list response
data VolumeListResponse = VolumeListResponse
  { volumeListResponseVolumes :: !([Volume]) -- ^ /Required/ "Volumes" - List of volumes
  , volumeListResponseWarnings :: !([Text]) -- ^ /Required/ "Warnings" - Warnings that occurred when fetching the list of volumes. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VolumeListResponse
instance A.FromJSON VolumeListResponse where
  parseJSON = A.withObject "VolumeListResponse" $ \o ->
    VolumeListResponse
      <$> (o .:  "Volumes")
      <*> (o .:  "Warnings")

-- | ToJSON VolumeListResponse
instance A.ToJSON VolumeListResponse where
  toJSON VolumeListResponse {..} =
   _omitNulls
      [ "Volumes" .= volumeListResponseVolumes
      , "Warnings" .= volumeListResponseWarnings
      ]


-- | Construct a value of type 'VolumeListResponse' (by applying it's required fields, if any)
mkVolumeListResponse
  :: [Volume] -- ^ 'volumeListResponseVolumes': List of volumes
  -> [Text] -- ^ 'volumeListResponseWarnings': Warnings that occurred when fetching the list of volumes. 
  -> VolumeListResponse
mkVolumeListResponse volumeListResponseVolumes volumeListResponseWarnings =
  VolumeListResponse
  { volumeListResponseVolumes
  , volumeListResponseWarnings
  }

-- ** VolumePruneResponse
-- | VolumePruneResponse
-- VolumePruneResponse
-- 
data VolumePruneResponse = VolumePruneResponse
  { volumePruneResponseVolumesDeleted :: !(Maybe [Text]) -- ^ "VolumesDeleted" - Volumes that were deleted
  , volumePruneResponseSpaceReclaimed :: !(Maybe Integer) -- ^ "SpaceReclaimed" - Disk space reclaimed in bytes
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VolumePruneResponse
instance A.FromJSON VolumePruneResponse where
  parseJSON = A.withObject "VolumePruneResponse" $ \o ->
    VolumePruneResponse
      <$> (o .:? "VolumesDeleted")
      <*> (o .:? "SpaceReclaimed")

-- | ToJSON VolumePruneResponse
instance A.ToJSON VolumePruneResponse where
  toJSON VolumePruneResponse {..} =
   _omitNulls
      [ "VolumesDeleted" .= volumePruneResponseVolumesDeleted
      , "SpaceReclaimed" .= volumePruneResponseSpaceReclaimed
      ]


-- | Construct a value of type 'VolumePruneResponse' (by applying it's required fields, if any)
mkVolumePruneResponse
  :: VolumePruneResponse
mkVolumePruneResponse =
  VolumePruneResponse
  { volumePruneResponseVolumesDeleted = Nothing
  , volumePruneResponseSpaceReclaimed = Nothing
  }

-- ** VolumeUsageData
-- | VolumeUsageData
-- Usage details about the volume. This information is used by the `GET /system/df` endpoint, and omitted in other endpoints. 
data VolumeUsageData = VolumeUsageData
  { volumeUsageDataSize :: !(Int) -- ^ /Required/ "Size" - Amount of disk space used by the volume (in bytes). This information is only available for volumes created with the &#x60;\&quot;local\&quot;&#x60; volume driver. For volumes created with other volume drivers, this field is set to &#x60;-1&#x60; (\&quot;not available\&quot;) 
  , volumeUsageDataRefCount :: !(Int) -- ^ /Required/ "RefCount" - The number of containers referencing this volume. This field is set to &#x60;-1&#x60; if the reference-count is not available. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON VolumeUsageData
instance A.FromJSON VolumeUsageData where
  parseJSON = A.withObject "VolumeUsageData" $ \o ->
    VolumeUsageData
      <$> (o .:  "Size")
      <*> (o .:  "RefCount")

-- | ToJSON VolumeUsageData
instance A.ToJSON VolumeUsageData where
  toJSON VolumeUsageData {..} =
   _omitNulls
      [ "Size" .= volumeUsageDataSize
      , "RefCount" .= volumeUsageDataRefCount
      ]


-- | Construct a value of type 'VolumeUsageData' (by applying it's required fields, if any)
mkVolumeUsageData
  :: Int -- ^ 'volumeUsageDataSize': Amount of disk space used by the volume (in bytes). This information is only available for volumes created with the `\"local\"` volume driver. For volumes created with other volume drivers, this field is set to `-1` (\"not available\") 
  -> Int -- ^ 'volumeUsageDataRefCount': The number of containers referencing this volume. This field is set to `-1` if the reference-count is not available. 
  -> VolumeUsageData
mkVolumeUsageData volumeUsageDataSize volumeUsageDataRefCount =
  VolumeUsageData
  { volumeUsageDataSize
  , volumeUsageDataRefCount
  }


-- * Enums


-- ** E'Availability

-- | Enum of 'Text' .
-- Availability of the node.
data E'Availability
  = E'Availability'Active -- ^ @"active"@
  | E'Availability'Pause -- ^ @"pause"@
  | E'Availability'Drain -- ^ @"drain"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Availability where toJSON = A.toJSON . fromE'Availability
instance A.FromJSON E'Availability where parseJSON o = P.either P.fail (pure . P.id) . toE'Availability =<< A.parseJSON o
instance WH.ToHttpApiData E'Availability where toQueryParam = WH.toQueryParam . fromE'Availability
instance WH.FromHttpApiData E'Availability where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Availability
instance MimeRender MimeMultipartFormData E'Availability where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Availability' enum
fromE'Availability :: E'Availability -> Text
fromE'Availability = \case
  E'Availability'Active -> "active"
  E'Availability'Pause -> "pause"
  E'Availability'Drain -> "drain"

-- | parse 'E'Availability' enum
toE'Availability :: Text -> P.Either String E'Availability
toE'Availability = \case
  "active" -> P.Right E'Availability'Active
  "pause" -> P.Right E'Availability'Pause
  "drain" -> P.Right E'Availability'Drain
  s -> P.Left $ "toE'Availability: enum parse failure: " P.++ P.show s


-- ** E'CgroupDriver

-- | Enum of 'Text' .
-- The driver to use for managing cgroups. 
data E'CgroupDriver
  = E'CgroupDriver'Cgroupfs -- ^ @"cgroupfs"@
  | E'CgroupDriver'Systemd -- ^ @"systemd"@
  | E'CgroupDriver'None -- ^ @"none"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'CgroupDriver where toJSON = A.toJSON . fromE'CgroupDriver
instance A.FromJSON E'CgroupDriver where parseJSON o = P.either P.fail (pure . P.id) . toE'CgroupDriver =<< A.parseJSON o
instance WH.ToHttpApiData E'CgroupDriver where toQueryParam = WH.toQueryParam . fromE'CgroupDriver
instance WH.FromHttpApiData E'CgroupDriver where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'CgroupDriver
instance MimeRender MimeMultipartFormData E'CgroupDriver where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'CgroupDriver' enum
fromE'CgroupDriver :: E'CgroupDriver -> Text
fromE'CgroupDriver = \case
  E'CgroupDriver'Cgroupfs -> "cgroupfs"
  E'CgroupDriver'Systemd -> "systemd"
  E'CgroupDriver'None -> "none"

-- | parse 'E'CgroupDriver' enum
toE'CgroupDriver :: Text -> P.Either String E'CgroupDriver
toE'CgroupDriver = \case
  "cgroupfs" -> P.Right E'CgroupDriver'Cgroupfs
  "systemd" -> P.Right E'CgroupDriver'Systemd
  "none" -> P.Right E'CgroupDriver'None
  s -> P.Left $ "toE'CgroupDriver: enum parse failure: " P.++ P.show s


-- ** E'CgroupVersion

-- | Enum of 'Text' .
-- The version of the cgroup. 
data E'CgroupVersion
  = E'CgroupVersion'1 -- ^ @"1"@
  | E'CgroupVersion'2 -- ^ @"2"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'CgroupVersion where toJSON = A.toJSON . fromE'CgroupVersion
instance A.FromJSON E'CgroupVersion where parseJSON o = P.either P.fail (pure . P.id) . toE'CgroupVersion =<< A.parseJSON o
instance WH.ToHttpApiData E'CgroupVersion where toQueryParam = WH.toQueryParam . fromE'CgroupVersion
instance WH.FromHttpApiData E'CgroupVersion where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'CgroupVersion
instance MimeRender MimeMultipartFormData E'CgroupVersion where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'CgroupVersion' enum
fromE'CgroupVersion :: E'CgroupVersion -> Text
fromE'CgroupVersion = \case
  E'CgroupVersion'1 -> "1"
  E'CgroupVersion'2 -> "2"

-- | parse 'E'CgroupVersion' enum
toE'CgroupVersion :: Text -> P.Either String E'CgroupVersion
toE'CgroupVersion = \case
  "1" -> P.Right E'CgroupVersion'1
  "2" -> P.Right E'CgroupVersion'2
  s -> P.Left $ "toE'CgroupVersion: enum parse failure: " P.++ P.show s


-- ** E'CgroupnsMode

-- | Enum of 'Text' .
-- cgroup namespace mode for the container. Possible values are:  - `\"private\"`: the container runs in its own private cgroup namespace - `\"host\"`: use the host system's cgroup namespace  If not specified, the daemon default is used, which can either be `\"private\"` or `\"host\"`, depending on daemon version, kernel support and configuration. 
data E'CgroupnsMode
  = E'CgroupnsMode'Private -- ^ @"private"@
  | E'CgroupnsMode'Host -- ^ @"host"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'CgroupnsMode where toJSON = A.toJSON . fromE'CgroupnsMode
instance A.FromJSON E'CgroupnsMode where parseJSON o = P.either P.fail (pure . P.id) . toE'CgroupnsMode =<< A.parseJSON o
instance WH.ToHttpApiData E'CgroupnsMode where toQueryParam = WH.toQueryParam . fromE'CgroupnsMode
instance WH.FromHttpApiData E'CgroupnsMode where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'CgroupnsMode
instance MimeRender MimeMultipartFormData E'CgroupnsMode where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'CgroupnsMode' enum
fromE'CgroupnsMode :: E'CgroupnsMode -> Text
fromE'CgroupnsMode = \case
  E'CgroupnsMode'Private -> "private"
  E'CgroupnsMode'Host -> "host"

-- | parse 'E'CgroupnsMode' enum
toE'CgroupnsMode :: Text -> P.Either String E'CgroupnsMode
toE'CgroupnsMode = \case
  "private" -> P.Right E'CgroupnsMode'Private
  "host" -> P.Right E'CgroupnsMode'Host
  s -> P.Left $ "toE'CgroupnsMode: enum parse failure: " P.++ P.show s


-- ** E'Condition

-- | Enum of 'Text' .
-- Condition for restart.
data E'Condition
  = E'Condition'None -- ^ @"none"@
  | E'Condition'On_failure -- ^ @"on-failure"@
  | E'Condition'Any -- ^ @"any"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Condition where toJSON = A.toJSON . fromE'Condition
instance A.FromJSON E'Condition where parseJSON o = P.either P.fail (pure . P.id) . toE'Condition =<< A.parseJSON o
instance WH.ToHttpApiData E'Condition where toQueryParam = WH.toQueryParam . fromE'Condition
instance WH.FromHttpApiData E'Condition where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Condition
instance MimeRender MimeMultipartFormData E'Condition where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Condition' enum
fromE'Condition :: E'Condition -> Text
fromE'Condition = \case
  E'Condition'None -> "none"
  E'Condition'On_failure -> "on-failure"
  E'Condition'Any -> "any"

-- | parse 'E'Condition' enum
toE'Condition :: Text -> P.Either String E'Condition
toE'Condition = \case
  "none" -> P.Right E'Condition'None
  "on-failure" -> P.Right E'Condition'On_failure
  "any" -> P.Right E'Condition'Any
  s -> P.Left $ "toE'Condition: enum parse failure: " P.++ P.show s


-- ** E'Condition2

-- | Enum of 'Text'
data E'Condition2
  = E'Condition2'Not_running -- ^ @"not-running"@
  | E'Condition2'Next_exit -- ^ @"next-exit"@
  | E'Condition2'Removed -- ^ @"removed"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Condition2 where toJSON = A.toJSON . fromE'Condition2
instance A.FromJSON E'Condition2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Condition2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Condition2 where toQueryParam = WH.toQueryParam . fromE'Condition2
instance WH.FromHttpApiData E'Condition2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Condition2
instance MimeRender MimeMultipartFormData E'Condition2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Condition2' enum
fromE'Condition2 :: E'Condition2 -> Text
fromE'Condition2 = \case
  E'Condition2'Not_running -> "not-running"
  E'Condition2'Next_exit -> "next-exit"
  E'Condition2'Removed -> "removed"

-- | parse 'E'Condition2' enum
toE'Condition2 :: Text -> P.Either String E'Condition2
toE'Condition2 = \case
  "not-running" -> P.Right E'Condition2'Not_running
  "next-exit" -> P.Right E'Condition2'Next_exit
  "removed" -> P.Right E'Condition2'Removed
  s -> P.Left $ "toE'Condition2: enum parse failure: " P.++ P.show s


-- ** E'ContentType

-- | Enum of 'Text'
data E'ContentType
  = E'ContentType'Application_x_tar -- ^ @"application/x-tar"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ContentType where toJSON = A.toJSON . fromE'ContentType
instance A.FromJSON E'ContentType where parseJSON o = P.either P.fail (pure . P.id) . toE'ContentType =<< A.parseJSON o
instance WH.ToHttpApiData E'ContentType where toQueryParam = WH.toQueryParam . fromE'ContentType
instance WH.FromHttpApiData E'ContentType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ContentType
instance MimeRender MimeMultipartFormData E'ContentType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ContentType' enum
fromE'ContentType :: E'ContentType -> Text
fromE'ContentType = \case
  E'ContentType'Application_x_tar -> "application/x-tar"

-- | parse 'E'ContentType' enum
toE'ContentType :: Text -> P.Either String E'ContentType
toE'ContentType = \case
  "application/x-tar" -> P.Right E'ContentType'Application_x_tar
  s -> P.Left $ "toE'ContentType: enum parse failure: " P.++ P.show s


-- ** E'FailureAction

-- | Enum of 'Text' .
-- Action to take if an updated task fails to run, or stops running during the update. 
data E'FailureAction
  = E'FailureAction'Continue -- ^ @"continue"@
  | E'FailureAction'Pause -- ^ @"pause"@
  | E'FailureAction'Rollback -- ^ @"rollback"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'FailureAction where toJSON = A.toJSON . fromE'FailureAction
instance A.FromJSON E'FailureAction where parseJSON o = P.either P.fail (pure . P.id) . toE'FailureAction =<< A.parseJSON o
instance WH.ToHttpApiData E'FailureAction where toQueryParam = WH.toQueryParam . fromE'FailureAction
instance WH.FromHttpApiData E'FailureAction where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'FailureAction
instance MimeRender MimeMultipartFormData E'FailureAction where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'FailureAction' enum
fromE'FailureAction :: E'FailureAction -> Text
fromE'FailureAction = \case
  E'FailureAction'Continue -> "continue"
  E'FailureAction'Pause -> "pause"
  E'FailureAction'Rollback -> "rollback"

-- | parse 'E'FailureAction' enum
toE'FailureAction :: Text -> P.Either String E'FailureAction
toE'FailureAction = \case
  "continue" -> P.Right E'FailureAction'Continue
  "pause" -> P.Right E'FailureAction'Pause
  "rollback" -> P.Right E'FailureAction'Rollback
  s -> P.Left $ "toE'FailureAction: enum parse failure: " P.++ P.show s


-- ** E'FailureAction2

-- | Enum of 'Text' .
-- Action to take if an rolled back task fails to run, or stops running during the rollback. 
data E'FailureAction2
  = E'FailureAction2'Continue -- ^ @"continue"@
  | E'FailureAction2'Pause -- ^ @"pause"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'FailureAction2 where toJSON = A.toJSON . fromE'FailureAction2
instance A.FromJSON E'FailureAction2 where parseJSON o = P.either P.fail (pure . P.id) . toE'FailureAction2 =<< A.parseJSON o
instance WH.ToHttpApiData E'FailureAction2 where toQueryParam = WH.toQueryParam . fromE'FailureAction2
instance WH.FromHttpApiData E'FailureAction2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'FailureAction2
instance MimeRender MimeMultipartFormData E'FailureAction2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'FailureAction2' enum
fromE'FailureAction2 :: E'FailureAction2 -> Text
fromE'FailureAction2 = \case
  E'FailureAction2'Continue -> "continue"
  E'FailureAction2'Pause -> "pause"

-- | parse 'E'FailureAction2' enum
toE'FailureAction2 :: Text -> P.Either String E'FailureAction2
toE'FailureAction2 = \case
  "continue" -> P.Right E'FailureAction2'Continue
  "pause" -> P.Right E'FailureAction2'Pause
  s -> P.Left $ "toE'FailureAction2: enum parse failure: " P.++ P.show s


-- ** E'Isolation

-- | Enum of 'Text' .
-- Isolation technology of the container. (Windows only) 
data E'Isolation
  = E'Isolation'Default -- ^ @"default"@
  | E'Isolation'Process -- ^ @"process"@
  | E'Isolation'Hyperv -- ^ @"hyperv"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Isolation where toJSON = A.toJSON . fromE'Isolation
instance A.FromJSON E'Isolation where parseJSON o = P.either P.fail (pure . P.id) . toE'Isolation =<< A.parseJSON o
instance WH.ToHttpApiData E'Isolation where toQueryParam = WH.toQueryParam . fromE'Isolation
instance WH.FromHttpApiData E'Isolation where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Isolation
instance MimeRender MimeMultipartFormData E'Isolation where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Isolation' enum
fromE'Isolation :: E'Isolation -> Text
fromE'Isolation = \case
  E'Isolation'Default -> "default"
  E'Isolation'Process -> "process"
  E'Isolation'Hyperv -> "hyperv"

-- | parse 'E'Isolation' enum
toE'Isolation :: Text -> P.Either String E'Isolation
toE'Isolation = \case
  "default" -> P.Right E'Isolation'Default
  "process" -> P.Right E'Isolation'Process
  "hyperv" -> P.Right E'Isolation'Hyperv
  s -> P.Left $ "toE'Isolation: enum parse failure: " P.++ P.show s


-- ** E'Isolation2

-- | Enum of 'Text' .
-- Represents the isolation technology to use as a default for containers. The supported values are platform-specific.  If no isolation value is specified on daemon start, on Windows client, the default is `hyperv`, and on Windows server, the default is `process`.  This option is currently not used on other platforms. 
data E'Isolation2
  = E'Isolation2'Default -- ^ @"default"@
  | E'Isolation2'Hyperv -- ^ @"hyperv"@
  | E'Isolation2'Process -- ^ @"process"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Isolation2 where toJSON = A.toJSON . fromE'Isolation2
instance A.FromJSON E'Isolation2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Isolation2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Isolation2 where toQueryParam = WH.toQueryParam . fromE'Isolation2
instance WH.FromHttpApiData E'Isolation2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Isolation2
instance MimeRender MimeMultipartFormData E'Isolation2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Isolation2' enum
fromE'Isolation2 :: E'Isolation2 -> Text
fromE'Isolation2 = \case
  E'Isolation2'Default -> "default"
  E'Isolation2'Hyperv -> "hyperv"
  E'Isolation2'Process -> "process"

-- | parse 'E'Isolation2' enum
toE'Isolation2 :: Text -> P.Either String E'Isolation2
toE'Isolation2 = \case
  "default" -> P.Right E'Isolation2'Default
  "hyperv" -> P.Right E'Isolation2'Hyperv
  "process" -> P.Right E'Isolation2'Process
  s -> P.Left $ "toE'Isolation2: enum parse failure: " P.++ P.show s


-- ** E'Mode

-- | Enum of 'Text' .
-- The mode of resolution to use for internal load balancing between tasks. 
data E'Mode
  = E'Mode'Vip -- ^ @"vip"@
  | E'Mode'Dnsrr -- ^ @"dnsrr"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Mode where toJSON = A.toJSON . fromE'Mode
instance A.FromJSON E'Mode where parseJSON o = P.either P.fail (pure . P.id) . toE'Mode =<< A.parseJSON o
instance WH.ToHttpApiData E'Mode where toQueryParam = WH.toQueryParam . fromE'Mode
instance WH.FromHttpApiData E'Mode where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Mode
instance MimeRender MimeMultipartFormData E'Mode where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Mode' enum
fromE'Mode :: E'Mode -> Text
fromE'Mode = \case
  E'Mode'Vip -> "vip"
  E'Mode'Dnsrr -> "dnsrr"

-- | parse 'E'Mode' enum
toE'Mode :: Text -> P.Either String E'Mode
toE'Mode = \case
  "vip" -> P.Right E'Mode'Vip
  "dnsrr" -> P.Right E'Mode'Dnsrr
  s -> P.Left $ "toE'Mode: enum parse failure: " P.++ P.show s


-- ** E'Name

-- | Enum of 'Text' .
-- - Empty string means not to restart - `no` Do not automatically restart - `always` Always restart - `unless-stopped` Restart always except when the user has manually stopped the container - `on-failure` Restart only when the container exit code is non-zero 
data E'Name
  = E'Name'Empty -- ^ @""@
  | E'Name'No -- ^ @"no"@
  | E'Name'Always -- ^ @"always"@
  | E'Name'Unless_stopped -- ^ @"unless-stopped"@
  | E'Name'On_failure -- ^ @"on-failure"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Name where toJSON = A.toJSON . fromE'Name
instance A.FromJSON E'Name where parseJSON o = P.either P.fail (pure . P.id) . toE'Name =<< A.parseJSON o
instance WH.ToHttpApiData E'Name where toQueryParam = WH.toQueryParam . fromE'Name
instance WH.FromHttpApiData E'Name where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Name
instance MimeRender MimeMultipartFormData E'Name where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Name' enum
fromE'Name :: E'Name -> Text
fromE'Name = \case
  E'Name'Empty -> ""
  E'Name'No -> "no"
  E'Name'Always -> "always"
  E'Name'Unless_stopped -> "unless-stopped"
  E'Name'On_failure -> "on-failure"

-- | parse 'E'Name' enum
toE'Name :: Text -> P.Either String E'Name
toE'Name = \case
  "" -> P.Right E'Name'Empty
  "no" -> P.Right E'Name'No
  "always" -> P.Right E'Name'Always
  "unless-stopped" -> P.Right E'Name'Unless_stopped
  "on-failure" -> P.Right E'Name'On_failure
  s -> P.Left $ "toE'Name: enum parse failure: " P.++ P.show s


-- ** E'Order

-- | Enum of 'Text' .
-- The order of operations when rolling out an updated task. Either the old task is shut down before the new task is started, or the new task is started before the old task is shut down. 
data E'Order
  = E'Order'Stop_first -- ^ @"stop-first"@
  | E'Order'Start_first -- ^ @"start-first"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Order where toJSON = A.toJSON . fromE'Order
instance A.FromJSON E'Order where parseJSON o = P.either P.fail (pure . P.id) . toE'Order =<< A.parseJSON o
instance WH.ToHttpApiData E'Order where toQueryParam = WH.toQueryParam . fromE'Order
instance WH.FromHttpApiData E'Order where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Order
instance MimeRender MimeMultipartFormData E'Order where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Order' enum
fromE'Order :: E'Order -> Text
fromE'Order = \case
  E'Order'Stop_first -> "stop-first"
  E'Order'Start_first -> "start-first"

-- | parse 'E'Order' enum
toE'Order :: Text -> P.Either String E'Order
toE'Order = \case
  "stop-first" -> P.Right E'Order'Stop_first
  "start-first" -> P.Right E'Order'Start_first
  s -> P.Left $ "toE'Order: enum parse failure: " P.++ P.show s


-- ** E'Propagation

-- | Enum of 'Text' .
-- A propagation mode with the value `[r]private`, `[r]shared`, or `[r]slave`.
data E'Propagation
  = E'Propagation'Private -- ^ @"private"@
  | E'Propagation'Rprivate -- ^ @"rprivate"@
  | E'Propagation'Shared -- ^ @"shared"@
  | E'Propagation'Rshared -- ^ @"rshared"@
  | E'Propagation'Slave -- ^ @"slave"@
  | E'Propagation'Rslave -- ^ @"rslave"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Propagation where toJSON = A.toJSON . fromE'Propagation
instance A.FromJSON E'Propagation where parseJSON o = P.either P.fail (pure . P.id) . toE'Propagation =<< A.parseJSON o
instance WH.ToHttpApiData E'Propagation where toQueryParam = WH.toQueryParam . fromE'Propagation
instance WH.FromHttpApiData E'Propagation where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Propagation
instance MimeRender MimeMultipartFormData E'Propagation where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Propagation' enum
fromE'Propagation :: E'Propagation -> Text
fromE'Propagation = \case
  E'Propagation'Private -> "private"
  E'Propagation'Rprivate -> "rprivate"
  E'Propagation'Shared -> "shared"
  E'Propagation'Rshared -> "rshared"
  E'Propagation'Slave -> "slave"
  E'Propagation'Rslave -> "rslave"

-- | parse 'E'Propagation' enum
toE'Propagation :: Text -> P.Either String E'Propagation
toE'Propagation = \case
  "private" -> P.Right E'Propagation'Private
  "rprivate" -> P.Right E'Propagation'Rprivate
  "shared" -> P.Right E'Propagation'Shared
  "rshared" -> P.Right E'Propagation'Rshared
  "slave" -> P.Right E'Propagation'Slave
  "rslave" -> P.Right E'Propagation'Rslave
  s -> P.Left $ "toE'Propagation: enum parse failure: " P.++ P.show s


-- ** E'Protocol

-- | Enum of 'Text' .
-- Protocol for communication with the external CA (currently only `cfssl` is supported). 
data E'Protocol
  = E'Protocol'Cfssl -- ^ @"cfssl"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Protocol where toJSON = A.toJSON . fromE'Protocol
instance A.FromJSON E'Protocol where parseJSON o = P.either P.fail (pure . P.id) . toE'Protocol =<< A.parseJSON o
instance WH.ToHttpApiData E'Protocol where toQueryParam = WH.toQueryParam . fromE'Protocol
instance WH.FromHttpApiData E'Protocol where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Protocol
instance MimeRender MimeMultipartFormData E'Protocol where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Protocol' enum
fromE'Protocol :: E'Protocol -> Text
fromE'Protocol = \case
  E'Protocol'Cfssl -> "cfssl"

-- | parse 'E'Protocol' enum
toE'Protocol :: Text -> P.Either String E'Protocol
toE'Protocol = \case
  "cfssl" -> P.Right E'Protocol'Cfssl
  s -> P.Left $ "toE'Protocol: enum parse failure: " P.++ P.show s


-- ** E'ProtocolScheme

-- | Enum of 'Text' .
-- Protocol to use for clients connecting to the plugin.
data E'ProtocolScheme
  = E'ProtocolScheme'Empty -- ^ @""@
  | E'ProtocolScheme'Moby_plugins_http_v1 -- ^ @"moby.plugins.http/v1"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ProtocolScheme where toJSON = A.toJSON . fromE'ProtocolScheme
instance A.FromJSON E'ProtocolScheme where parseJSON o = P.either P.fail (pure . P.id) . toE'ProtocolScheme =<< A.parseJSON o
instance WH.ToHttpApiData E'ProtocolScheme where toQueryParam = WH.toQueryParam . fromE'ProtocolScheme
instance WH.FromHttpApiData E'ProtocolScheme where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ProtocolScheme
instance MimeRender MimeMultipartFormData E'ProtocolScheme where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ProtocolScheme' enum
fromE'ProtocolScheme :: E'ProtocolScheme -> Text
fromE'ProtocolScheme = \case
  E'ProtocolScheme'Empty -> ""
  E'ProtocolScheme'Moby_plugins_http_v1 -> "moby.plugins.http/v1"

-- | parse 'E'ProtocolScheme' enum
toE'ProtocolScheme :: Text -> P.Either String E'ProtocolScheme
toE'ProtocolScheme = \case
  "" -> P.Right E'ProtocolScheme'Empty
  "moby.plugins.http/v1" -> P.Right E'ProtocolScheme'Moby_plugins_http_v1
  s -> P.Left $ "toE'ProtocolScheme: enum parse failure: " P.++ P.show s


-- ** E'PublishMode

-- | Enum of 'Text' .
-- The mode in which port is published.  <p><br /></p>  - \"ingress\" makes the target port accessible on every node,   regardless of whether there is a task for the service running on   that node or not. - \"host\" bypasses the routing mesh and publish the port directly on   the swarm node where that service is running. 
data E'PublishMode
  = E'PublishMode'Ingress -- ^ @"ingress"@
  | E'PublishMode'Host -- ^ @"host"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'PublishMode where toJSON = A.toJSON . fromE'PublishMode
instance A.FromJSON E'PublishMode where parseJSON o = P.either P.fail (pure . P.id) . toE'PublishMode =<< A.parseJSON o
instance WH.ToHttpApiData E'PublishMode where toQueryParam = WH.toQueryParam . fromE'PublishMode
instance WH.FromHttpApiData E'PublishMode where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'PublishMode
instance MimeRender MimeMultipartFormData E'PublishMode where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'PublishMode' enum
fromE'PublishMode :: E'PublishMode -> Text
fromE'PublishMode = \case
  E'PublishMode'Ingress -> "ingress"
  E'PublishMode'Host -> "host"

-- | parse 'E'PublishMode' enum
toE'PublishMode :: Text -> P.Either String E'PublishMode
toE'PublishMode = \case
  "ingress" -> P.Right E'PublishMode'Ingress
  "host" -> P.Right E'PublishMode'Host
  s -> P.Left $ "toE'PublishMode: enum parse failure: " P.++ P.show s


-- ** E'RegistryAuthFrom

-- | Enum of 'Text'
data E'RegistryAuthFrom
  = E'RegistryAuthFrom'Spec -- ^ @"spec"@
  | E'RegistryAuthFrom'Previous_spec -- ^ @"previous-spec"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'RegistryAuthFrom where toJSON = A.toJSON . fromE'RegistryAuthFrom
instance A.FromJSON E'RegistryAuthFrom where parseJSON o = P.either P.fail (pure . P.id) . toE'RegistryAuthFrom =<< A.parseJSON o
instance WH.ToHttpApiData E'RegistryAuthFrom where toQueryParam = WH.toQueryParam . fromE'RegistryAuthFrom
instance WH.FromHttpApiData E'RegistryAuthFrom where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'RegistryAuthFrom
instance MimeRender MimeMultipartFormData E'RegistryAuthFrom where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'RegistryAuthFrom' enum
fromE'RegistryAuthFrom :: E'RegistryAuthFrom -> Text
fromE'RegistryAuthFrom = \case
  E'RegistryAuthFrom'Spec -> "spec"
  E'RegistryAuthFrom'Previous_spec -> "previous-spec"

-- | parse 'E'RegistryAuthFrom' enum
toE'RegistryAuthFrom :: Text -> P.Either String E'RegistryAuthFrom
toE'RegistryAuthFrom = \case
  "spec" -> P.Right E'RegistryAuthFrom'Spec
  "previous-spec" -> P.Right E'RegistryAuthFrom'Previous_spec
  s -> P.Left $ "toE'RegistryAuthFrom: enum parse failure: " P.++ P.show s


-- ** E'Role

-- | Enum of 'Text' .
-- Role of the node.
data E'Role
  = E'Role'Worker -- ^ @"worker"@
  | E'Role'Manager -- ^ @"manager"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Role where toJSON = A.toJSON . fromE'Role
instance A.FromJSON E'Role where parseJSON o = P.either P.fail (pure . P.id) . toE'Role =<< A.parseJSON o
instance WH.ToHttpApiData E'Role where toQueryParam = WH.toQueryParam . fromE'Role
instance WH.FromHttpApiData E'Role where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Role
instance MimeRender MimeMultipartFormData E'Role where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Role' enum
fromE'Role :: E'Role -> Text
fromE'Role = \case
  E'Role'Worker -> "worker"
  E'Role'Manager -> "manager"

-- | parse 'E'Role' enum
toE'Role :: Text -> P.Either String E'Role
toE'Role = \case
  "worker" -> P.Right E'Role'Worker
  "manager" -> P.Right E'Role'Manager
  s -> P.Left $ "toE'Role: enum parse failure: " P.++ P.show s


-- ** E'Scope

-- | Enum of 'Text' .
-- The level at which the volume exists. Either `global` for cluster-wide, or `local` for machine level. 
data E'Scope
  = E'Scope'Local -- ^ @"local"@
  | E'Scope'Global -- ^ @"global"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Scope where toJSON = A.toJSON . fromE'Scope
instance A.FromJSON E'Scope where parseJSON o = P.either P.fail (pure . P.id) . toE'Scope =<< A.parseJSON o
instance WH.ToHttpApiData E'Scope where toQueryParam = WH.toQueryParam . fromE'Scope
instance WH.FromHttpApiData E'Scope where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Scope
instance MimeRender MimeMultipartFormData E'Scope where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Scope' enum
fromE'Scope :: E'Scope -> Text
fromE'Scope = \case
  E'Scope'Local -> "local"
  E'Scope'Global -> "global"

-- | parse 'E'Scope' enum
toE'Scope :: Text -> P.Either String E'Scope
toE'Scope = \case
  "local" -> P.Right E'Scope'Local
  "global" -> P.Right E'Scope'Global
  s -> P.Left $ "toE'Scope: enum parse failure: " P.++ P.show s


-- ** E'Scope2

-- | Enum of 'Text' .
-- Scope of the event. Engine events are `local` scope. Cluster (Swarm) events are `swarm` scope. 
data E'Scope2
  = E'Scope2'Local -- ^ @"local"@
  | E'Scope2'Swarm -- ^ @"swarm"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Scope2 where toJSON = A.toJSON . fromE'Scope2
instance A.FromJSON E'Scope2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Scope2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Scope2 where toQueryParam = WH.toQueryParam . fromE'Scope2
instance WH.FromHttpApiData E'Scope2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Scope2
instance MimeRender MimeMultipartFormData E'Scope2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Scope2' enum
fromE'Scope2 :: E'Scope2 -> Text
fromE'Scope2 = \case
  E'Scope2'Local -> "local"
  E'Scope2'Swarm -> "swarm"

-- | parse 'E'Scope2' enum
toE'Scope2 :: Text -> P.Either String E'Scope2
toE'Scope2 = \case
  "local" -> P.Right E'Scope2'Local
  "swarm" -> P.Right E'Scope2'Swarm
  s -> P.Left $ "toE'Scope2: enum parse failure: " P.++ P.show s


-- ** E'State

-- | Enum of 'Text'
data E'State
  = E'State'Updating -- ^ @"updating"@
  | E'State'Paused -- ^ @"paused"@
  | E'State'Completed -- ^ @"completed"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'State where toJSON = A.toJSON . fromE'State
instance A.FromJSON E'State where parseJSON o = P.either P.fail (pure . P.id) . toE'State =<< A.parseJSON o
instance WH.ToHttpApiData E'State where toQueryParam = WH.toQueryParam . fromE'State
instance WH.FromHttpApiData E'State where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'State
instance MimeRender MimeMultipartFormData E'State where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'State' enum
fromE'State :: E'State -> Text
fromE'State = \case
  E'State'Updating -> "updating"
  E'State'Paused -> "paused"
  E'State'Completed -> "completed"

-- | parse 'E'State' enum
toE'State :: Text -> P.Either String E'State
toE'State = \case
  "updating" -> P.Right E'State'Updating
  "paused" -> P.Right E'State'Paused
  "completed" -> P.Right E'State'Completed
  s -> P.Left $ "toE'State: enum parse failure: " P.++ P.show s


-- ** E'Status

-- | Enum of 'Text' .
-- Status is one of `none`, `starting`, `healthy` or `unhealthy`  - \"none\"      Indicates there is no healthcheck - \"starting\"  Starting indicates that the container is not yet ready - \"healthy\"   Healthy indicates that the container is running correctly - \"unhealthy\" Unhealthy indicates that the container has a problem 
data E'Status
  = E'Status'None -- ^ @"none"@
  | E'Status'Starting -- ^ @"starting"@
  | E'Status'Healthy -- ^ @"healthy"@
  | E'Status'Unhealthy -- ^ @"unhealthy"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Status where toJSON = A.toJSON . fromE'Status
instance A.FromJSON E'Status where parseJSON o = P.either P.fail (pure . P.id) . toE'Status =<< A.parseJSON o
instance WH.ToHttpApiData E'Status where toQueryParam = WH.toQueryParam . fromE'Status
instance WH.FromHttpApiData E'Status where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Status
instance MimeRender MimeMultipartFormData E'Status where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Status' enum
fromE'Status :: E'Status -> Text
fromE'Status = \case
  E'Status'None -> "none"
  E'Status'Starting -> "starting"
  E'Status'Healthy -> "healthy"
  E'Status'Unhealthy -> "unhealthy"

-- | parse 'E'Status' enum
toE'Status :: Text -> P.Either String E'Status
toE'Status = \case
  "none" -> P.Right E'Status'None
  "starting" -> P.Right E'Status'Starting
  "healthy" -> P.Right E'Status'Healthy
  "unhealthy" -> P.Right E'Status'Unhealthy
  s -> P.Left $ "toE'Status: enum parse failure: " P.++ P.show s


-- ** E'Status2

-- | Enum of 'Text' .
-- String representation of the container state. Can be one of \"created\", \"running\", \"paused\", \"restarting\", \"removing\", \"exited\", or \"dead\". 
data E'Status2
  = E'Status2'Created -- ^ @"created"@
  | E'Status2'Running -- ^ @"running"@
  | E'Status2'Paused -- ^ @"paused"@
  | E'Status2'Restarting -- ^ @"restarting"@
  | E'Status2'Removing -- ^ @"removing"@
  | E'Status2'Exited -- ^ @"exited"@
  | E'Status2'Dead -- ^ @"dead"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Status2 where toJSON = A.toJSON . fromE'Status2
instance A.FromJSON E'Status2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Status2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Status2 where toQueryParam = WH.toQueryParam . fromE'Status2
instance WH.FromHttpApiData E'Status2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Status2
instance MimeRender MimeMultipartFormData E'Status2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Status2' enum
fromE'Status2 :: E'Status2 -> Text
fromE'Status2 = \case
  E'Status2'Created -> "created"
  E'Status2'Running -> "running"
  E'Status2'Paused -> "paused"
  E'Status2'Restarting -> "restarting"
  E'Status2'Removing -> "removing"
  E'Status2'Exited -> "exited"
  E'Status2'Dead -> "dead"

-- | parse 'E'Status2' enum
toE'Status2 :: Text -> P.Either String E'Status2
toE'Status2 = \case
  "created" -> P.Right E'Status2'Created
  "running" -> P.Right E'Status2'Running
  "paused" -> P.Right E'Status2'Paused
  "restarting" -> P.Right E'Status2'Restarting
  "removing" -> P.Right E'Status2'Removing
  "exited" -> P.Right E'Status2'Exited
  "dead" -> P.Right E'Status2'Dead
  s -> P.Left $ "toE'Status2: enum parse failure: " P.++ P.show s


-- ** E'Type

-- | Enum of 'Text'
data E'Type
  = E'Type'Tcp -- ^ @"tcp"@
  | E'Type'Udp -- ^ @"udp"@
  | E'Type'Sctp -- ^ @"sctp"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type where toJSON = A.toJSON . fromE'Type
instance A.FromJSON E'Type where parseJSON o = P.either P.fail (pure . P.id) . toE'Type =<< A.parseJSON o
instance WH.ToHttpApiData E'Type where toQueryParam = WH.toQueryParam . fromE'Type
instance WH.FromHttpApiData E'Type where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type
instance MimeRender MimeMultipartFormData E'Type where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type' enum
fromE'Type :: E'Type -> Text
fromE'Type = \case
  E'Type'Tcp -> "tcp"
  E'Type'Udp -> "udp"
  E'Type'Sctp -> "sctp"

-- | parse 'E'Type' enum
toE'Type :: Text -> P.Either String E'Type
toE'Type = \case
  "tcp" -> P.Right E'Type'Tcp
  "udp" -> P.Right E'Type'Udp
  "sctp" -> P.Right E'Type'Sctp
  s -> P.Left $ "toE'Type: enum parse failure: " P.++ P.show s


-- ** E'Type2

-- | Enum of 'Text' .
-- The mount type:  - `bind` a mount of a file or directory from the host into the container. - `volume` a docker volume with the given `Name`. - `tmpfs` a `tmpfs`. - `npipe` a named pipe from the host into the container. 
data E'Type2
  = E'Type2'Bind -- ^ @"bind"@
  | E'Type2'Volume -- ^ @"volume"@
  | E'Type2'Tmpfs -- ^ @"tmpfs"@
  | E'Type2'Npipe -- ^ @"npipe"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type2 where toJSON = A.toJSON . fromE'Type2
instance A.FromJSON E'Type2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type2 where toQueryParam = WH.toQueryParam . fromE'Type2
instance WH.FromHttpApiData E'Type2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type2
instance MimeRender MimeMultipartFormData E'Type2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type2' enum
fromE'Type2 :: E'Type2 -> Text
fromE'Type2 = \case
  E'Type2'Bind -> "bind"
  E'Type2'Volume -> "volume"
  E'Type2'Tmpfs -> "tmpfs"
  E'Type2'Npipe -> "npipe"

-- | parse 'E'Type2' enum
toE'Type2 :: Text -> P.Either String E'Type2
toE'Type2 = \case
  "bind" -> P.Right E'Type2'Bind
  "volume" -> P.Right E'Type2'Volume
  "tmpfs" -> P.Right E'Type2'Tmpfs
  "npipe" -> P.Right E'Type2'Npipe
  s -> P.Left $ "toE'Type2: enum parse failure: " P.++ P.show s


-- ** E'Type3

-- | Enum of 'Text' .
-- The type of object emitting the event
data E'Type3
  = E'Type3'Builder -- ^ @"builder"@
  | E'Type3'Config -- ^ @"config"@
  | E'Type3'Container -- ^ @"container"@
  | E'Type3'Daemon -- ^ @"daemon"@
  | E'Type3'Image -- ^ @"image"@
  | E'Type3'Network -- ^ @"network"@
  | E'Type3'Node -- ^ @"node"@
  | E'Type3'Plugin -- ^ @"plugin"@
  | E'Type3'Secret -- ^ @"secret"@
  | E'Type3'Service -- ^ @"service"@
  | E'Type3'Volume -- ^ @"volume"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type3 where toJSON = A.toJSON . fromE'Type3
instance A.FromJSON E'Type3 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type3 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type3 where toQueryParam = WH.toQueryParam . fromE'Type3
instance WH.FromHttpApiData E'Type3 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type3
instance MimeRender MimeMultipartFormData E'Type3 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type3' enum
fromE'Type3 :: E'Type3 -> Text
fromE'Type3 = \case
  E'Type3'Builder -> "builder"
  E'Type3'Config -> "config"
  E'Type3'Container -> "container"
  E'Type3'Daemon -> "daemon"
  E'Type3'Image -> "image"
  E'Type3'Network -> "network"
  E'Type3'Node -> "node"
  E'Type3'Plugin -> "plugin"
  E'Type3'Secret -> "secret"
  E'Type3'Service -> "service"
  E'Type3'Volume -> "volume"

-- | parse 'E'Type3' enum
toE'Type3 :: Text -> P.Either String E'Type3
toE'Type3 = \case
  "builder" -> P.Right E'Type3'Builder
  "config" -> P.Right E'Type3'Config
  "container" -> P.Right E'Type3'Container
  "daemon" -> P.Right E'Type3'Daemon
  "image" -> P.Right E'Type3'Image
  "network" -> P.Right E'Type3'Network
  "node" -> P.Right E'Type3'Node
  "plugin" -> P.Right E'Type3'Plugin
  "secret" -> P.Right E'Type3'Secret
  "service" -> P.Right E'Type3'Service
  "volume" -> P.Right E'Type3'Volume
  s -> P.Left $ "toE'Type3: enum parse failure: " P.++ P.show s


-- ** E'Type4

-- | Enum of 'Text'
data E'Type4
  = E'Type4'Json_file -- ^ @"json-file"@
  | E'Type4'Syslog -- ^ @"syslog"@
  | E'Type4'Journald -- ^ @"journald"@
  | E'Type4'Gelf -- ^ @"gelf"@
  | E'Type4'Fluentd -- ^ @"fluentd"@
  | E'Type4'Awslogs -- ^ @"awslogs"@
  | E'Type4'Splunk -- ^ @"splunk"@
  | E'Type4'Etwlogs -- ^ @"etwlogs"@
  | E'Type4'None -- ^ @"none"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type4 where toJSON = A.toJSON . fromE'Type4
instance A.FromJSON E'Type4 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type4 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type4 where toQueryParam = WH.toQueryParam . fromE'Type4
instance WH.FromHttpApiData E'Type4 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type4
instance MimeRender MimeMultipartFormData E'Type4 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type4' enum
fromE'Type4 :: E'Type4 -> Text
fromE'Type4 = \case
  E'Type4'Json_file -> "json-file"
  E'Type4'Syslog -> "syslog"
  E'Type4'Journald -> "journald"
  E'Type4'Gelf -> "gelf"
  E'Type4'Fluentd -> "fluentd"
  E'Type4'Awslogs -> "awslogs"
  E'Type4'Splunk -> "splunk"
  E'Type4'Etwlogs -> "etwlogs"
  E'Type4'None -> "none"

-- | parse 'E'Type4' enum
toE'Type4 :: Text -> P.Either String E'Type4
toE'Type4 = \case
  "json-file" -> P.Right E'Type4'Json_file
  "syslog" -> P.Right E'Type4'Syslog
  "journald" -> P.Right E'Type4'Journald
  "gelf" -> P.Right E'Type4'Gelf
  "fluentd" -> P.Right E'Type4'Fluentd
  "awslogs" -> P.Right E'Type4'Awslogs
  "splunk" -> P.Right E'Type4'Splunk
  "etwlogs" -> P.Right E'Type4'Etwlogs
  "none" -> P.Right E'Type4'None
  s -> P.Left $ "toE'Type4: enum parse failure: " P.++ P.show s


-- ** LocalNodeState

-- | Enum of 'Text' .
-- Current local status of this node.
data LocalNodeState
  = LocalNodeState'Empty -- ^ @""@
  | LocalNodeState'Inactive -- ^ @"inactive"@
  | LocalNodeState'Pending -- ^ @"pending"@
  | LocalNodeState'Active -- ^ @"active"@
  | LocalNodeState'Error -- ^ @"error"@
  | LocalNodeState'Locked -- ^ @"locked"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON LocalNodeState where toJSON = A.toJSON . fromLocalNodeState
instance A.FromJSON LocalNodeState where parseJSON o = P.either P.fail (pure . P.id) . toLocalNodeState =<< A.parseJSON o
instance WH.ToHttpApiData LocalNodeState where toQueryParam = WH.toQueryParam . fromLocalNodeState
instance WH.FromHttpApiData LocalNodeState where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toLocalNodeState
instance MimeRender MimeMultipartFormData LocalNodeState where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'LocalNodeState' enum
fromLocalNodeState :: LocalNodeState -> Text
fromLocalNodeState = \case
  LocalNodeState'Empty -> ""
  LocalNodeState'Inactive -> "inactive"
  LocalNodeState'Pending -> "pending"
  LocalNodeState'Active -> "active"
  LocalNodeState'Error -> "error"
  LocalNodeState'Locked -> "locked"

-- | parse 'LocalNodeState' enum
toLocalNodeState :: Text -> P.Either String LocalNodeState
toLocalNodeState = \case
  "" -> P.Right LocalNodeState'Empty
  "inactive" -> P.Right LocalNodeState'Inactive
  "pending" -> P.Right LocalNodeState'Pending
  "active" -> P.Right LocalNodeState'Active
  "error" -> P.Right LocalNodeState'Error
  "locked" -> P.Right LocalNodeState'Locked
  s -> P.Left $ "toLocalNodeState: enum parse failure: " P.++ P.show s


-- ** NodeState

-- | Enum of 'Text' .
-- NodeState represents the state of a node.
data NodeState
  = NodeState'Unknown -- ^ @"unknown"@
  | NodeState'Down -- ^ @"down"@
  | NodeState'Ready -- ^ @"ready"@
  | NodeState'Disconnected -- ^ @"disconnected"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON NodeState where toJSON = A.toJSON . fromNodeState
instance A.FromJSON NodeState where parseJSON o = P.either P.fail (pure . P.id) . toNodeState =<< A.parseJSON o
instance WH.ToHttpApiData NodeState where toQueryParam = WH.toQueryParam . fromNodeState
instance WH.FromHttpApiData NodeState where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toNodeState
instance MimeRender MimeMultipartFormData NodeState where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'NodeState' enum
fromNodeState :: NodeState -> Text
fromNodeState = \case
  NodeState'Unknown -> "unknown"
  NodeState'Down -> "down"
  NodeState'Ready -> "ready"
  NodeState'Disconnected -> "disconnected"

-- | parse 'NodeState' enum
toNodeState :: Text -> P.Either String NodeState
toNodeState = \case
  "unknown" -> P.Right NodeState'Unknown
  "down" -> P.Right NodeState'Down
  "ready" -> P.Right NodeState'Ready
  "disconnected" -> P.Right NodeState'Disconnected
  s -> P.Left $ "toNodeState: enum parse failure: " P.++ P.show s


-- ** Reachability

-- | Enum of 'Text' .
-- Reachability represents the reachability of a node.
data Reachability
  = Reachability'Unknown -- ^ @"unknown"@
  | Reachability'Unreachable -- ^ @"unreachable"@
  | Reachability'Reachable -- ^ @"reachable"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON Reachability where toJSON = A.toJSON . fromReachability
instance A.FromJSON Reachability where parseJSON o = P.either P.fail (pure . P.id) . toReachability =<< A.parseJSON o
instance WH.ToHttpApiData Reachability where toQueryParam = WH.toQueryParam . fromReachability
instance WH.FromHttpApiData Reachability where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toReachability
instance MimeRender MimeMultipartFormData Reachability where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'Reachability' enum
fromReachability :: Reachability -> Text
fromReachability = \case
  Reachability'Unknown -> "unknown"
  Reachability'Unreachable -> "unreachable"
  Reachability'Reachable -> "reachable"

-- | parse 'Reachability' enum
toReachability :: Text -> P.Either String Reachability
toReachability = \case
  "unknown" -> P.Right Reachability'Unknown
  "unreachable" -> P.Right Reachability'Unreachable
  "reachable" -> P.Right Reachability'Reachable
  s -> P.Left $ "toReachability: enum parse failure: " P.++ P.show s


-- ** TaskState

-- | Enum of 'Text'
data TaskState
  = TaskState'New -- ^ @"new"@
  | TaskState'Allocated -- ^ @"allocated"@
  | TaskState'Pending -- ^ @"pending"@
  | TaskState'Assigned -- ^ @"assigned"@
  | TaskState'Accepted -- ^ @"accepted"@
  | TaskState'Preparing -- ^ @"preparing"@
  | TaskState'Ready -- ^ @"ready"@
  | TaskState'Starting -- ^ @"starting"@
  | TaskState'Running -- ^ @"running"@
  | TaskState'Complete -- ^ @"complete"@
  | TaskState'Shutdown -- ^ @"shutdown"@
  | TaskState'Failed -- ^ @"failed"@
  | TaskState'Rejected -- ^ @"rejected"@
  | TaskState'Remove -- ^ @"remove"@
  | TaskState'Orphaned -- ^ @"orphaned"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON TaskState where toJSON = A.toJSON . fromTaskState
instance A.FromJSON TaskState where parseJSON o = P.either P.fail (pure . P.id) . toTaskState =<< A.parseJSON o
instance WH.ToHttpApiData TaskState where toQueryParam = WH.toQueryParam . fromTaskState
instance WH.FromHttpApiData TaskState where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toTaskState
instance MimeRender MimeMultipartFormData TaskState where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'TaskState' enum
fromTaskState :: TaskState -> Text
fromTaskState = \case
  TaskState'New -> "new"
  TaskState'Allocated -> "allocated"
  TaskState'Pending -> "pending"
  TaskState'Assigned -> "assigned"
  TaskState'Accepted -> "accepted"
  TaskState'Preparing -> "preparing"
  TaskState'Ready -> "ready"
  TaskState'Starting -> "starting"
  TaskState'Running -> "running"
  TaskState'Complete -> "complete"
  TaskState'Shutdown -> "shutdown"
  TaskState'Failed -> "failed"
  TaskState'Rejected -> "rejected"
  TaskState'Remove -> "remove"
  TaskState'Orphaned -> "orphaned"

-- | parse 'TaskState' enum
toTaskState :: Text -> P.Either String TaskState
toTaskState = \case
  "new" -> P.Right TaskState'New
  "allocated" -> P.Right TaskState'Allocated
  "pending" -> P.Right TaskState'Pending
  "assigned" -> P.Right TaskState'Assigned
  "accepted" -> P.Right TaskState'Accepted
  "preparing" -> P.Right TaskState'Preparing
  "ready" -> P.Right TaskState'Ready
  "starting" -> P.Right TaskState'Starting
  "running" -> P.Right TaskState'Running
  "complete" -> P.Right TaskState'Complete
  "shutdown" -> P.Right TaskState'Shutdown
  "failed" -> P.Right TaskState'Failed
  "rejected" -> P.Right TaskState'Rejected
  "remove" -> P.Right TaskState'Remove
  "orphaned" -> P.Right TaskState'Orphaned
  s -> P.Left $ "toTaskState: enum parse failure: " P.++ P.show s



